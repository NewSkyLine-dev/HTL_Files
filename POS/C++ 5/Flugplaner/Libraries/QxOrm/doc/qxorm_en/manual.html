<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
  <title>QxOrm : C++ Qt ORM Object Relational Mapping database library - QxEntityEditor : C++ Qt entities graphic editor (data model designer and source code generator)</title>
  <link rel='stylesheet' type='text/css' href='./resource/qxorm_style.css'>
  <script type="text/javascript" src="./resource/jquery.min.js"></script>
  <script type="text/javascript" src="./resource/qxorm_script.js"></script>
</head>
<body>
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col>
  <tbody>
    <tr>
      <td><a href="./home.html"><img alt="QxOrm" src="./resource/logo_qxorm_and_qxee.png"align="left" border="0"></a></td>
      <td align="right" style="vertical-align:bottom"><div id="qx_search"><gcse:search></gcse:search></div></td>
      <td width="15"></td>
      <td align="right" style="vertical-align:bottom">
        <img alt="Windows" src="./resource/logo_windows.gif" width="35" height="35">
        <img alt="Linux" src="./resource/logo_linux.gif" width="35" height="35">
        <img alt="Macintosh" src="./resource/logo_mac.gif" width="35" height="35">
      </td>
      <td width="70"><img alt="C++" src="./resource/logo_cpp.gif" width="50" height="50" align="right"></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody>
    <tr>
      <td align="center"><a href="./home.html" class="btn_nav">Home</a></td>
      <td align="center"><a href="./download.html" class="btn_nav">Download</a></td>
      <td align="center"><a href="./quick_sample.html" class="btn_nav">Quick sample</a></td>
      <td align="center" onmouseover="showHideElementById('menu_tuto', true);" onmouseout="showHideElementById('menu_tuto', false);">
         <a href="./tutorial.html" class="btn_nav">Tutorial (4)</a>
         <table class="table_menu_tuto"><tbody><tr><td>
            <div id="menu_tuto" class="div_menu_tuto">
               <a href="./tutorial_3.html" class="btn_sub_menu">install QxOrm</a><br/>
               <a href="./tutorial.html" class="btn_sub_menu">qxBlog</a><br/>
               <a href="./tutorial_2.html" class="btn_sub_menu">qxClientServer</a><br/>
               <a href="./tutorial_4.html" class="btn_sub_menu">QxEntityEditor videos</a>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center" onmouseover="showHideElementById('menu_manual', true);" onmouseout="showHideElementById('menu_manual', false);">
         <a href="./manual.html" class="btn_nav">Manual (2)</a>
         <table class="table_menu_manual"><tbody><tr><td>
            <div id="menu_manual" class="div_menu_manual">
               <a href="./manual.html" class="btn_sub_menu">QxOrm manual</a><br/>
               <a href="./manual_qxee.html" class="btn_sub_menu">QxEntityEditor manual</a><br/>
            </div>
         </td></tr></tbody></table>
      </td>
      <td align="center"><a href="./link.html" class="btn_nav">Forum</a></td>
      <td align="center"><a href="./customer.html" class="btn_nav">Our customers</a></td>
    </tr>
  </tbody>
</table>
<hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col><col><col><col>
  <tbody><tr>
  <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm  &gt;&gt;  Manual - QxOrm library user guide</font></td>
  <td align="right" valign="top">
    <table cellspacing="0" cellpadding="1"><col><col><tbody>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow">Current version :&nbsp;</font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxOrm 1.5.0 - <a href="../doxygen/index.html" target="_blank">QxOrm library online class documentation</a> - <a href="https://github.com/QxOrm/QxOrm" target="_blank">GitHub</a></font></td>
      </tr>
      <tr>
         <td align="right" valign="top"><font size="2" class="txt_with_shadow"></font></td>
         <td align="left" valign="top"><font size="2" class="txt_with_shadow">QxEntityEditor 1.2.8</font></td>
      </tr>
    </tbody></table>
  </td>
  <td width="10px"></td>
  <td width="40px" height="30px"><a href="../qxorm_fr/manual.html"><img alt="Version française du site" src="./resource/FR.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="../qxorm_en/manual.html"><img alt="Web site english version" src="./resource/GB.png" width="40" height="30" border="0"></a></td>
  <td width="40px" height="30px"><a href="http://sites.google.com/site/qxormpostgres/" target="_blank"><img alt="" src="./resource/ES.png" width="40" height="30" border="0"></a></td>
  </tr></tbody>
</table>
<table border="1" frame="vsides" rules="cols" style="width: 80%" align="center" cellpadding="6" bgcolor="#F2F2F4">
  <col>
  <tbody>
    <tr>
      <td align="justify">
      <script>$(function() { initQxOrmManualWebPage(); });</script>
      <table border="0" cellpadding="4">
       <col><col>
       <tbody>
         <tr>
           <td><font class="txt_with_shadow" color="#0B0B61" size="4"><i>Select a manual : </i></font></td>
           <td align="left">
             <a href="./manual.html" class="btn_tuto_selected">QxOrm user guide</a>
             <a href="./manual_qxee.html" class="btn_tuto">QxEntityEditor user guide</a>
           </td>
         </tr>
       </tbody>
      </table>
      <hr style="width: 100%" align="center" size="1" color="#100D5A">
      <br>
      <table border="0" style="width: 100%" align="center">
      <col><col>
         <tbody>
            <tr>
               <td>
                  <h3 class="txt_slogan"><b>QxOrm library manual - Table of Contents</b></h3>
                  <div id="manual_table_of_contents">
                  <ol class="manual_manual_ol_title_1" type="I">
                     <li class="manual_li_title_1">
                        <a href="#manual_10">Introduction</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_100">QxOrm library</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_110">Quick overview of QxEntityEditor application</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_120">C++ coding style of QxOrm library</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_20">Installation</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_200">Qt dependency</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_210">Boost dependency (optional)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_230">Build QxOrm library (with qmake or CMake)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_240">Qt SQL drivers (supported databases)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_30">Persistence - Object Relational Mapping (ORM)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_300">Register a class in QxOrm context (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3000">Primary key other than default type "long"</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3010">Composite primary key</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3020">public or protected/private data members</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3030">Namespace</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3040">Built-in C++ supported types</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3050">Register a transient data member</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_310">Connection to database</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_320">Persist a C++ instance in database (insert/update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_340">Delete an instance in database (delete)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3400">Soft delete behaviour (logical delete)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_350">Get a C++ instance from database (fetch)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_360">SQL queries</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3610">Using standard SQL or stored procedure</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_370">Transactions (commit, rollback, session)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_380">Relationships</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3800">one-to-many (1-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3810">many-to-one (n-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3820">many-to-many (n-n)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3830">one-to-one (1-1)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3840">Fetch relationships</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3850">Select columns fetching relationships and define custom SQL alias</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3855">Add SQL query inside LEFT OUTER JOIN / INNER JOIN</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_390">Supported containers</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3900">Qt containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3910">Boost containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3920">std containers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_3930">qx::QxCollection</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_400">Supported smart pointers</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4000">Qt smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4010">Boost smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4020">std smart pointers</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4030">qx::dao::ptr</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_410">Triggers</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_420">Validators</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_430">Manage NULL database value</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4300">boost::optional</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_4310">QVariant</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_440">Inheritance and polymorphism</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_450">qx::IxPersistable interface (abstract class)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_455">Use PIMPL C++ pattern (Private Implementation idiom or d-pointer)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_460">Persist custom type</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_470">Generate database DDL SQL schema</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_475">Associate a SQL type to a C++ class</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_480">Async database queries</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_490">Cache to store C++ instances (QxCache module)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_500">Working with several databases</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_510">Register an abstract class in QxOrm context</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_520">Register automatically Qt meta-properties (<i>Q_PROPERTY</i> macro)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_60">Serialization</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_605">Version number to manage ascendant compatibility</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_600">Qt QDataStream engine</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_606">Qt JSON engine</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_610">XML boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_620">Binary boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_630">Other boost serialization</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_640">Clone a C++ instance</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_650">Dump a C++ instance (XML or JSON format)</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_70">Introspection - Reflection</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_710">Get a data member value dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_720">Set a data member value dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_730">Call function dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_740">Create a C++ instance dynamically</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_750">Iterate over all classes/properties registered in QxOrm context</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_80">Services : transfer persistent data layer over network (QxService module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_810">Input/output service parameters (request/response)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_820">Define service functions exposed to clients</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_825">List of options available on server side</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_826">Connection settings on client side</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_830">Service authentication</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_840">Async client/server queries</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_90">Model View engine (QxModelView module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_910">Simple model (without relationship)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_920">Model with relationships (nested models)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_940">Interaction with QML views</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_950">Interaction with QtWidget views</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_960">Connect model to QxService module</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_95">QxOrm and MongoDB database (C++ ODM Object Document Mapper)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_980">Prerequisites : driver <i>libmongoc</i> and <i>libbson</i></a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_981">QxOrm.pri (or QxOrm.cmake) configuration file</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_982">Connection to MongoDB database</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_983">Register a MongoDB persistent class (Collection) in QxOrm context (mapping)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9830">Manage ObjectId (primary key)</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_984">Insert a C++ instance (Document) in MongoDB database</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9840">Insert many C++ instances (list of Documents) in MongoDB database</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_986">Update a C++ instance (Document) in MongoDB database</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9860">Update many C++ instances (list of Documents) in MongoDB database</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_988">Delete a C++ instance (Document) from MongoDB database</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9880">Delete many C++ instances (list of Documents) from MongoDB database</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_990">Fetch a C++ instance (Document) from MongoDB database</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9900">Fetch many C++ instances (list of Documents) from MongoDB database</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_992">JSON queries</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9920">Using qx::QxSqlQuery class (or qx_query alias)</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9921">Using MongoDB aggregation framework</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9922">Add 'sort', 'limit', 'skip', etc..., properties to JSON query</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9923">Execute a custom query</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_993">Relationships engine (MongoDB version 3.6 or + is required)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9930">Embedded vs Referenced</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_994">Create automatically indexes</a>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_96">HTTP/HTTPS web server (QxHttpServer module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_995">Hello World !</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_996">HTTP/HTTPS web server settings</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9961">Secured connections SSL/TLS</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_997">Routing URL (dispatcher / endpoints)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9962">Dynamic URL routing</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_856">Get HTTP request parameters</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_857">Build HTTP response</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_998">Sessions (storage per client on server side)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_999">Cookies</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_851">Static files</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_852">Chunked responses</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_853">Requests using JSON API (QxRestApi module)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_854">WebSocket</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_855">Performance (tested with Apache Benchmark)</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_8550">Improve performance with epoll dispatcher on Linux</a>
                                 </li>
                              </ol>
                           </li>
                        </ol>
                     </li>
                     <li class="manual_li_title_1">
                        <a href="#manual_97">JSON REST API (QxRestApi module)</a>
                        <ol class="manual_ol_title_2" type="1">
                           <li class="manual_li_title_2">
                              <a href="#manual_971">How it works</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9710">Use cases</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_972">qxBlogRestApi example project (QML and HTTP web server)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_973">Fetch</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9731">fetch_all</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9732">fetch_by_id</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9733">fetch_by_query</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9734">count</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9735">exist</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_974">Insert</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_975">Update</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_976">Save (insert or update)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_977">Delete</a>
                              <ol class="manual_ol_title_3" type="a">
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9771">delete_all / destroy_all</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9772">delete_by_query / destroy_by_query</a>
                                 </li>
                                 <li class="manual_li_title_3">
                                    <a href="#manual_9773">delete_by_id / destroy_by_id</a>
                                 </li>
                              </ol>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_978">Validate</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_979">Custom SQL query or stored procedure</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_961">Call C++ natives functions</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_962">Meta-data (C++ classes registered into QxOrm context)</a>
                           </li>
                           <li class="manual_li_title_2">
                              <a href="#manual_963">Send a list of JSON requests</a>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  </div>
               </td>
               <td width="200" align="center" valign="top"><a href="./resource/qt_ambassador_logo.png" target="_blank"><img alt="qt_ambassador" src="./resource/qt_ambassador_logo_150x150.png" width="150" height="150" border="0"></a><br>
                  <b><font size="2">QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a></font></b>
               </td>
            </tr>
         </tbody>
      </table>
      <br>
      <hr width="90%">
      <div id="manual_content">

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_10">Introduction</a></p>
      <div class="manual_div_content_1">
         The goal of this documentation is to provide a user guide to learn how to work with <b>QxOrm</b> library features.
         This manual is intended for developers and software architects who are looking for a solution to manage a persistent data layer in C++/Qt.
         Technical skills in C++ and databases are required to understand this document.
         <br><br>
         <b>Note :</b> all features described in this manual/user guide can be defined quickly and easily with <b>QxEntityEditor</b> application (the graphic editor for <b>QxOrm</b> library, data model designer and source code generator).
         <a href="./manual_qxee.html">Another documentation dedicated to <b>QxEntityEditor</b> application is available on QxOrm website.</a>
         <br><br>
         <b>Other note :</b> this manual is based on <a href="./faq.html">the old FAQ of QxOrm website, you can always access to this FAQ here</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_100">QxOrm library</a></p>
         <div class="manual_div_content">
           <b>QxOrm is a C++ library designed to provide <i>Object Relational Mapping (ORM)</i> feature to C++ users.<br>
           QxOrm is developed by Lionel Marty, a software development engineer since 2003.</b>
           <br><br>
           Based on a simple <b>C++ setting function per class</b> (like <a href="http://hibernate.org/" target="_blank"><i>Hibernate</i></a> XML mapping file in Java), <b>QxOrm</b> library provides following features :
           <ul>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_30">Persistence</a></font></b> : support most common databases like SQLite, MySQL, PostgreSQL, Oracle, MS SQL Server, <a href="./manual.html#manual_95">MongoDB</a> (with <i>1-1</i>, <i>1-n</i>, <i>n-1</i> and <i>n-n</i> relationships) ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_60">Serialization</a></font></b> : JSON, binary and XML format ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_70">Reflection</a></font></b> (or <b><font style="background-color:yellow"><a href="./manual.html#manual_70">introspection</a></font></b>) : access dynamically to classes definitions, retrieve properties and call classes methods ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_96">HTTP web server</a></font></b> : standalone multi-threaded HTTP 1.1 web server (support SSL/TLS, persistent connections, cookies, sessions, chunked responses, URL dispatcher/routing) ;</li>
             <li><b><font style="background-color:yellow"><a href="./manual.html#manual_97">JSON API</a></font></b> : interoperability with other technology than C++/Qt (REST web services, QML applications, scripting language).</li>
           </ul>
           QxOrm depends on <a href="http://www.qt.io/" target="_blank"><b>Qt</b></a> (from version 4.5.0) and <a href="http://www.boost.org/" target="_blank"><b>boost</b></a> (from version 1.38, and by default just header files <i>*.hpp</i> are necessary).<br>
           QxOrm library has been accepted into the <a href="http://forum.qt.io/category/24/qt-ambassador-program" target="_blank">Qt Ambassador Program</a>.
           <br><br>
           If you find a bug or if you have a question about <b>QxOrm</b> library, you can send an e-mail to : <u><i>support@qxorm.com</i></u>.<br>
           A forum dedicated to <b>QxOrm</b> library is available <a href="https://www.qxorm.com/forum/phpbb/" target="_blank">here</a>.<br>
           If you speak/understand french, you can access to <a href="http://www.developpez.net/forums/f1563/c-cpp/bibliotheques/qt/bases-donnees/qxorm/" target="_blank">the french community on the famous <i>developpez.com</i> forum</a>.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_110">Quick overview of QxEntityEditor application</a></p>
         <div class="manual_div_content">
           <b>QxEntityEditor</b> is a graphic editor for <b>QxOrm</b> library : <b>QxEntityEditor</b> provides a graphic way to manage the data model.<br>
           <b>QxEntityEditor</b> is multi-platform (available for Windows, Linux and Mac OS X) and generates native code for all environments : desktop (Windows, Linux, Mac OS X), embedded and mobile (Android, iOS, Windows Phone, Raspberry Pi, etc.).<br>
           <a href="./tutorial_4.html">A presentation video of <b>QxEntityEditor</b> application is available on YouTube</a>.<br>
           <br>
           <b>QxEntityEditor</b> is based on plugins and provides many ways to import/export your data model :
           <ul>
             <li>generate C++ persistent classes automatically (registered in QxOrm context) ;</li>
             <li>generate DDL SQL script automatically (database schema) for SQLite, MySQL, PostgreSQL, Oracle and MS SQL Server ;</li>
             <li>manage schema evolution for each project version (<i>ALTER TABLE</i>, <i>ADD COLUMN</i>, <i>DROP INDEX</i>, etc.) ;</li>
             <li>transfer your data model over network and create quickly client/server applications, using <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module ;</li>
             <li>import existing database structure (using ODBC connection) for SQLite, MySQL, PostgreSQL, Oracle and MS SQL Server databases ;</li>
             <li>because each project is different, QxEntityEditor provides several ways to customize generated files (especially a javascript engine and an integrated debugger).</li>
           </ul>
           <a href="../qxentityeditor/resource/qxee_sample.png" target="_blank"><img alt="QxEntityEditor" src="../qxentityeditor/resource/qxee_sample_small.png" border="0" class="img_with_shadow"></a>
           <br><br>
           <b>QxEntityEditor</b> is developed by Lionel Marty, a software development engineer since 2003.<br>
           <a href="./manual_qxee.html">A manual dedicated to <b>QxEntityEditor</b> application is available on QxOrm website.</a>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_120">C++ coding style of QxOrm library</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses following syntax and naming convention for C++ source code :
           <ul><li>all classes, functions, properties, etc... are defined under <a href="./resource/qxorm.namespace.qx.jpg"><i>namespace qx</i></a> ;
           </li><li>all macros of QxOrm library are prefixed by <i>QX_...</i> ;
           </li><li>all abstracts classes (or interfaces) start with prefix <i>Ix</i> (for example <i>IxFactory</i> is an interface to create an instance of object) ;
           </li><li>other classes start with prefix <i>Qx</i> (for example <i>QxDataMember</i>) ;
           </li><li>containers of objects end with suffix <i>X</i> (for example <i>QxDataMemberX</i> is a list of <i>QxDataMember</i>) ;
           </li><li>functions to interact with databases are under <a href="./resource/qxorm.namespace.qx.dao.jpg"><i>namespace qx::dao</i></a> (for example <i>qx::dao::fetch_by_id()</i>) ;
           </li><li>functions to <i>serialize</i> are under <a href="./resource/qxorm.namespace.qx.serialization.jpg"><i>namespace qx::serialization</i></a> (for example <i>qx::serialization::xml::to_file()</i>) ;
           </li><li>the <i>reflection</i> (or <i>introspection</i>) engine can be used with <b><i>qx::QxClassX</i></b> class (for example <i>qx::QxClassX::invoke()</i> to call a class method) ;
           </li><li>all traits classes are under <a href="./resource/qxorm.namespace.qx.trait.jpg"><i>namespace qx::trait</i></a> (for example <i>qx::trait::is_smart_ptr&lt;T&gt;</i>).
           </li></ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_20">Installation</a></p>
      <div class="manual_div_content_1">
         <b>QxOrm</b> library is multi-platform and can be installed on all environments : Windows, Linux, Mac OS X, Android, iOS, Windows Phone, Raspberry Pi, etc...<br>
         <a href="./tutorial_3.html">A full tutorial (with screenshots) to install a development environment with QxOrm on Windows is available here.</a>
         <br><br>
         The goal of this chapter is to explain all steps required to install <b>QxOrm</b> library on all environments :
         <ul>
            <li><a href="#manual_200">Download and install Qt framework ;</a></li>
            <li><a href="#manual_210">Download and unzip boost library (optional) ;</a></li>
            <li><a href="#manual_220">Configure <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file ;</a></li>
            <li><a href="#manual_230">Build QxOrm library (with qmake or CMake) ;</a></li>
            <li><a href="#manual_240">Check SQL drivers provided by Qt.</a></li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_200">Qt dependency</a></p>
         <div class="manual_div_content">
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://www.qt.io/" target="_blank"><img alt="Qt" src="./resource/logo_qt.jpg" width="42" height="50" border="0"></a></td>
                 <td align="justify"><b>Qt</b> : cross-platform application development framework : GUI (<i>QtGui</i>), network (<i>QtNetwork</i>), XML (<i>QtXml</i>), database (<i>QtSql</i>)...<br>
                 Qt provides excellent support and documentation. Using Qt, you can write simple and powerful C++ code.<br>
                 Qt is produced by Digia's Qt Development Frameworks division and is available under LGPL license.<br>
                 QxOrm is compatible with many Qt's objects : <i>QObject, QString, QDate, QTime, QDateTime, QList, QHash, QSharedPointer, QScopedPointer...</i><br>
                 It is recommended to install the latest version of Qt available at the following address : <a href="http://www.qt.io/" target="_blank">http://www.qt.io/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Note :</b> by default, <b>QxOrm</b> library depends only on <a href="http://doc.qt.io/qt-5/qtcore-index.html" target="_blank">QtCore</a> and <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql</a> binaries.
           It is possible to enable extra features in the <a href="#manual_220"><i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file</a> : some features can add dependencies to QxOrm library.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_210">Boost dependency (optional)</a></p>
         <div class="manual_div_content">
           By default, QxOrm library depends only on Qt (<i>QtCore</i> and <i>QtSql</i>).
           boost installation is optional and not required with default configuration.
           <br/>
           <b>Note :</b> QxOrm provides 2 dependency levels on boost :
           <ul>
             <li>dependency only on boost headers files (<i>*.hpp</i>) : <i>_QX_ENABLE_BOOST</i> compilation option ;</li>
             <li>dependency on <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost serialization</a> module : <i>_QX_ENABLE_BOOST_SERIALIZATION</i> compilation option.</li>
           </ul>
           <br/>
           <table border="0" style="width: 100%" align="center">
             <col><col>
             <tbody>
               <tr>
                 <td valign="middle" width="161" align="center"><a href="http://www.boost.org/" target="_blank"><img alt="boost" src="./resource/logo_boost.jpg" width="161" height="50" border="0"></a></td>
                 <td align="justify"><b>boost</b> : many of boost's founders are on the C++ standard committee and several boost libraries have been accepted for incorporation into C++1x (new standard for the C++ programming language).
                 The boost's libraries are aimed at a wide range of C++ users and application domains.<br>
                 QxOrm uses the following boost's features (header files <i>*.hpp</i> only, boost <i>serialization</i> dependency is optional) : <i>smart_pointer, type_traits, multi_index_container, unordered_container, any, tuple, foreach, function.</i><br>
                 It is recommended to get the latest version of boost available at the following address : <a href="http://www.boost.org/" target="_blank">http://www.boost.org/</a></td>
               </tr>
             </tbody>
           </table>
           <br>
           <b>Important note :</b> with <i>_QX_ENABLE_BOOST</i> compilation option, <b>QxOrm</b> library depends only on <i>*.hpp</i> boost header files (<i>header only</i> libraries).
           So in this case, boost installation is very easy because you just have to unzip boost package (to get <i>*.hpp</i> header files, there is nothing to build).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a></p>
         <div class="manual_div_content">
            <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file is divided into several sections (each section is commented) and provides all settings and compilation options available to customize QxOrm library features.
            So it is strongly recommended to read carefully <i>QxOrm.pri</i> configuration file before compiling and building QxOrm library.
            It is possible to keep default settings, only <b>QX_BOOST_INCLUDE_PATH</b> variable is required if you work with boost : this variable is used to define where <i>*.hpp</i> boost header files are located :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>isEmpty(QX_BOOST_INCLUDE_PATH) { QX_BOOST_INCLUDE_PATH = $$quote(<font style="background-color:yellow">D:/Dvlp/_Libs/Boost/1_57/include</font>) }</i>   </pre>
            </td></tr></tbody></table>
            <br>
            If you don't want to change <i>QxOrm.pri</i> configuration file, it is possible to define an environment variable named <b>BOOST_INCLUDE</b> : this environment variable will be used automatically to set <b>QX_BOOST_INCLUDE_PATH</b> value (read <i>QxOrm.pri</i> configuration file for more details).
            <br><br>
            Here is a list of compilation options available in <i>QxOrm.pri</i> configuration file, by default they are all disabled :
            <ul>
               <li><b>_QX_ENABLE_BOOST :</b> add a dependency to boost headers files (<i>*.hpp</i>), support some classes like : <i>boost::shared_ptr</i>, <i>boost::optional</i>, <i>boost::container</i>, etc... ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION :</b> enable <a href="#manual_610">boost::serialization engine</a>. This option requires to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary and adds a dependency to QxOrm library ;</li>
               <br>
               <li><b>_QX_ENABLE_QT_GUI :</b> support serialization of <a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a> types : <i>QBrush, QColor, QFont, QImage, QMatrix, QPicture, QPixmap, QRegion</i>. This option adds a dependency to QxOrm library (<a href="http://doc.qt.io/qt-5/qtgui-index.html" target="_blank">QtGui</a>) ;</li>
               <li><b>_QX_ENABLE_QT_NETWORK :</b> enable <a href="#manual_80">QxService module</a> to transfer persistent data layer over network (client/server application). This option adds a dependency to QxOrm library (<a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a>) ;</li>
               <li><b>_QX_NO_PRECOMPILED_HEADER :</b> disable precompiled header (used to reduce compilation times of a project) : this option is required <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56926" target="_blank">with recent versions of MinGW (because of a known compiler bug)</a>, for all other compilers it is recommended to work with <i>precompiled header</i> ;</li>
               <li><b>_QX_NO_RTTI :</b> build QxOrm library (and all projects which depend on QxOrm) without <a href="https://en.wikipedia.org/wiki/Run-time_type_information" target="_blank">RTTI C++ type information</a> ;</li>
               <li><b>_QX_STATIC_BUILD :</b> build QxOrm library in <i>static</i> mode (but build QxOrm as a <i>shared library</i> is recommended).</li>
               <li><b>_QX_UNITY_BUILD :</b> reduce QxOrm library compilation times using <i>unity build</i> concept : only one <i>all.cpp</i> source file to compile. It is recommended to enable this option with <a href="https://cmake.org/" target="_blank">CMake</a> (because doesn't support natively precompiled headers) ;</li>
               <li><b>_QX_ENABLE_MONGODB :</b> <a href="#manual_95">support MongoDB database</a>, QxOrm library becomes an ODM (Object Document Mapper).</li>
            </ul>
            <br>
            <b>Note :</b> <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file must be included in all projects which depend on QxOrm library, just adding following line in <i>*.pro</i> project file :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   include(<i>my_path_to_QxOrm_library</i>/QxOrm.pri)   </pre>
            </td></tr></tbody></table>
            <br>
            <b>Other note :</b> instead of <i>qmake</i>, it is possible to use <a href="https://cmake.org/" target="_blank">CMake compilation tools</a> to configure and build QxOrm library.
            CMake provides a GUI tool to display and configure all available parameters :
            <br><br>
            <img alt="QxOrm and CMake" src="./resource/qxorm_cmake.png" />
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_230">Build QxOrm library (with qmake or CMake)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses <b>qmake</b> process from <b>Qt</b> framework to create <i>makefile</i> and build the project (it is also possible to use <a href="https://cmake.org/" target="_blank">CMake compilation tools</a>, a <b>CMakeLists.txt</b> file is provided with QxOrm library).<br>
           <b>qmake</b> is portable and multi-platform, so it works perfectly on Windows, Linux (Unix) and Mac OS X.<br>
           To build <b>QxOrm</b> library, just execute following commands :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <i>qmake</i>
   <i>make debug</i>
   <i>make release</i>   </pre>
           </td></tr></tbody></table>
           <br>
           On <b>Windows</b>, <i>*.vcproj</i> and <i>*.sln</i> files are available for <b>Microsoft Visual C++</b>.<br>
           <i>*.pro</i> files are readable by <b>Qt Creator</b>, and some plugins are available to interface to other C++ source code editors.<br>
           <i>mingw_build_all_debug.bat</i> and <i>mingw_build_all_release.bat</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests with <b>MinGW</b> compiler on Windows.<br>
           <i>gcc_build_all_debug.sh</i> and <i>gcc_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests with <b>GCC</b> compiler on <b>Linux</b>.<br>
           <i>osx_build_all_debug.sh</i> and <i>osx_build_all_release.sh</i> scripts in the directory <i>./tools/</i> can be used to quickly build QxOrm library and all tests on <b>Mac OS X</b> (thanks very much to Dominique Billet for the scripts).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_240">Qt SQL drivers (supported databases)</a></p>
         <div class="manual_div_content">
           <b>QxOrm</b> library uses <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank"><i>QtSql</i></a> engine of <b>Qt</b> framework based on a system of plugins.<br>
           <a href="http://doc.qt.io/qt-5/sql-driver.html" target="_blank">A list of supported databases is available on Qt website</a>.<br>
           The <i>ODBC</i> plugin (<i>QODBC</i>) ensures compatibility with many databases.<br>
           For optimal performances, it is recommended to work with a database specific plugin :
           <ul>
              <li><i>QMYSQL</i> : MySQL ;</li>
              <li><i>QPSQL</i> : PostgreSQL (versions 7.3 and above) ;</li>
              <li><i>QOCI</i> : Oracle Call Interface Driver ;</li>
              <li><i>QSQLITE</i> : SQLite version 3 ;</li>
              <li><i>QDB2</i> : IBM DB2 (version 7.1 and above) ;</li>
              <li><i>QIBASE</i> : Borland InterBase ;</li>
              <li><i>QTDS</i> : Sybase Adaptive Server.</li>
           </ul>
           <b>Note :</b> to connect to a <i>Microsoft SQL Server</i> database, it is necessary to use <i>ODBC</i> (<i>QODBC</i> plugin).
           <br><br>
           <b>Other note :</b> QxOrm library is able to connect to <a href="#manual_95">MongoDB database (C++ ODM Object Document Mapper)</a>.
           <br><br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_30">Persistence - Object Relational Mapping (ORM)</a></p>
      <div class="manual_div_content_1">
         <b>QxOrm</b> library provides a data persistence engine based on <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank"><i>QtSql</i></a> module of Qt framework.
         This persistence engine uses programming pattern : <b>Object Relational Mapping (ORM)</b>.
         <br><br>
         <a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">From Wikipedia website :</a> Object-Relational Mapping (ORM) in computer science is a programming technique for converting data between incompatible type systems in object-oriented programming languages. This creates, in effect, a "virtual object database" that can be used from within the programming language.<br>
         In object-oriented programming, data management tasks act on object-oriented (OO) objects that are almost always non-scalar values. For example, consider an address book entry that represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object-oriented implementation by a "Person object" with attributes/fields to hold each data item that the entry comprises : the person's name, a list of phone numbers, and a list of addresses. The list of phone numbers would itself contain "PhoneNumber objects" and so on. The address book entry is treated as a single object by the programming language (it can be referenced by a single variable containing a pointer to the object, for instance). Various methods can be associated with the object, such as a method to return the preferred phone number, the home address, and so on.<br>
         However, many popular database products such as SQL database management systems (DBMS) can only store and manipulate scalar values such as integers and strings organized within tables. The programmer must either convert the object values into groups of simpler values for storage in the database (and convert them back upon retrieval), or only use simple scalar values within the program. Object-relational mapping is used to implement the first approach.<br>
         The heart of the problem is translating the logical representation of the objects into an atomized form that is capable of being stored in the database, while preserving the properties of the objects and their relationships so that they can be reloaded as objects when needed. If this storage and retrieval functionality is implemented, the objects are said to be persistent.
         <br><br>
         To do this link between object world and relational world, and to provide all its features, <b>QxOrm</b> library requires that C++ classes are registered in QxOrm context.
         So we will start this chapter this way : <b>how to register a C++ class in QxOrm context ?</b>
         <br><br>
         <b>Note :</b> QxOrm library is able to connect to <a href="#manual_95">MongoDB database (C++ ODM Object Document Mapper)</a>.
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_300">Register a class in QxOrm context (mapping)</a></p>
         <div class="manual_div_content">
            All C++ classes can be registered in QxOrm context : there is no need to inherit from a <i>super object</i>, and you can write your methods and accessors without any constraint.
            Register a C++ class in QxOrm context means :
            <ul>
               <li>in <i>*.h</i> header file (containing class definition) : use <i><b>QX_REGISTER_HPP(class_name, base_class, class_version)</b></i> macro ;</li>
               <li>in <i>*.cpp</i> source file (containing class implementation) : use <i><b>QX_REGISTER_CPP(class_name)</b></i> macro ;</li>
               <li>in <i>*.cpp</i> source file (containing class implementation) : specialize template function : <i><b>void qx::register_class&lt;T&gt;(qx::QxClass&lt;T&gt; & t)</b></i>.</li>
            </ul>
            Here is an example to show how to define a class named <i>person</i> with 4 properties registered in QxOrm context : <i>id</i>, <i>firstName</i>, <i>lastName</i>, <i>birthDate</i> :<br>
            <br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span></font><span class="comment">

/* This macro is necessary to register 'person' class in QxOrm context */
/* param 1 : the current class to register =&gt; 'person' */
/* param 2 : the base class, if no base class, use the qx trait =&gt; 'qx::trait::no_base_class_defined' */
/* param 3 : the class version used by serialization engine to provide 'ascendant compatibility' */</span><span class="pre">

#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="pre">#include <span class="string">"precompiled.h"</span>   <span class="comment">// Precompiled-header with '#include &lt;QxOrm.h&gt;' and '#include "export.h"'</span>
#include <span class="string">"person.h"</span>          <span class="comment">// Class definition 'person'</span>
#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>     <span class="comment">// Automatic memory leak detection and boost serialization export macro</span>
</span>
<font style="background-color:yellow">QX_REGISTER_CPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">)</span></font><span class="comment">   // This macro is necessary to register 'person' class in QxOrm context
</span><span class="keyword">
namespace</span> qx<span class="operator"> {</span><font style="background-color:yellow"><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
  t<span class="operator">.</span>setName<span class="operator">(</span><span class="string">"t_person"</span><span class="operator">)</span>;<span class="comment">               // 'person' C++ class is mapped to 't_person' database table</span>

  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span><span class="comment">               // Register 'person::id' &lt;=&gt; primary key in your database
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span><span class="comment">      // Register 'person::firstName' property mapped to 'first_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span><span class="comment">  // Register 'person::lastName' property mapped to 'last_name' database column name
</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span><span class="comment">  // Register 'person::birthDate' property mapped to 'birth_date' database column name
</span><span class="operator">}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> class methods <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::id()</a> and <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> return an instance of type : <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> (which is the base class to register a data member).
            With this instance, it is possible to customize default behaviour of <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class, like for example in the chapter : <a href="#manual_3050">Register a <i>transient</i> data member</a>.
            <br><br>
            <b>Other note :</b> it is also possible to register functions and class methods in QxOrm context (support <i>static</i> and <i>non static</i> methods) with <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a>, <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a>, etc...
            This feature is a part of <a href="#manual_70">introspection engine</a> of QxOrm library, more details in the chapter : <a href="#manual_730">Call function dynamically</a>.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3000">Primary key other than default type "long"</a></p>
            <div class="manual_div_content">
              By default, the unique id (primary key) of a C++ class registered in QxOrm context is defined as <i>long</i> type (with auto-increment behaviour in database).<br>
              <br>
              It is possible to define a unique id (primary key) of another type (for example, <i>QString</i> type) with <b>QX_REGISTER_PRIMARY_KEY</b> macro.<br>
              This macro specializes <i>qx::trait::get_primary_key&lt;T&gt;</i> template to associate a primary key type to a C++ class.<br>
              <br>
              For example, to define a <i>QString</i> primary key for <i>myClass</i> C++ class (mapped to a database table with a column primary key of type <i>VARCHAR</i>), you have to write :
              <i><b>QX_REGISTER_PRIMARY_KEY(myClass, QString)</b></i><br>
              <br>
              <b>Warning :</b> <b><i>QX_REGISTER_PRIMARY_KEY</i></b> macro must be used before <b><i>QX_REGISTER_HPP</i></b> macro in your class definition, otherwise a compilation error occurs.<br>
              <br>
              Here is an example with <i>author</i> class of <i>qxBlog</i> tutorial and a <i>QString</i> primary key type :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword"> 
class</span> author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- properties
</span>   QString  m_id<span class="operator">;</span>
   QString  m_name<span class="operator">;</span><span class="comment">
// -- constructor, virtual destructor
</span>   author<span class="operator">() { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }
};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3010">Composite primary key</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> supports '<i>multi-columns primary key</i>'.<br>
              The class id (primary key) must be defined with following type :
              <ul>
                <li><i>QPair</i> or <i>std::pair</i> to define 2 columns ;</li>
                <li><i>boost::tuple</i> (or <i>std::tuple</i>) to define from 2 columns to 9 columns.</li>
              </ul>
              It is necessary to use <b><i>QX_REGISTER_PRIMARY_KEY()</i></b> macro to specialize template and to map class id with multi-columns in database.<br>
              The list of multi-columns names must be defined with '<b>|</b>' character as separator : '<i>column1|column2|column3|etc...</i>'.<br>
              <br>
              Here is an example with '<i>author</i>' class from '<i>qxBlogCompositeKey</i>' sample project, this class has an id mapped to 3 columns in database :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span><span class="comment">

// -- composite key (multi-column primary key in database)
</span>   <font style="background-color:yellow"><span class="keyword">typedef</span> boost<span class="operator">::</span>tuple<span class="operator">&lt;</span>QString<span class="operator">,</span><span class="type"> long</span><span class="operator">,</span> QString<span class="operator">&gt;</span> type_composite_key<span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="keyword">static</span> QString str_composite_key<span class="operator">() {</span><span class="flow"> return</span><span class="string"> "author_id_0|author_id_1|author_id_2"</span><span class="operator">; }</span></font><span class="comment">

// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">

// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">

// -- properties
</span>   type_composite_key   m_id<span class="operator">;</span>
   QString              m_name<span class="operator">;</span>
   QDate                m_birthdate<span class="operator">;</span>
   enum_sex             m_sex<span class="operator">;</span>
   list_blog            m_blogX<span class="operator">;</span><span class="comment">

// -- contructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="string">""</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="string"> ""</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">

// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="comment">

// -- methods "get" to composite key
</span>   type_composite_key getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QString getId_0<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="type">
   long</span> getId_1<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span>
   QString getId_2<span class="operator">()</span><span class="keyword"> const</span><span class="operator">             {</span><span class="flow"> return</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">); }</span><span class="comment">

// -- methods "set" to composite key
</span><span class="type">   void</span> setId_0<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">0</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }</span><span class="type">
   void</span> setId_1<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">1</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> l<span class="operator">; }</span><span class="type">
   void</span> setId_2<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> boost<span class="operator">::</span>tuples<span class="operator">::</span>get<span class="operator">&lt;</span><span class="int">2</span><span class="operator">&gt;(</span>m_id<span class="operator">) =</span> s<span class="operator">; }

};</span>

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> author<span class="operator">::</span>type_composite_key<span class="operator">)</span></font>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>author<span class="operator">::</span>type_composite_key<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif // _QX_BLOG_AUTHOR_H_
</span></pre>
              </td></tr></tbody></table>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/author.h"
#include "../include/blog.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span></font>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span> blog<span class="operator">::</span>str_composite_key<span class="operator">(),</span> author<span class="operator">::</span>str_composite_key<span class="operator">());</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3020">public or protected/private data members</a></p>
            <div class="manual_div_content">
              To register <i>private</i> or <i>protected</i> data members in QxOrm context (<i>qx::register_class&lt;T&gt;</i> function), it's necessary to declare some <i>friend class</i>.<br>
              To do that, QxOrm library provides <b>QX_REGISTER_FRIEND_CLASS(myClass)</b> macro.<br>
              An example can be found in <i>./test/qxDllSample/dll1/</i> directory of QxOrm package with <i>CPerson</i> class :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> test<span class="operator"> {</span><span class="keyword">

class</span> QX_DLL1_EXPORT CPerson<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>qx<span class="operator">::</span>test<span class="operator">::</span>CPerson<span class="operator">)</span></font><span class="comment">

   // etc...
</span><span class="operator">
};

}</span><span class="comment"> // namespace test
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3030">Namespace</a></p>
            <div class="manual_div_content">
              If a class is defined in a namespace, a compilation error occurs with <b>QX_REGISTER_HPP</b> and <b>QX_REGISTER_CPP</b> macros.<br>
              To avoid this compilation error, it is necessary to use <b>QX_REGISTER_COMPLEX_CLASS_NAME_HPP</b> and <b>QX_REGISTER_COMPLEX_CLASS_NAME_CPP</b> macros.<br>
              <br>
              You can find a sample in <i>./test/qxDllSample/dll1/</i> directory of QxOrm package with <i>CPerson</i> class defined in <i>qx::test</i> namespace :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QX_DLL1(qx::test::CPerson, QObject, 0, qx_test_CPerson)   </pre>
              </td></tr></tbody></table>
              <br>
              <b>QX_REGISTER_COMPLEX_CLASS_NAME...</b> macros require an extra parameter (in above sample : <i>qx_test_CPerson</i>) to be able to create a global variable.
              This global variable is created before your application is started.
              This global variable instance registers the class in <a href="#manual_740"><i>QxFactory</i> module (design pattern factory)</a>.
              A C++ class name cannot contain "<i>::</i>" character, so this is why extra parameter replaces all "<i>::</i>" characters by "<i>_</i>".
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3040">Built-in C++ supported types</a></p>
            <div class="manual_div_content">
               QxOrm library supports all primitive types of C++ standard and Qt framework (numeric, boolean, string, date/time, container, pointer and smart-pointer, etc...).
               Here is an example with a list (non exhaustive) of supported C++ types mapped to database types (here as <i>SQLite</i> format) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Note :</b> it is possible to persist a type not managed by default by QxOrm library. Go to the chapter <a href="#manual_460"><b><i>Persist custom type</i></b></a> for more details about this feature.
               <br><br>
               <b>Other note :</b> to map a C++ type to a database type, please go to the chapter <a href="#manual_475"><b><i>Associate a SQL type to a C++ class</i></b></a> for more details.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3050">Register a transient data member</a></p>
            <div class="manual_div_content">
               A <i>transient</i> data member is not associated to a column in a database table.
               <a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao module</a> doesn't use a <i>transient</i> property for all requests to database.
               <br><br>
               Why to register a <i>transient</i> property in QxOrm context ?<br>
               Register a <i>transient</i> data member in QxOrm context enables other features provided by QxOrm library on this property : <a href="./manual.html#manual_60">serialization</a>, <a href="./manual.html#manual_70">introspection</a>, etc...
               <br><br>
               <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::data()</a> class method has an optional parameter named : <i>bool bDao</i> (default value is <i>true</i>).
               For example, we add a <i>transient</i> property named <i>age</i> to <i>person</i> class (this property doesn't have to be stored in database because we already have a <i>birthDate</i> property) :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> <font style="background-color:yellow">false</font></span><span class="operator">);
}}</span></pre>
               </td></tr></tbody></table>
               <br>
               Here is another way to define a <i>transient</i> property with <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> instance :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">;);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setDao<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_310">Connection to database</a></p>
         <div class="manual_div_content">
            To configure a connection to database, you can use the singleton class : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a>.<br>
            Here is an example to connect to a SQLite database named <i>test_qxorm.db</i> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlDatabase">
<pre>   <span class="comment">// Init parameters to connect to database</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDriverName<span class="operator">(</span><span class="string">"QSQLITE"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setDatabaseName<span class="operator">(</span><span class="string">"./test_qxorm.db"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setHostName<span class="operator">(</span><span class="string">"localhost"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setUserName<span class="operator">(</span><span class="string">"root"</span><span class="operator">);</span>
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setPassword<span class="operator">(</span><span class="string">""</span><span class="operator">);</span>
</pre>
            </td></tr></tbody></table>
            <br>
            By default, all requests sent from QxOrm library to database are executed using <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> singleton class settings.
            For more details about available settings, it is recommended to read <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase Qt class documentation</a>.
            <br><br>
            <b>Note :</b> <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><b>qx::QxSqlDatabase</b></a> singleton class can manage automatically requests to database in several threads (support <i>multi-threading</i>).
            <br><br>
            <b>Other note :</b> it is possible to manage your own connection pool to database, and also to work with several databases : for more details about this feature, please go to the chapter <a href="#manual_500"><b><i>Working with several databases</i></b></a>.
            <br><br>
            <b>Other note :</b> depending on Qt SQL plugin (<a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank"><i>setDriverName()</i></a> method), QxOrm library associates automatically a SQL generator.
            This SQL generator is used to manage specific features provided by databases.
            All SQL generators inherit from <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a> base class :
            <ul>
               <li><i>QMYSQL</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___my_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_MySQL</a> ;</li>
               <li><i>QPSQL</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___postgre_s_q_l.html" target="_blank">qx::dao::detail::QxSqlGenerator_PostgreSQL</a> ;</li>
               <li><i>QSQLITE</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___s_q_lite.html" target="_blank">qx::dao::detail::QxSqlGenerator_SQLite</a> ;</li>
               <li><i>QOCI</i> plugin : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___oracle.html" target="_blank">qx::dao::detail::QxSqlGenerator_Oracle</a> ;</li>
               <li>for all other plugins : SQL generator <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_qx_sql_generator___standard.html" target="_blank">qx::dao::detail::QxSqlGenerator_Standard</a> (it is possible to create your own SQL generator writing a class based on <a href="../doxygen/html/classqx_1_1dao_1_1detail_1_1_ix_sql_generator.html" target="_blank">qx::dao::detail::IxSqlGenerator</a>) ;</li>
               <li>to connect to a <i>Microsoft SQL Server</i> database, you have to work with <i>QODBC</i> plugin : then you have to define yourself the SQL generator like this : </li>
            </ul>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="SQL generator">
<pre>   qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxSqlGenerator_ptr pSqlGenerator<span class="operator">;</span>
   pSqlGenerator<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxSqlGenerator_MSSQLServer<span class="operator">());</span>   
   qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>setSqlGenerator<span class="operator">(</span>pSqlGenerator<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_320">Persist a C++ instance in database (insert/update)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To save a C++ instance (or a list of C++ instances) to database, QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert</i></a> : insert an instance (or a list of instances) to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_relation</i></a> : insert an instance (or a list of instances) + its relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::insert_with_all_relation</i></a> : insert an instance (or a list of instances) + all relationships to database ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update</i></a> : update an instance (or a list of instances) to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_relation</i></a> : update an instance (or a list of instances) + its relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_with_all_relation</i></a> : update an instance (or a list of instances) + all relationships to database ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query</i></a> : update an instance (or a list of instances) to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_relation</i></a> : update an instance (or a list of instances) + its relationships to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_by_query_with_all_relation</i></a> : update an instance (or a list of instances) + all relationships to database with a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized</i></a> : update only modified fields of an instance (or a list of instances) to database using <i>is dirty</i> pattern and <a href="#manual_4030">qx::dao::ptr</a> class features ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::update_optimized_by_query</i></a> : update only modified fields of an instance (or a list of instances) to database using <i>is dirty</i> pattern and <a href="#manual_4030">qx::dao::ptr</a> class features with a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + its relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_all_relation</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + all relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::save_with_relation_recursive</i></a> : insert (if entity doesn't exist in database) or update (if entity already exists in database) + all relationships on all levels (recursively) : useful to store quickly a complex tree structure for example ;</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="insert/update">
<pre>   <span class="comment">// Create 3 drugs instances
   // It is possible to use 'boost' and 'Qt' smart pointer : 'boost::shared_ptr', 'QSharedPointer', etc...
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span>
   drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
   drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
   drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span>

   <span class="comment">// Insert some drugs into a container
   // It is possible to use many containers from 'std', 'boost', 'Qt' and 'qx::QxCollection&lt;Key, Value&gt;'
</span><span class="keyword">   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>drug_ptr<span class="operator">&gt;</span> type_lst_drug<span class="operator">;</span>
   type_lst_drug lst_drug<span class="operator">;</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d1<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d2<span class="operator">);</span>
   lst_drug<span class="operator">.</span>push_back<span class="operator">(</span>d3<span class="operator">);</span><span class="comment">

   // Insert drugs from container to database
   // 'id' property of 'd1', 'd2' and 'd3' are auto-updated
</span>   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>lst_drug<span class="operator">);</span></font><span class="comment">

   // Modify and update the second drug into database
</span>   d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2 modified"</span><span class="operator">;</span>
   d2<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc2 modified"</span><span class="operator">;</span>
   daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>d2<span class="operator">);</span></font>
</pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> all functions located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace are flexible because they accept several types of parameters : a simple instance, a list of instances, a pointer, a smart-pointer, a list of pointers, a list of smart-pointers, etc... For example :
            <ul>
               <li><i>my_entity t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>my_entity * t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>std::shared_ptr&lt;my_entity&gt; t; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(t);</i></li>
               <li><i>QList&lt;my_entity&gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
               <li><i>QList&lt;std::shared_ptr&lt;my_entity&gt; &gt; lst; &nbsp;&nbsp;&nbsp;&nbsp;/* ... */&nbsp;&nbsp;&nbsp;&nbsp; qx::dao::insert(lst);</i></li>
            </ul>
            About supported collection types by QxOrm library, please go to the chapter : <a href="#manual_390">Supported containers</a>.<br>
            About supported smart-pointer types by QxOrm library, please go to the chapter : <a href="#manual_400">Supported smart pointers</a>.<br>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_340">Delete an instance in database (delete)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To delete a C++ instance (or a list of C++ instances) from database, QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_id</i></a> : delete entity (or a list of entities) from database associated to the id parameter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_all</i></a> : delete all entities from a database table ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::delete_by_query</i></a> : delete entities from a database table using a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_id</i></a> : delete entity (or a list of entities) from database associated to the id parameter (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_all</i></a> : delete all entities from a database table (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::destroy_by_query</i></a> : delete entities from a database table using a SQL query filter (<a href="#manual_3400">with soft delete behaviour, logical delete</a>) ;</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="delete">
<pre>   <span class="comment">// Create a drug instance with id '18'
   </span>drug d<span class="operator">;</span> d<span class="operator">.</span>setId<span class="operator">(</span><span class="int">18</span><span class="operator">);</span><span class="comment">

   // Delete the drug with id '18' from database
   </span>QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>d<span class="operator">);</span></font><span class="comment">

   // Delete all drugs from database
   </span>daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>drug<span class="operator">&gt;();</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3400">Soft delete behaviour (logical delete)</a></p>
            <div class="manual_div_content">
              A soft delete doesn't remove rows from a database table (this is not a physical delete) : a new column is added to table definition to flag a row as deleted or not.
              This extra column can contain a boolean (1 means row deleted, 0 or NULL means row not deleted), or can contain deletion date-time (if empty or NULL, row is not deleted).
              So it is always possible to enable a row which has been previously deleted : you just have to put a NULL or empty value in this extra column.<br>
              <br>
              To define a soft delete behaviour with QxOrm library, you have to use <a href="../doxygen/html/classqx_1_1_qx_soft_delete.html" target="_blank"><b>qx::QxSoftDelete</b></a> class in mapping function <i>qx::register_class&lt;T&gt;</i>.<br>
              Here is an example with <i>Bar</i> class containing 2 properties <i>m_id</i> and <i>m_desc</i> :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>Bar<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   <font style="background-color:yellow">t<span class="operator">.</span>setSoftDelete<span class="operator">(</span>qx<span class="operator">::</span>QxSoftDelete<span class="operator">(</span><span class="string">"deleted_at"</span><span class="operator">));</span></font>

   t<span class="operator">.</span>id<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> Bar<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "desc"</span><span class="operator">);
}}</span></pre>
              </td></tr></tbody></table>
              <br>
              SQL queries generated by QxOrm library will take into account this soft delete parameter to add conditions (don't fetch deleted items, don't delete physically a row, etc...).<br>
              For example, if you execute this code with <i>Bar</i> class :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>Bar_ptr pBar<span class="operator">;</span> pBar<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> Bar<span class="operator">());</span>
pBar<span class="operator">-&gt;</span>setId<span class="operator">(</span><span class="int">5</span><span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>pBar<span class="operator">);</span>     qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span>
qx_bool bDaoExist<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>exist<span class="operator">(</span>pBar<span class="operator">);</span>             qAssert<span class="operator">(!</span> bDaoExist<span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>                qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span><span class="type">
long</span> lBarCount<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(</span>lBarCount<span class="operator"> ==</span><span class="int"> 0</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_all<span class="operator">&lt;</span>Bar<span class="operator">&gt;();</span>               qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span></pre>
              </td></tr></tbody></table>
              <br>
              Then output logs are :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">93</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148615'</span> WHERE id<span class="operator"> = :</span>id<span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT Bar<span class="operator">.</span>id AS Bar_id_0<span class="operator">,</span> Bar<span class="operator">.</span>deleted_at FROM Bar WHERE Bar<span class="operator">.</span>id<span class="operator"> = :</span>id 
                                         AND<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">78</span> ms<span class="operator">) :</span> UPDATE Bar SET deleted_at<span class="operator"> =</span><span class="char"> '20110617115148724'</span><span class="operator">
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">0</span> ms<span class="operator">) :</span> SELECT COUNT<span class="operator">(*)</span> FROM Bar WHERE<span class="operator"> (</span>Bar<span class="operator">.</span>deleted_at IS NULL OR Bar<span class="operator">.</span>deleted_at<span class="operator"> =</span><span class="char"> ''</span><span class="operator">)
[</span>QxOrm<span class="operator">]</span> sql query<span class="operator"> (</span><span class="int">110</span> ms<span class="operator">) :</span> DELETE FROM Bar</pre>
              </td></tr></tbody></table>
              <br>
              <b>Note :</b> to delete physically a row from database, you have to use these functions : <i>qx::dao::destroy_by_id()</i> and <i>qx::dao::destroy_all()</i>.<br>
              <br>
              <b>Other note :</b> it is recommended to define an index on <i>deleted_at</i> extra column to optimize SQL queries execution (better performance).
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_350">Get a C++ instance from database (fetch)</a></p>
         <div class="manual_div_content">
            All functions to communicate with databases are located in <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace.<br>
            <br>
            To fetch automatically all properties of a C++ instance (or a list of C++ instances) mapped to database table columns (and several tables if relationships are defined), QxOrm library provides these functions :
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id</i></a> : fetch entity properties (or list of entities properties) based on the id parameter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_relation</i></a> : fetch entity properties (or list of entities properties) + its relationships based on the id parameter  ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_id_with_all_relation</i></a> : fetch entity properties (or list of entities properties) + all relationships based on the id parameter  ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all</i></a> : fetch all entities from database table (all rows) ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_relation</i></a> : fetch all entities from database table (all rows) + its relationships ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_all_with_all_relation</i></a> : fetch all entities from database table (all rows) + all relationships ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query</i></a> : fetch entities from database table using a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_relation</i></a> : fetch entities + its relationships from database table using a SQL query filter ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::fetch_by_query_with_all_relation</i></a> : fetch entities + all relationships from database table using a SQL query filter ;</li>
               <br>
               <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank"><i>qx::dao::exist</i></a> : check if an entity (or a list of entities) already exists in database (based on its id).</li>
            </ul>
            <br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="fetch">
<pre><span class="comment">   // Fetch drug with id '3' into a new variable
</span>   drug_ptr d<span class="operator">;</span> d<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> <font style="background-color:yellow">qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_360">SQL queries</a></p>
         <div class="manual_div_content">
            QxOrm library provides several tools to execute SQL queries to database :
            <ul>
               <li><a href="#manual_3600">qx::QxSqlQuery</a> class (or its <i>qx_query</i> alias) ;</li>
               <li><a href="#manual_3610">qx::dao::execute_query<T>()</a> function ;</li>
               <li><a href="#manual_3610">qx::dao::call_query()</a> function.</li>
            </ul>
            <b>Note :</b> QxOrm library is based on <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> module of Qt framework, so it is always possible to call database using <a href="http://doc.qt.io/qt-5/qsqlquery.html" target="_blank">QSqlQuery</a> Qt class if QxOrm features are not adapted to solve an issue.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a></p>
            <div class="manual_div_content">
              <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class (or its <i>qx_query</i> typedef) is used to communicate with database (to filter, to sort, etc.) in 2 different ways :
              <ul>
                <li>writing manually a SQL query ;</li>
                <li>using C++ methods with a syntax similar to SQL (same concept than the great library <a href="http://subsonicproject.com/docs/Simple_Query_Tool" target="_blank">SubSonic for .Net</a>).</li>
              </ul>
              With the first method (writing manually SQL query), you can use some optimizations specific for each database.<br>
              The second method (using C++ code to build SQL query) binds automatically SQL parameters without having to deal with <i>qx::QxSqlQuery::bind()</i> function.<br>
              <br>
              Here is an example with <i>qx::QxSqlQuery</i> class writing manually a SQL query :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Build a SQL query to fetch only 'author' of type 'female'
</span>qx<span class="operator">::</span>QxSqlQuery query<span class="operator">(</span><span class="string">"WHERE author.sex = :sex"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":sex"</span><span class="operator">,</span> author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* here we can work with the collection provided by database */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              QxOrm library provides 3 styles to write SQL parameters.<br>
              This style can be modified for a project using <i>qx::QxSqlDatabase::getSingleton()->setSqlPlaceHolderStyle()</i> method :<br>
              <ul>
                <li><i>ph_style_2_point_name</i> : "WHERE author.sex = :sex" (default style) ;</li>
                <li><i>ph_style_at_name</i> : "WHERE author.sex = @sex" ;</li>
                <li><i>ph_style_question_mark</i> : "WHERE author.sex = ?".</li>
              </ul>
              Here is the same example using <i>qx::QxSqlQuery</i> class methods to generate SQL query automatically :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Build a SQL query to fetch only 'author' of type 'female'
</span>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"author.sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">);</span>

QList<span class="operator">&lt;</span>author<span class="operator">&gt;</span> list_of_female<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">(</span>query<span class="operator">,</span> list_of_female<span class="operator">);</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> list_of_female<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
{</span><span class="comment"> /* here we can work with the collection provided by database */</span><span class="operator"> }</span></pre>
              </td></tr></tbody></table>
              <br>
              With C++ methods of <i>qx::QxSqlQuery</i> class, you don't have to bind any SQL parameter, and the syntax is similar to real SQL.<br>
              All SQL parameters will be provided to database automatically with the following style : <i>qx::QxSqlDatabase::getSingleton()->getSqlPlaceHolderStyle()</i>.<br>
              <br>
              Here is another example using several <i>qx::QxSqlQuery</i> class methods :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">;</span>
query<span class="operator">.</span>where<span class="operator">(</span><span class="string">"sex"</span><span class="operator">).</span>isEqualTo<span class="operator">(</span>author<span class="operator">::</span>female<span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"age"</span><span class="operator">).</span>isGreaterThan<span class="operator">(</span><span class="int">38</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">).</span>isNotEqualTo<span class="operator">(</span><span class="string">"Dupont"</span><span class="operator">)
     .</span>or_<span class="operator">(</span><span class="string">"first_name"</span><span class="operator">).</span>like<span class="operator">(</span><span class="string">"Alfred"</span><span class="operator">)
     .</span>and_OpenParenthesis<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>isLessThanOrEqualTo<span class="operator">(</span><span class="int">999</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"birth_date"</span><span class="operator">).</span>isBetween<span class="operator">(</span>date1<span class="operator">,</span> date2<span class="operator">)
     .</span>closeParenthesis<span class="operator">()
     .</span>or_<span class="operator">(</span><span class="string">"id"</span><span class="operator">).</span>in<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 999</span><span class="operator">,</span><span class="int"> 11</span><span class="operator">,</span><span class="int"> 23</span><span class="operator">,</span><span class="int"> 78945</span><span class="operator">)
     .</span>and_<span class="operator">(</span><span class="string">"is_deleted"</span><span class="operator">).</span>isNotNull<span class="operator">()
     .</span>orderAsc<span class="operator">(</span><span class="string">"last_name"</span><span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="string"> "sex"</span><span class="operator">)
     .</span>limit<span class="operator">(</span><span class="int">50</span><span class="operator">,</span><span class="int"> 150</span><span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code will generate following SQL query for <i>MySQL</i>, <i>PostgreSQL</i> and <i>SQLite</i> databases (for <i>Oracle</i> and <i>Microsoft SQL Server</i>, there is a specific process for <i>limit()</i> method) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>WHERE sex<span class="operator"> = :</span>sex_1_0 
AND age<span class="operator"> &gt; :</span>age_3_0 
OR last_name<span class="operator"> &lt;&gt; :</span>last_name_5_0 
OR first_name LIKE<span class="operator"> :</span>first_name_7_0 
AND<span class="operator"> (</span> id<span class="operator"> &lt;= :</span>id_10_0 AND birth_date BETWEEN<span class="operator"> :</span>birth_date_12_0_1 AND<span class="operator"> :</span>birth_date_12_0_2<span class="operator"> )</span> 
OR id IN<span class="operator"> (:</span>id_15_0_0<span class="operator">, :</span>id_15_0_1<span class="operator">, :</span>id_15_0_2<span class="operator">, :</span>id_15_0_3<span class="operator">, :</span>id_15_0_4<span class="operator">)</span> 
AND is_deleted IS NOT NULL 
ORDER BY last_name ASC<span class="operator">,</span> first_name ASC<span class="operator">,</span> sex ASC 
LIMIT<span class="operator"> :</span>limit_rows_count_19_0 OFFSET<span class="operator"> :</span>offset_start_row_19_0</pre>
              </td></tr></tbody></table>
              <br>
              Here is the list of all functions available to use <i>qx::QxSqlQuery</i> class (or its <i>qx_query</i> typedef) :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// with functions into namespace qx::dao
</span>qx<span class="operator">::</span>dao<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>destroy_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_by_query_with_all_relation<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized_by_query<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// with qx::QxSession class
</span>qx<span class="operator">::</span>QxSession<span class="operator">::</span>count<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>fetchByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>update<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>deleteByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span>
qx<span class="operator">::</span>QxSession<span class="operator">::</span>destroyByQuery<span class="operator">&lt;</span>T<span class="operator">&gt;()</span><span class="comment">

// with qx::QxRepository&lt;T&gt; class
</span>qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>count<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fetchByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>update<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>deleteByQuery<span class="operator">()</span>
qx<span class="operator">::</span>QxRepository<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>destroyByQuery<span class="operator">()</span></pre>
              </td></tr></tbody></table>
              <br>
              <b>Note :</b> these functions have 2 other optionals parameters :
              <ul>
                <li><i>const QStringList & columns</i> : to select columns to fetch (by default, all columns are fetched) ;</li>
                <li><i>const QStringList & relation</i> : to select relationships to fetch (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i> defined in <i>void qx::register_class&lt;T&gt;()</i> mapping function per class), by default there is no relation fetched.</li>
              </ul>
              <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3610">Using standard SQL or stored procedure</a></p>
            <div class="manual_div_content">
              QxOrm library provides 2 functions to execute a stored procedure or a custom SQL query :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a></li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a></li>
              </ul>
              The first parameter of these functions, of <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> type (or <i>qx_query</i>), contains the stored procedure or the custom SQL query to execute.<br>
              For more information about <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class, please read this chapter : <a href="#manual_3600">Using qx::QxSqlQuery class (or qx_query alias)</a><br>
              <br>
              <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::execute_query&lt;T&gt;()</a> function is a <i>template</i> function : T type must be registered in QxOrm context (<i>qx::register_class&lt;T&gt;</i> function).<br>
              All datas returned by the stored procedure or the custom SQL query which could be associated with members of the C++ class (of T type) will be fetched automatically.<br>
              An automatic search is done on the name of each fields returned by the query.<br>
              Here is an example from qxBlog project of QxOrm package :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom SQL query or a stored procedure and fetch automatically properties (with a collection of items)
</span>qx_query testStoredProcBis<span class="operator">(</span><span class="string">"SELECT * FROM author"</span><span class="operator">);</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>execute_query<span class="operator">(</span>testStoredProcBis<span class="operator">,</span> authorX<span class="operator">);</span>
qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">());</span> qAssert<span class="operator">(</span>authorX<span class="operator">.</span>count<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
qx<span class="operator">::</span>dump<span class="operator">(</span>authorX<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
              <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> function is not a <i>template</i> function : you have to iterate over each result using <i><a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a></i> class (or <i>qx_query</i>).<br>
              To get an output value parameter (must be passed as <i>QSql::Out</i> or <i>QSql::InOut</i>) returned by a stored procedure, just call the following method : <i>QVariant qx::QxSqlQuery::boundValue(const QString & sKey) const;</i>.<br>
              <br>
              To iterate over all resultset, just use the following methods :
              <ul>
                <li><i>long qx::QxSqlQuery::getSqlResultRowCount() const;</i></li>
                <li><i>long qx::QxSqlQuery::getSqlResultColumnCount() const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, long column) const;</i></li>
                <li><i>QVariant qx::QxSqlQuery::getSqlResultAt(long row, const QString & column) const;</i></li>
                <li><i>QVector qx::QxSqlQuery::getSqlResultAllColumns() const;</i></li>
                <li><i>void qx::QxSqlQuery::dumpSqlResult();</i></li>
              </ul>
              Here is an example using <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao::call_query()</a> function :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>qx_query query<span class="operator">(</span><span class="string">"CALL MyStoredProc(:param1, :param2)"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param1"</span><span class="operator">,</span><span class="string"> "myValue1"</span><span class="operator">);</span>
query<span class="operator">.</span>bind<span class="operator">(</span><span class="string">":param2"</span><span class="operator">,</span><span class="int"> 5024</span><span class="operator">,</span> QSql<span class="operator">::</span>InOut<span class="operator">);</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>call_query<span class="operator">(</span>query<span class="operator">);</span>
QVariant vNewValue<span class="operator"> =</span> query<span class="operator">.</span>boundValue<span class="operator">(</span><span class="string">":param2"</span><span class="operator">);</span>
query<span class="operator">.</span>dumpSqlResult<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_370">Transactions (commit, rollback, session)</a></p>
         <div class="manual_div_content">
            A database <a href="http://en.wikipedia.org/wiki/Database_transaction" target="_blank"><b>transaction</b></a> is a sequence of operations performed as a single logical unit of work :<br>
            <ul>
               <li>if no error occurred during the execution of the transaction, then the system <b>commits</b> the transaction.</li>
               <li>if an error occurs during the transaction, or if the user specifies a <b>rollback</b> operation, then the data manipulations within the transaction are not persisted to the database.</li>
            </ul>
            <b><a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a></b> class of QxOrm library is designed to manage automatically database transactions (using <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank">C++ RAII</a>) :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Start a scope where a new session is instantiated

  // Create a session : a valid database connection by thread is automatically assigned to the session and a transaction is opened
  </span>qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Execute some operations with database (using += operator of qx::QxSession class and session database connection)
  </span>session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>insert<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span>
  session<span class="operator"> +=</span> qx<span class="operator">::</span>dao<span class="operator">::</span>delete_by_id<span class="operator">(</span>my_object<span class="operator">,</span> session<span class="operator">.</span>database<span class="operator">());</span><span class="comment">

  // If the session is not valid (so an error occured) =&gt; display first error
  </span><span class="flow">if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // End of scope : session is destroyed (transaction =&gt; automatically commit or rollback if there is an error)</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Note :</b> a session can throw a <a href="../doxygen/html/classqx_1_1dao_1_1sql__error.html" target="_blank"><i>qx::dao::sql_error</i></a> exception when a SQL error occured (by default, there is no exception). You can setup this feature using :
            <ul>
               <li><i>qx::QxSession</i> constructor (for a specific session) ;</li>
               <li><i>qx::QxSqlDatabase::getSingleton()->setSessionThrowable(bool b)</i> parameter (for all sessions).</li>
            </ul>
            <b>Other note :</b> don't forget to pass the session database connection to each <i>qx::dao::xxx</i> functions (using <i>session.database()</i> method).<br>
            Moreover, you can manage your own database connection (from a connection pool for example) using constructor of <i>qx::QxSession</i> class.<br>
            <br>
            <i>qx::QxSession</i> class provides persistent methods to perform CRUD operations.<br>
            Here is the same example using <i>qx::QxSession</i> class methods instead of <i>qx::dao</i> functions :<br>
            <br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">{</span><span class="comment"> // Start a scope where a new session is instantiated

  // Create a session : a valid database connection by thread is automatically assigned to the session and a transaction is opened
</span>  qx<span class="operator">::</span>QxSession session<span class="operator">;</span><span class="comment">

  // Execute some operations with database
</span>  session<span class="operator">.</span>insert<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>update<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>fetchById<span class="operator">(</span>my_object<span class="operator">);</span>
  session<span class="operator">.</span>deleteById<span class="operator">(</span>my_object<span class="operator">);</span><span class="comment">

  // If the session is not valid (so an error occured) =&gt; display first error
</span><span class="flow">  if</span><span class="operator"> (!</span> session<span class="operator">.</span>isValid<span class="operator">()) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] session error : '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>session<span class="operator">.</span>firstError<span class="operator">().</span>text<span class="operator">())); }

}</span><span class="comment"> // End of scope : session is destroyed (transaction =&gt; automatically commit or rollback if there is an error)</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_380">Relationships</a></p>
         <div class="manual_div_content">
            QxOrm library provides a powerful relationship engine to define easily :
            <ul>
               <li><a href="#manual_3800">one-to-many (1-n)</a> relationship ;</li>
               <li><a href="#manual_3810">many-to-one (n-1)</a> relationship ;</li>
               <li><a href="#manual_3820">many-to-many (n-n)</a> relationship ;</li>
               <li><a href="#manual_3830">one-to-one (1-1)</a> relationship ;</li>
            </ul>
            <b>Note :</b> <a href="./tutorial.html">a full tutorial about relationships based on <i>qxBlog</i> sample project</a> (source code in QxOrm package) is available.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3800">one-to-many (1-n)</a></p>
            <div class="manual_div_content">
              A <i>one-to-many (1-n)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToMany()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 3 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
                <li><i>const QString & sForeignKey</i> : foreign key defined in the linked class/table.</li>
              </ul>
              <br>
              <b>For example : </b> imagine an <i>author</i> (a person) who can write several <i>blog</i> : we will show how to define a <b><i>one-to-many</i></b> relationship.<br>
              Here are the 2 tables in database : <br>
              <br>
              <img alt="qxBlog.table.author" src="./resource/qxBlog.table.author.jpg"
              width="318" height="118"><br>
              <br>
              <i>author.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- properties
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
               </td></tr></tbody></table>
               <br>
               <i>author.cpp</i> file :<br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span></font>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3810">many-to-one (n-1)</a></p>
            <div class="manual_div_content">
              A <i>many-to-one (n-1)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToOne()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 2 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship (mapped to a table column in database) ;</li>
              </ul>
              <br>
              <b>For example : </b> a <i>comment</i> is associated to a <i>blog</i> and a <i>blog</i> can contain several <i>comment</i> : we will show how to define a <b><i>many-to-one</i></b> relationship.<br>
              Here are the 2 tables in database : <br>
              <br>
              <img alt="qxBlog.table.comment"
              src="./resource/qxBlog.table.comment.jpg" width="335" height="116"><br>
              <br>
              <i>comment.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.h">
<pre><span class="pre">#ifndef _QX_BLOG_COMMENT_H_
#define _QX_BLOG_COMMENT_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT comment<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="comment">
// -- properties
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_text<span class="operator">;</span>
   QDateTime   m_dt_create<span class="operator">;</span>
   <font style="background-color:yellow">blog_ptr    m_blog<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   comment<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>comment<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>comment<span class="operator">&gt;</span> comment_ptr<span class="operator">;</span><span class="keyword">
typedef</span> QList<span class="operator">&lt;</span>comment_ptr<span class="operator">&gt;</span> list_comment<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_COMMENT_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              <i>comment.cpp</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="comment.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>comment<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>comment<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "comment_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_text<span class="operator">,</span><span class="string"> "comment_text"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_dt_create<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToOne<span class="operator">(&amp;</span> comment<span class="operator">::</span>m_blog<span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3820">many-to-many (n-n)</a></p>
            <div class="manual_div_content">
              A <i>many-to-many (n-n)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationManyToMany()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 5 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
                <li><i>const QString & sExtraTable</i> : extra table name to store id of each side of relationship ;</li>
                <li><i>const QString & sForeignKeyOwner</i> : foreign key in extra table linked to current class ;</li>
                <li><i>const QString & sForeignKeyDataType</i> : foreign key in extra table linked to other class.</li>
              </ul>
              <br>
              <b>For example :</b> a <i>category</i> embed several <i>blog</i> and a <i>blog</i> can belong to several <i>category</i> : we will show how to define a <b><i>many-to-many</i></b> relationship.
              A <i>n-n</i> relationship requires an extra table to store id of each side of relationship.<br>
              Here are the 3 tables in database : <br>
              <br>
              <img alt="qxBlog.table.category"
              src="./resource/qxBlog.table.category.jpg" width="464" height="115"><br>
              <br>
              <i>category.h</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.h">
<pre><span class="pre">#ifndef _QX_BLOG_CATEGORY_H_
#define _QX_BLOG_CATEGORY_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT category<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- properties
</span><span class="type">   long</span>        m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   <font style="background-color:yellow">list_blog   m_blogX<span class="operator">;</span></font><span class="comment">
// -- constructor, virtual destructor
</span>   category<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>category<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>category<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> QSharedPointer<span class="operator">&lt;</span>category<span class="operator">&gt;</span> category_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> category_ptr<span class="operator">&gt;</span> list_category<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_CATEGORY_H_</span>
</span></pre>
              </td></tr></tbody></table>
              <br>
              <i>category.cpp</i> file :<br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="category.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/category.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>category<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>category<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> category<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> category<span class="operator">::</span>m_desc<span class="operator">,</span><span class="string"> "description"</span><span class="operator">);</span>

   <font style="background-color:yellow">t<span class="operator">.</span>relationManyToMany<span class="operator">(&amp;</span> category<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "category_blog"</span><span class="operator">,</span><span class="string"> "category_id"</span><span class="operator">,</span><span class="string"> "blog_id"</span><span class="operator">);</font>
}}</span>
</pre>
               </td></tr></tbody></table>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3830">one-to-one (1-1)</a></p>
            <div class="manual_div_content">
              A <i>one-to-one (1-1)</i> relationship links 2 entities which share the same database id.
              A <i>one-to-one (1-1)</i> relationship is defined with method : <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::relationOneToOne()</a>.
              This method returns an instance of <a href="../doxygen/html/classqx_1_1_ix_sql_relation.html" target="_blank">qx::IxSqlRelation</a> type (which is the base class to register a relationship) and take 2 parameters :
              <ul>
                <li><i>V U::* pData</i> : reference to the class data member ;</li>
                <li><i>const QString & sKey</i> : unique key associated to the relationship ;</li>
              </ul>
              <br>
              <b>For example :</b> imagine a <i>person</i> table and an <i>author</i> table : an <i>author</i> is also a <i>person</i>, so these 2 tables could share the same id in database.
              Here are the 2 tables in database (with <i>person_id == author_id</i>) :<br>
              <br>
              <img alt="qxBlog.table.person" src="resource/qxBlog.table.person.jpg" width="279" height="118">
              <br><br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3840">Fetch relationships</a></p>
            <div class="manual_div_content">
              QxOrm library supports 4 kind of relationships to link C++ classes registered in QxOrm context : <i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i>.<br>
              For more details to define relationships, you can take a look at <a href="./tutorial.html" target="_blank">qxBlog tutorial</a>.<br>
              We will explain here how to fetch datas from many tables (<a href="../doxygen/html/group___qx_dao.html" target="_blank">QxDao</a> module, functions of <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace) :
              <ul>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query</a> : fetch datas from only 1 table from database (<i>lazy fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_all_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_all_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_all_relation</a> : fetch datas from 1 table + all tables linked (<i>eager fetch</i>) ;</li>
              <li><a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> : same as above (<i>eager fetch</i>) with possibility to select relationships to fetch on many levels.</li>
              </ul>
              The first parameter of <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_id_with_relation</a>, <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_all_with_relation</a> and <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">fetch_by_query_with_relation</a> functions is the list of relationships to fetch.<br>
              This list of relationships can contain these items :
              <ul>
              <li>relation key : each relation is associated to a key defined in <i>qx::register_class&lt;T&gt;</i> mapping function ;</li>
              <li>"<i>*</i>" keyword means "<i>fetch all relationships defined in <i>qx::register_class&lt;T&gt;</i> function (1 level of relationships)</i>" ;</li>
              <li>"<i>-></i>" keyword means "<i>LEFT OUTER JOIN</i>" join type between 2 tables ;</li>
              <li>"<i>>></i>" keyword means "<i>INNER JOIN</i>" join type between 2 tables.</li>
              </ul>
              <b>Note :</b> using "*" keyword to indicate "<i>fetch all relationships defined into <i>qx::register_class&lt;T&gt;</i> function</i>", following calls are similar :
              <ul>
              <li><i>qx::dao::fetch_by_id_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_id_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_by_query_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_by_query_with_all_relation(...)</i> ;</li>
              <li><i>qx::dao::fetch_all_with_relation(<b>"*"</b>, ...)</i>  ==  <i>qx::dao::fetch_all_with_all_relation(...)</i>.</li>
              </ul>
              <br>
              <b>Example :</b> from qxBlog tutorial, it's possible to fetch all these datas with only 1 query :<br>
              <br>
              <b>1-</b> fetch a <i>blog</i> and its <i>author</i> ;<br>
              <b>2-</b> for the <i>author</i> fetched, fetch all <i>blog</i> he wrote ;<br>
              <b>3-</b> for each <i>blog</i> written by <i>author</i> fetched, fetch all <i>comment</i> associated.<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:180px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Another example :</b> it's also possible to create a list of relationships to fetch, like this :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QStringList relation<span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "author_id-&gt;list_blog-&gt;list_category"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_comment"</span><span class="operator">;</span>
relation<span class="operator"> &lt;&lt;</span><span class="string"> "list_category"</span><span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>relation<span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:270px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, 
       category_7.category_id AS category_7_category_id_0, category_7.name AS category_7_name_0, category_7.description AS category_7_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN category_blog category_blog_7 ON blog.blog_id = category_blog_7.blog_id 
LEFT OUTER JOIN category category_7 ON category_blog_7.category_id = category_7.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
              <b>Another example :</b> to fetch all relationships per level, "*" keyword must be used.<br>
              So to fetch all relationships on 3 levels, we can write :<br>
              <br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="complex fetch with relationships">
<pre>blog_ptr my_blog<span class="operator"> =</span> blog_ptr<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">(</span><span class="int">10</span><span class="operator">));</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span><span class="string">"*-&gt;*-&gt;*"</span><span class="operator">,</span> my_blog<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br>
              This code generates following SQL query :
              <div style="width:900px; height:620px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog.blog_id AS blog_blog_id_0, blog.blog_text AS blog_blog_text_0, blog.date_creation AS blog_date_creation_0, blog.author_id AS blog_author_id_0, 
       author_1.author_id AS author_1_author_id_0, author_1.name AS author_1_name_0, author_1.birthdate AS author_1_birthdate_0, author_1.sex AS author_1_sex_0, 
       blog_2.blog_id AS blog_2_blog_id_0, blog_2.author_id AS blog_2_author_id_0, blog_2.blog_text AS blog_2_blog_text_0, blog_2.date_creation AS blog_2_date_creation_0, blog_2.author_id AS blog_2_author_id_0_2, 
       author_3.author_id AS author_3_author_id_0, author_3.name AS author_3_name_0, author_3.birthdate AS author_3_birthdate_0, author_3.sex AS author_3_sex_0, 
       comment_4.comment_id AS comment_4_comment_id_0, comment_4.blog_id AS comment_4_blog_id_0, comment_4.comment_text AS comment_4_comment_text_0, comment_4.date_creation AS comment_4_date_creation_0, 
       category_5.category_id AS category_5_category_id_0, category_5.name AS category_5_name_0, category_5.description AS category_5_description_0, 
       comment_6.comment_id AS comment_6_comment_id_0, comment_6.blog_id AS comment_6_blog_id_0, comment_6.comment_text AS comment_6_comment_text_0, comment_6.date_creation AS comment_6_date_creation_0, comment_6.blog_id AS comment_6_blog_id_0_6, 
       blog_7.blog_id AS blog_7_blog_id_0, blog_7.blog_text AS blog_7_blog_text_0, blog_7.date_creation AS blog_7_date_creation_0, blog_7.author_id AS blog_7_author_id_0_7, 
       author_8.author_id AS author_8_author_id_0, author_8.name AS author_8_name_0, author_8.birthdate AS author_8_birthdate_0, author_8.sex AS author_8_sex_0, 
       comment_9.comment_id AS comment_9_comment_id_0, comment_9.blog_id AS comment_9_blog_id_0, comment_9.comment_text AS comment_9_comment_text_0, comment_9.date_creation AS comment_9_date_creation_0, 
       category_10.category_id AS category_10_category_id_0, category_10.name AS category_10_name_0, category_10.description AS category_10_description_0, 
       category_11.category_id AS category_11_category_id_0, category_11.name AS category_11_name_0, category_11.description AS category_11_description_0, 
       blog_12.blog_id AS blog_12_blog_id_0, blog_12.blog_text AS blog_12_blog_text_0, blog_12.date_creation AS blog_12_date_creation_0, blog_12.author_id AS blog_12_author_id_0_12, 
       author_13.author_id AS author_13_author_id_0, author_13.name AS author_13_name_0, author_13.birthdate AS author_13_birthdate_0, author_13.sex AS author_13_sex_0, 
       comment_14.comment_id AS comment_14_comment_id_0, comment_14.blog_id AS comment_14_blog_id_0, comment_14.comment_text AS comment_14_comment_text_0, comment_14.date_creation AS comment_14_date_creation_0, 
       category_15.category_id AS category_15_category_id_0, category_15.name AS category_15_name_0, category_15.description AS category_15_description_0 
FROM blog 
LEFT OUTER JOIN author author_1 ON author_1.author_id = blog.author_id 
LEFT OUTER JOIN blog blog_2 ON blog_2.author_id = author_1.author_id 
LEFT OUTER JOIN author author_3 ON author_3.author_id = blog_2.author_id 
LEFT OUTER JOIN comment comment_4 ON comment_4.blog_id = blog_2.blog_id 
LEFT OUTER JOIN category_blog category_blog_5 ON blog_2.blog_id = category_blog_5.blog_id 
LEFT OUTER JOIN category category_5 ON category_blog_5.category_id = category_5.category_id 
LEFT OUTER JOIN comment comment_6 ON comment_6.blog_id = blog.blog_id 
LEFT OUTER JOIN blog blog_7 ON blog_7.blog_id = comment_6.blog_id 
LEFT OUTER JOIN author author_8 ON author_8.author_id = blog_7.author_id 
LEFT OUTER JOIN comment comment_9 ON comment_9.blog_id = blog_7.blog_id 
LEFT OUTER JOIN category_blog category_blog_10 ON blog_7.blog_id = category_blog_10.blog_id 
LEFT OUTER JOIN category category_10 ON category_blog_10.category_id = category_10.category_id 
LEFT OUTER JOIN category_blog category_blog_11 ON blog.blog_id = category_blog_11.blog_id 
LEFT OUTER JOIN category category_11 ON category_blog_11.category_id = category_11.category_id 
LEFT OUTER JOIN category_blog category_blog_12 ON category_11.category_id = category_blog_12.category_id 
LEFT OUTER JOIN blog blog_12 ON category_blog_12.blog_id = blog_12.blog_id 
LEFT OUTER JOIN author author_13 ON author_13.author_id = blog_12.author_id 
LEFT OUTER JOIN comment comment_14 ON comment_14.blog_id = blog_12.blog_id 
LEFT OUTER JOIN category_blog category_blog_15 ON blog_12.blog_id = category_blog_15.blog_id 
LEFT OUTER JOIN category category_15 ON category_blog_15.category_id = category_15.category_id 
WHERE blog.blog_id = :blog_id</span></pre>
              </div>
              <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3850">Select columns fetching relationships and define custom SQL alias</a></p>
            <div class="manual_div_content">
               It is sometimes necessary to not request all table columns to optimize : indeed, selecting columns really used by a process limits network traffic between database and C++ application, so performance are improved.<br>
               <br>
               About relationships, QxOrm library provides a syntax to select columns to fetch, using format : <b>my_relation { col_1, col_2, etc... }</b>.
               By default, if this syntax is not used, then QxOrm library fetches all columns.<br>
               <br>
               <b>For example</b> : imagine a query to fetch :
               <ul>
                  <li>only <i>blog_text</i> column of <i>blog</i> table ;</li>
                  <li>only <i>name</i> and <i>birthdate</i> columns of <i>author</i> table ;</li>
                  <li>only <i>comment_text</i> column of <i>comment</i> table.</li>
               </ul>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre><span class="comment">   // Fetch relations defining columns to fetch with syntax { col_1, col_2, etc... }
</span>   list_blog lstBlogComplexRelation<span class="operator">;</span>
   <font style="background-color:yellow">QStringList relations<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "{ blog_text }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "author_id { name, birthdate }"</span><span class="operator"> &lt;&lt;</span><span class="string"> "list_comment { comment_text }"</span><span class="operator">;</span></font>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all_with_relation<span class="operator">(</span>relations<span class="operator">,</span> lstBlogComplexRelation<span class="operator">);</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lstBlogComplexRelation<span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_creation<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_sex<span class="operator"> ==</span> author<span class="operator">::</span>unknown<span class="operator">);</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_author<span class="operator">-&gt;</span>m_name<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">);</span>
   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_dt_create<span class="operator">.</span>isNull<span class="operator">());</span><span class="comment"> // Not fetched
</span>   qAssert<span class="operator">(</span>lstBlogComplexRelation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_commentX<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator"> !=</span><span class="string"> ""</span><span class="operator">);</span><span class="comment"> // Fetched</span></pre>
               </td></tr></tbody></table>
               <br>
               <b>Note :</b> another syntax is available to select columns to not fetch : <b>my_relation -{ col_1, col_2, etc... }</b>.
               <br><br>
               <b>Other note :</b> you can also define <b>a custom SQL alias per relation</b>.
               This is useful to write your <i>WHERE</i> conditions in the SQL query.
               A SQL alias can be defined between characters <b>&lt;</b> <b>&gt;</b>.
               <br><br>
               <b>Example :</b> here is a fetch with relationships example defining some SQL aliases per relation :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="select relationships columns">
<pre>list_blog lstBlogComplexRelation3;
QStringList relations;
relations &lt;&lt; <span class="string">"<font style="background-color:yellow">&lt;blog_alias&gt;</font> { blog_text }"</span>;
relations &lt;&lt; <span class="string">"author_id <font style="background-color:yellow">&lt;author_alias&gt;</font> { name, birthdate }"</span>;
relations &lt;&lt; <span class="string">"list_comment <font style="background-color:yellow">&lt;list_comment_alias&gt;</font> { comment_text } -&gt; blog_id <font style="background-color:yellow">&lt;blog_alias_2&gt;</font> -&gt; * <font style="background-color:yellow">&lt;..._my_alias_suffix&gt;</font>"</span>;
QSqlError daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation3);
qx::dump(lstBlogComplexRelation3);</pre>
               </td></tr></tbody></table>
               <br><br>
               This code generates following SQL query :
               <br>
               <div style="width:900px; height:230px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog_alias.blog_id AS blog_alias_blog_id_0, blog_alias.blog_text AS blog_alias_blog_text_0, blog_alias.author_id AS blog_alias_author_id_0, author_alias.author_id AS author_alias_author_id_0, author_alias.name AS author_alias_name_0, author_alias.birthdate AS author_alias_birthdate_0, list_comment_alias.comment_id AS list_comment_alias_comment_id_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0, list_comment_alias.comment_text AS list_comment_alias_comment_text_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0_2, blog_alias_2.blog_id AS blog_alias_2_blog_id_0, blog_alias_2.blog_text AS blog_alias_2_blog_text_0, blog_alias_2.date_creation AS blog_alias_2_date_creation_0, blog_alias_2.author_id AS blog_alias_2_author_id_0_3, author_my_alias_suffix.author_id AS author_my_alias_suffix_author_id_0, author_my_alias_suffix.name AS author_my_alias_suffix_name_0, author_my_alias_suffix.birthdate AS author_my_alias_suffix_birthdate_0, author_my_alias_suffix.sex AS author_my_alias_suffix_sex_0, comment_my_alias_suffix.comment_id AS comment_my_alias_suffix_comment_id_0, comment_my_alias_suffix.blog_id AS comment_my_alias_suffix_blog_id_0, comment_my_alias_suffix.comment_text AS comment_my_alias_suffix_comment_text_0, comment_my_alias_suffix.date_creation AS comment_my_alias_suffix_date_creation_0, comment_my_alias_suffix.blog_id AS comment_my_alias_suffix_blog_id_0_5, category_my_alias_suffix.category_id AS category_my_alias_suffix_category_id_0, category_my_alias_suffix.name AS category_my_alias_suffix_name_0, category_my_alias_suffix.description AS category_my_alias_suffix_description_0
  FROM blog AS <font style="background-color:yellow">blog_alias</font>
  LEFT OUTER JOIN author <font style="background-color:yellow">author_alias</font> ON author_alias.author_id = blog_alias.author_id
  LEFT OUTER JOIN comment <font style="background-color:yellow">list_comment_alias</font> ON list_comment_alias.blog_id = blog_alias.blog_id
  LEFT OUTER JOIN blog <font style="background-color:yellow">blog_alias_2</font> ON blog_alias_2.blog_id = list_comment_alias.blog_id
  LEFT OUTER JOIN author <font style="background-color:yellow">author_my_alias_suffix</font> ON author_my_alias_suffix.author_id = blog_alias_2.author_id
  LEFT OUTER JOIN comment <font style="background-color:yellow">comment_my_alias_suffix</font> ON comment_my_alias_suffix.blog_id = blog_alias_2.blog_id
  LEFT OUTER JOIN category_blog category_blog_6 ON blog_alias_2.blog_id = category_blog_6.blog_id
  LEFT OUTER JOIN category <font style="background-color:yellow">category_my_alias_suffix</font> ON category_blog_6.category_id = category_my_alias_suffix.category_id</span></pre>
               </div>
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3855">Add SQL query inside LEFT OUTER JOIN / INNER JOIN</a></p>
            <div class="manual_div_content">
               <a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx::QxSqlQuery</a> class (or its <a href="../doxygen/html/classqx_1_1_qx_sql_query.html" target="_blank">qx_query</a> alias) provides the following method :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlQuery::addJoinQuery()">
<pre>QxSqlQuery & QxSqlQuery::<font style="background-color:yellow">addJoinQuery</font>(const QString & relationKeyOrAlias, const QxSqlQuery & joinQuery);</pre>
               </td></tr></tbody></table>
               <br><br>
               The <i>qx::QxSqlQuery::addJoinQuery()</i> method inserts SQL sub-queries inside <i>LEFT OUTER JOIN</i> / <i>INNER JOIN</i>.<br>
               For example :
               <br><br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::QxSqlQuery::addJoinQuery()">
<pre><span class="comment">// Test to add join SQL sub-queries (inside LEFT OUTER JOIN or INNER JOIN)</span>
list_blog lstBlogWithJoinQueries;
qx_query query = qx_query().where(<span class="string">"blog_alias.blog_text"</span>).isEqualTo(<span class="string">"update blog_text_1"</span>);
<font style="background-color:yellow">query.addJoinQuery</font>(<span class="string">"list_comment_alias"</span>, <span class="string">"AND list_comment_alias.comment_text IS NOT NULL"</span>);
<font style="background-color:yellow">query.addJoinQuery</font>(<span class="string">"author_alias"</span>, qx_query().freeText(<span class="string">"AND author_alias.sex = :sex"</span>, QVariantList() &lt;&lt; author::female));
daoError = qx::dao::fetch_by_query_with_relation(QStringList() &lt;&lt; <span class="string">"&lt;blog_alias&gt; { blog_text }"</span> &lt;&lt; <span class="string">"author_id &lt;author_alias&gt; { name, birthdate, sex }"</span> 
                                                               &lt;&lt; <span class="string">"list_comment &lt;list_comment_alias&gt; { comment_text }"</span>, query, lstBlogWithJoinQueries);
qx::dump(lstBlogWithJoinQueries);
qAssert(lstBlogWithJoinQueries.size() &gt; 0);
qAssert(lstBlogWithJoinQueries[0]-&gt;m_text == <span class="string">"update blog_text_1"</span>);
qAssert(lstBlogWithJoinQueries[0]-&gt;m_author-&gt;m_sex == author::female);</pre>
               </td></tr></tbody></table>
               <br><br>
               Above C++ code will build following SQL query :
               <br><br>
               <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre><span class="int">SELECT blog_alias.blog_id AS blog_alias_blog_id_0, blog_alias.blog_text AS blog_alias_blog_text_0, blog_alias.author_id AS blog_alias_author_id_0, author_alias.author_id AS author_alias_author_id_0, author_alias.name AS author_alias_name_0, author_alias.birthdate AS author_alias_birthdate_0, author_alias.sex AS author_alias_sex_0, list_comment_alias.comment_id AS list_comment_alias_comment_id_0, list_comment_alias.blog_id AS list_comment_alias_blog_id_0, list_comment_alias.comment_text AS list_comment_alias_comment_text_0
  FROM blog AS blog_alias
  LEFT OUTER JOIN author author_alias ON (author_alias.author_id = blog_alias.author_id
      <font style="background-color:yellow">AND author_alias.sex = :sex</font>)
  LEFT OUTER JOIN comment list_comment_alias ON (list_comment_alias.blog_id = blog_alias.blog_id
      <font style="background-color:yellow">AND list_comment_alias.comment_text IS NOT NULL</font>)
  WHERE blog_alias.blog_text = :blog_alias_blog_text_1_0</span></pre>
               </div>
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_390">Supported containers</a></p>
         <div class="manual_div_content">
            QxOrm library supports several containers provided by <a href="#manual_3900">Qt</a>, <a href="#manual_3910">boost</a> and <a href="#manual_3920">std standard library</a>.
            QxOrm library provides also its own container, named <a href="#manual_3930">qx::QxCollection</a>, especially designed to store data fetched from database.
            So the developer is not restricted : QxOrm library offers a large choice of containers.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3900">Qt containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt collections">
<pre>
  QList&lt;T&gt;  
  QVector&lt;T&gt;  
  QSet&lt;T&gt;  
  QLinkedList&lt;T&gt;  
  QHash&lt;Key, Value&gt;  
  QMap&lt;Key, Value&gt;  
  QMultiHash&lt;Key, Value&gt;  
  QMultiMap&lt;Key, Value&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3910">Boost containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost collections">
<pre>
  boost::unordered_map&lt;Key, Value&gt;  
  boost::unordered_set&lt;T&gt;  
  boost::unordered_multimap&lt;Key, Value&gt;  
  boost::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3920">std containers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std collections">
<pre>
  std::list&lt;T&gt;  
  std::vector&lt;T&gt;  
  std::set&lt;T&gt;  
  std::map&lt;Key, Value&gt;  

  std::unordered_map&lt;Key, Value&gt;  
  std::unordered_set&lt;T&gt;  
  std::unordered_multimap&lt;Key, Value&gt;  
  std::unordered_multiset&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_3930">qx::QxCollection</a></p>
            <div class="manual_div_content">
              There are several containers provided by <b>stl</b>, <b>boost</b> and <b>Qt</b> libraries.<br>
              So, it is legitimate to ask this question : what is <i>qx::QxCollection&lt;Key, Value&gt;</i> for ?<br>
              <i><a href="../doxygen/html/classqx_1_1_qx_collection.html" target="_blank">qx::QxCollection&lt;Key, Value&gt;</a></i> is a new <i>container</i> (based on the excellent <a href="http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html" target="_blank"><i>boost::multi_index_container</i></a> library) which has following features :
              <ul><li>keeps insertion order of items in the list ;
              </li><li>quick access to an item by its index : is equivalent to <i>std::vector&lt;T&gt;</i> or <i>QList&lt;T&gt;</i> for example ;
              </li><li>quick access to an item by a key (<i>hash-map</i>) : is equivalent to <i>QHash&lt;Key, Value&gt;</i> or <i>boost::unordered_map&lt;Key, Value&gt;</i> for example ;
              </li><li>sort by <i>Key</i> type and by <i>Value</i> type ;
              </li><li>thread-safe.
              </li></ul>
              <b>Note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is compatible with the <i>foreach</i> macro provided by <b>Qt</b> library and the <a href="http://www.boost.org/doc/libs/release/doc/html/foreach.html" target="_blank"><i>BOOST_FOREACH</i></a> macro provided by <b>boost</b> library.<br>
              However, each element returned by these 2 macros matches to an object of <i>std::pair&lt;Key, Value&gt;</i> type.<br>
              To get a more natural and more readable result, it is advised to use the <i>_foreach</i> macro : this macro uses <i>BOOST_FOREACH</i> for all containers except for <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              In this case, the returned element matches to the <i>Value</i> type (cf. <i>sample</i>).<br>
              <i>_foreach</i> macro is compatible with all <i>containers</i> (<b>stl</b>, <b>Qt</b>, <b>boost</b>...) since it uses <i>BOOST_FOREACH</i> macro.<br><br>

              <b>Additional note :</b> <i>qx::QxCollection&lt;Key, Value&gt;</i> is especially designed to receive data resulting from a database.<br>
              Indeed, these data can be sorted (using <i>ORDER BY</i> in a SQL query for example), it is thus important to keep insertion order of items in the list.<br>
              Furthermore, each data resulting from a database has a unique id : it is thus important to be able to access quickly to an item based on this single identifier (<i>hash-map</i>).<br><br>

              <b>Sample :</b><br>
              <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">/* definition of drug class with 3 properties : code, name, description */</span><span class="keyword">
class</span> drug<span class="operator"> {</span><span class="keyword"> public</span><span class="operator">:</span> QString code<span class="operator">;</span> QString name<span class="operator">;</span> QString desc<span class="operator">; };</span><span class="comment">

/* smart pointer of drug */</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>drug<span class="operator">&gt;</span> drug_ptr<span class="operator">;</span><span class="comment">

/* collection of drugs by code */</span>
qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> lstDrugs<span class="operator">;</span><span class="comment">

/* create 3 new drugs */</span>
drug_ptr d1<span class="operator">;</span> d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d1<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span> d1<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span>
drug_ptr d2<span class="operator">;</span> d2<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d2<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name2"</span><span class="operator">;</span> d2<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc2"</span><span class="operator">;</span>
drug_ptr d3<span class="operator">;</span> d3<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span> d3<span class="operator">-&gt;</span>code<span class="operator"> =</span><span class="string"> "code3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name3"</span><span class="operator">;</span> d3<span class="operator">-&gt;</span>desc<span class="operator"> =</span><span class="string"> "desc3"</span><span class="operator">;</span><span class="comment">

/* insert drugs into the collection */</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d1<span class="operator">-&gt;</span>code<span class="operator">,</span> d1<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d2<span class="operator">-&gt;</span>code<span class="operator">,</span> d2<span class="operator">);</span>
lstDrugs<span class="operator">.</span>insert<span class="operator">(</span>d3<span class="operator">-&gt;</span>code<span class="operator">,</span> d3<span class="operator">);</span><span class="comment">

/* iterate with '_foreach' keyword */</span>
_foreach<span class="operator">(</span>drug_ptr p<span class="operator">,</span> lstDrugs<span class="operator">)
{</span> qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">); }</span><span class="comment">

/* iterate with 'for' keyword */</span><span class="flow">
for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lstDrugs<span class="operator">.</span>count<span class="operator">(); ++</span>l<span class="operator">)
{</span>
   drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span>l<span class="operator">);</span>
   QString code<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getKeyByIndex<span class="operator">(</span>l<span class="operator">);</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>p<span class="operator">-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* iterate with 'QxCollectionIterator' java style */</span>
qx<span class="operator">::</span>QxCollectionIterator<span class="operator">&lt;</span>QString<span class="operator">,</span> drug_ptr<span class="operator">&gt;</span> itr<span class="operator">(</span>lstDrugs<span class="operator">);</span><span class="flow">
while</span><span class="operator"> (</span>itr<span class="operator">.</span>next<span class="operator">())
{</span>
   QString code<span class="operator"> =</span> itr<span class="operator">.</span>key<span class="operator">();</span>
   qDebug<span class="operator">() &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>name<span class="operator">) &lt;&lt;</span><span class="string"> " "</span><span class="operator"> &lt;&lt;</span> qPrintable<span class="operator">(</span>itr<span class="operator">.</span>value<span class="operator">()-&gt;</span>desc<span class="operator">);
}</span><span class="comment">

/* sort ascending by key and sort descending by value */</span>
lstDrugs<span class="operator">.</span>sortByKey<span class="operator">(</span><span class="bool">true</span><span class="operator">);</span>
lstDrugs<span class="operator">.</span>sortByValue<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="comment">

/* access drug by code */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByKey<span class="operator">(</span><span class="string">"code2"</span><span class="operator">);</span><span class="comment">

/* access drug by index */</span>
drug_ptr p<span class="operator"> =</span> lstDrugs<span class="operator">.</span>getByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* test if drug exists and if collection is empty */</span><span class="type">
bool</span> bExist<span class="operator"> =</span> lstDrugs<span class="operator">.</span>exist<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="type">
bool</span> bEmpty<span class="operator"> =</span> lstDrugs<span class="operator">.</span>empty<span class="operator">();</span><span class="comment">

/* remove the second drug from collection */</span>
lstDrugs<span class="operator">.</span>removeByIndex<span class="operator">(</span><span class="int">2</span><span class="operator">);</span><span class="comment">

/* remove the drug with "code3" */</span>
lstDrugs<span class="operator">.</span>removeByKey<span class="operator">(</span><span class="string">"code3"</span><span class="operator">);</span><span class="comment">

/* clear the collection */</span>
lstDrugs<span class="operator">.</span>clear<span class="operator">();</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_400">Supported smart pointers</a></p>
         <div class="manual_div_content">
            QxOrm library supports several smart pointers provided by <a href="#manual_4000">Qt</a>, <a href="#manual_4010">boost</a> and <a href="#manual_4020">std standard library</a>.
            QxOrm library provides also its own smart pointer, named <a href="#manual_4030">qx::dao::ptr</a>, which provides new features when used with <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> functions.
            So the developer is not restricted : QxOrm library offers a large choice of smart pointers.
            <br><br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4000">Qt smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt smart pointers">
<pre>
  QSharedPointer&lt;T&gt;  
  QScopedPointer&lt;T&gt;  
  QWeakPointer&lt;T&gt;  
  QSharedDataPointer&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4010">Boost smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="boost smart pointers">
<pre>
  boost::shared_ptr&lt;T&gt;  
  boost::intrusive_ptr&lt;T&gt;  
  boost::scoped_ptr&lt;T&gt;  
  boost::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4020">std smart pointers</a></p>
            <div class="manual_div_content">
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="std smart pointers">
<pre>
  std::shared_ptr&lt;T&gt;  
  std::unique_ptr&lt;T&gt;  
  std::weak_ptr&lt;T&gt;  
</pre>
               </td></tr></tbody></table>
               <br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4030">qx::dao::ptr</a></p>
            <div class="manual_div_content">
              <b>QxOrm</b> library can be used with smart-pointers provided by <b>std</b>, <b>boost</b> and <b>Qt</b> libraries.<br>
              <b>QxOrm</b> smart-pointer is based on <i>QSharedPointer</i> and provides new features with '<i>qx::dao::...</i>' functions.<br>
              <i><a href="../doxygen/html/classqx_1_1dao_1_1ptr.html" target="_blank">qx::dao::ptr&lt;T&gt;</a></i> keeps automatically values from database.<br>
              So it's possible to detect if an instance has been modified using the method '<i>isDirty()</i>' : this method can return list of properties changed.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> can also be used with the function '<i>qx::dao::update_optimized()</i>' to update in database only properties changed.<br>
              <i>qx::dao::ptr&lt;T&gt;</i> can be used with a simple object and with many containers : <i>stl</i>, <i>boost</i>, <i>Qt</i> and <i>qx::QxCollection&lt;Key, Value&gt;</i>.<br>
              <br>
              <b>Sample :</b><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">   // Test 'isDirty()' method
</span>   qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_isdirty<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   blog_isdirty<span class="operator">-&gt;</span>m_id<span class="operator"> =</span> blog_1<span class="operator">-&gt;</span>m_id<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>

   blog_isdirty<span class="operator">-&gt;</span>m_text<span class="operator"> =</span><span class="string"> "blog property 'text' modified =&gt; blog is dirty !!!"</span><span class="operator">;</span>
   QStringList lstDiff<span class="operator">;</span><span class="type"> bool</span> bDirty<span class="operator"> =</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">) &amp;&amp; (</span>lstDiff<span class="operator">.</span>at<span class="operator">(</span><span class="int">0</span><span class="operator">) ==</span><span class="string"> "blog_text"</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 1 : blog is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_text' of 'blog_isdirty'
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>blog_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> blog_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>blog_isdirty<span class="operator">);</span><span class="comment">

   // Test 'isDirty()' method with a container
</span><span class="keyword">   typedef</span> qx<span class="operator">::</span>dao<span class="operator">::</span>ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt; &gt;</span> type_lst_author_test_is_dirty<span class="operator">;</span>

   type_lst_author_test_is_dirty container_isdirty<span class="operator"> =</span> type_lst_author_test_is_dirty<span class="operator">(</span><span class="keyword">new</span> QList<span class="operator">&lt;</span>author_ptr<span class="operator">&gt;());</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">() &amp;&amp; (</span>container_isdirty<span class="operator">-&gt;</span>count<span class="operator">() ==</span><span class="int"> 3</span><span class="operator">));</span>

   author_ptr author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">1</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_name<span class="operator"> =</span><span class="string"> "author name modified at index 1 =&gt; container is dirty !!!"</span><span class="operator">;</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 1</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 2 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span>

   author_ptr_dirty<span class="operator"> =</span> container_isdirty<span class="operator">-&gt;</span>at<span class="operator">(</span><span class="int">2</span><span class="operator">);</span>
   author_ptr_dirty<span class="operator">-&gt;</span>m_birthdate<span class="operator"> =</span> QDate<span class="operator">(</span><span class="int">1998</span><span class="operator">,</span><span class="int"> 03</span><span class="operator">,</span><span class="int"> 06</span><span class="operator">);</span>
   bDirty<span class="operator"> =</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">(</span>lstDiff<span class="operator">);</span>
   qAssert<span class="operator">(</span>bDirty<span class="operator"> &amp;&amp; (</span>lstDiff<span class="operator">.</span>count<span class="operator">() ==</span><span class="int"> 2</span><span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>bDirty<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] test dirty 3 : container is dirty =&gt; '%s'"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>lstDiff<span class="operator">.</span>join<span class="operator">(</span><span class="string">"|"</span><span class="operator">))); }</span><span class="comment">

   // Update only property 'm_name' at position 1, only property 'm_birthdate' at position 2 and nothing at position 0
</span>   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>update_optimized<span class="operator">(</span>container_isdirty<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; !</span> container_isdirty<span class="operator">.</span>isDirty<span class="operator">());</span>
   qx<span class="operator">::</span>dump<span class="operator">(</span>container_isdirty<span class="operator">);</span><span class="comment">

   // Fetch only property 'm_dt_creation' of blog
</span>   QStringList lstColumns<span class="operator"> =</span> QStringList<span class="operator">() &lt;&lt;</span><span class="string"> "date_creation"</span><span class="operator">;</span>
   list_blog lst_blog_with_only_date_creation<span class="operator">;</span>
   daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">,</span> NULL<span class="operator">,</span> lstColumns<span class="operator">);</span>
   qAssert<span class="operator">(!</span> daoError<span class="operator">.</span>isValid<span class="operator">() &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">));</span><span class="flow">

   if</span><span class="operator"> ((</span>lst_blog_with_only_date_creation<span class="operator">.</span>size<span class="operator">() &gt;</span><span class="int"> 0</span><span class="operator">) &amp;&amp; (</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">] !=</span> NULL<span class="operator">))
   {</span> qAssert<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">[</span><span class="int">0</span><span class="operator">]-&gt;</span>m_text<span class="operator">.</span>isEmpty<span class="operator">()); }</span>

   qx<span class="operator">::</span>dump<span class="operator">(</span>lst_blog_with_only_date_creation<span class="operator">);</span></pre>
              </td></tr></tbody></table>
              <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_410">Triggers</a></p>
         <div class="manual_div_content">
           With <b>QxOrm</b> <i>Triggers</i>, it is possible to execute custom process before and/or after an insert, update or delete query in database.<br>
           You can find a sample in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.<br>
           <i>BaseClassTrigger</i> sample class contains 5 properties : <i>m_id</i>, <i>m_dateCreation</i>, <i>m_dateModification</i>, <i>m_userCreation</i> and <i>m_userModification</i>.<br>
           In the following example, each property will be automatically auto-updated for all derived classes from <i>BaseClassTrigger</i> (see <i>Foo</i> class and <i>Bar</i> class in the same project).<br>
           It is necessary to specialize '<i>qx::dao::detail::QxDao_Trigger&lt;T&gt;</i>' template to work with this feature.<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BASE_CLASS_TRIGGER_H_
#define _QX_BASE_CLASS_TRIGGER_H_
</span><span class="keyword">
class</span> QX_DLL2_EXPORT BaseClassTrigger<span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   long</span>        m_id<span class="operator">;</span>
   QDateTime   m_dateCreation<span class="operator">;</span>
   QDateTime   m_dateModification<span class="operator">;</span>
   QString     m_userCreation<span class="operator">;</span>
   QString     m_userModification<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   BaseClassTrigger<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">)  { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>BaseClassTrigger<span class="operator">()   { ; }</span><span class="type">

   long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                     {</span><span class="flow"> return</span> m_id<span class="operator">; }</span>
   QDateTime getDateCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">      {</span><span class="flow"> return</span> m_dateCreation<span class="operator">; }</span>
   QDateTime getDateModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">  {</span><span class="flow"> return</span> m_dateModification<span class="operator">; }</span>
   QString getUserCreation<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_userCreation<span class="operator">; }</span>
   QString getUserModification<span class="operator">()</span><span class="keyword"> const</span><span class="operator">    {</span><span class="flow"> return</span> m_userModification<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                              {</span> m_id<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDateCreation<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)      {</span> m_dateCreation<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setDateModification<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)  {</span> m_dateModification<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setUserCreation<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)         {</span> m_userCreation<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setUserModification<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)     {</span> m_userModification<span class="operator"> =</span> s<span class="operator">; }</span>

   <font style="background-color:yellow"><span class="type">void</span> onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>
   <font style="background-color:yellow"><span class="type">void</span> onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> dao<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span>
<font style="background-color:yellow"><span class="keyword">struct</span> QxDao_Trigger<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt;</span></font>
<span class="operator">{</span><span class="keyword">

   static inline</span><span class="type"> void</span> onBeforeInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeInsert<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span><span class="flow"> if</span><span class="operator"> (</span>t<span class="operator">) {</span> t<span class="operator">-&gt;</span>onBeforeUpdate<span class="operator">(</span>dao<span class="operator">); } }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onBeforeFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterInsert<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterUpdate<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }</span><span class="keyword">
   static inline</span><span class="type"> void</span> onAfterDelete<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }
   static inline</span><span class="type"> void</span> onAfterFetch<span class="operator">(</span>BaseClassTrigger<span class="operator"> *</span> t<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)
   {</span> Q_UNUSED<span class="operator">(</span>t<span class="operator">);</span> Q_UNUSED<span class="operator">(</span>dao<span class="operator">); }

};

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace dao
</span><span class="operator">}</span><span class="comment"> // namespace qx
</span><span class="pre">
#endif // _QX_BASE_CLASS_TRIGGER_H_
</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/BaseClassTrigger.h"
#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_QX_DLL2<span class="operator">(</span>BaseClassTrigger<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>BaseClassTrigger<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   IxDataMember<span class="operator"> *</span> pData<span class="operator"> =</span> NULL<span class="operator">;</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>id<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateCreation<span class="operator">,</span><span class="string"> "date_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_dateModification<span class="operator">,</span><span class="string"> "date_modification"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userCreation<span class="operator">,</span><span class="string"> "user_creation"</span><span class="operator">);</span>
   pData<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> BaseClassTrigger<span class="operator">::</span>m_userModification<span class="operator">,</span><span class="string"> "user_modification"</span><span class="operator">);
}}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeInsert<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateCreation<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userCreation<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_1"</span><span class="operator">;
}</span>

<font style="background-color:yellow"><span class="type">void</span> BaseClassTrigger<span class="operator">::</span>onBeforeUpdate<span class="operator">(</span>qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>IxDao_Helper<span class="operator"> *</span> dao<span class="operator">)</span></font>
<span class="operator">{</span>
   Q_UNUSED<span class="operator">(</span>dao<span class="operator">);</span>
   m_dateModification<span class="operator"> =</span> QDateTime<span class="operator">::</span>currentDateTime<span class="operator">();</span>
   m_userModification<span class="operator"> =</span><span class="string"> "current_user_2"</span><span class="operator">;
}</span>
</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_420">Validators</a></p>
         <div class="manual_div_content">
            <b><a href="../doxygen/html/group___qx_validator.html" target="_blank">QxValidator</a></b> module of <b>QxOrm</b> library provides a validation engine for classes registered in QxOrm context.<br>
            To use this validation engine, you have to define your constraints into the mapping function per class : <i>void qx::register_class&lt;T&gt;</i>.<br>
            If for an instance of class, at least one constraint violation is detected, then the instance is invalid : the object cannot be saved into database (<i>INSERT</i> or <i>UPDATE</i>).<br>
            <br>
            It's also possible to use <b>QxValidator</b> module to validate an instance on the presentation layer : if some datas from a user are invalids, an error message can be displayed, and it's not necessary to try to send the instance to the data access layer.<br>
            The validation process can be executed in several layers of your application without having to duplicate any of these rules (presentation layer, data access layer).<br>
            <br>
            Here is a description of some classes defined in <b>QxValidator</b> module :
            <ul>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator.html" target="_blank">qx::IxValidator</a> : each constraint defined in <i>void qx::register_class&lt;T&gt;</i> function is associated with an interface of <i>qx::IxValidator</i> type ;</li>
                <li><a href="../doxygen/html/classqx_1_1_ix_validator_x.html" target="_blank">qx::IxValidatorX</a> : the list of constraints is associated with an interface of <i>qx::IxValidatorX</i> type. You can iterate over this collection during program execution : it could be interesting for example to generate DDL SQL schema and to take into account some validation rules into database (read the chapter : <a href="#manual_470">Generate database DDL SQL schema</a>) ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value_x.html" target="_blank">qx::QxInvalidValueX</a> : when an instance is invalid, list of constraints violation are inserted into a <i>qx::QxInvalidValueX</i> collection ;</li>
                <li><a href="../doxygen/html/classqx_1_1_qx_invalid_value.html" target="_blank">qx::QxInvalidValue</a> : each item into this collection is a <i>qx::QxInvalidValue</i> type and contains an error message (description to explain why the instance is not valid).</li>
            </ul>
            <b>QxValidator</b> module manages automatically class inheritance : each constraint defined into a base class is checked during validation process of a derived class.<br>
            <br>
            Here is an example using <b>QxValidator</b> module with a '<i>person</i>' class :<br>
            <br>
            * '<i>person.h</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _CLASS_PERSON_H_
#define _CLASS_PERSON_H_
</span><span class="keyword"> 
class</span> person<span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span><span class="keyword">

   enum</span> sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="type">

   long</span>        _id<span class="operator">;</span>
   QString     _firstName<span class="operator">;</span>
   QString     _lastName<span class="operator">;</span>
   QDateTime   _birthDate<span class="operator">;</span>
   sex         _sex<span class="operator">;</span>

   person<span class="operator">() :</span> _id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span>
   person<span class="operator">(</span><span class="type">long</span> id<span class="operator">) :</span> _id<span class="operator">(</span>id<span class="operator">),</span> _sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span><span class="keyword">

private</span><span class="operator">:</span>

   <font style="background-color:yellow"><span class="type">void</span> isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _CLASS_PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>person.cpp</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/person.h"
#include "../include/global_validator.h"

#include &lt;QxOrm_Impl.h&gt;
</span>
QX_REGISTER_CPP_MY_EXE<span class="operator">(</span>person<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>_id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_firstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_lastName<span class="operator">,</span><span class="string"> "lastName"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_birthDate<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   <font style="background-color:yellow">QxValidatorX<span class="operator">&lt;</span>person<span class="operator">&gt; *</span> pAllValidator<span class="operator"> =</span> t<span class="operator">.</span>getAllValidator<span class="operator">();</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_NotEmpty<span class="operator">(</span><span class="string">"lastName"</span><span class="operator">,</span><span class="string"> "a person must have a lastname"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator<span class="operator">(&amp;</span> person<span class="operator">::</span>isValid<span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_QVariant<span class="operator">(&amp;</span> validateFirstName<span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span>
   pAllValidator<span class="operator">-&gt;</span>add_CustomValidator_DataType<span class="operator">&lt;</span>QDateTime<span class="operator">&gt;(&amp;</span> validateDateTime<span class="operator">,</span><span class="string"> "birthDate"</span><span class="operator">);</span></font>
<span class="operator">}}</span>

<font style="background-color:yellow"><span class="type">void</span> person<span class="operator">::</span>isValid<span class="operator">(</span>qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)</span></font>
<span class="operator">{</span><span class="comment">
   // This method is called automatically by 'QxValidator' module (validator engine of QxOrm library) :
   // - when you try to insert or update using 'qx::dao::xxx' functions
   // - when you call 'qx::validate()' function

   // For registration, see 'pAllValidator->add_CustomValidator(& person::isValid);' into 'qx::register_class' function

   // Here, you can verify some values of your instance
   // If a value is not valid, you must add an invalid value into the collection 'invalidValues'

   // For example, if we want to check property '_sex' of a person :
</span><span class="flow">   if</span><span class="operator"> ((</span>_sex<span class="operator"> !=</span> male<span class="operator">) &amp;&amp; (</span>_sex<span class="operator"> !=</span> female<span class="operator">))
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"person sex must be defined : male or female"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>global_validator.h</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Example of global functions 'validateFirstName' and 'validateDateTime' used by 'QxValidator' module
// Those functions will be called automatically by validator engine of QxOrm library :
// - when you try to insert or update using 'qx::dao::xxx' functions
// - when you call 'qx::validate()' function
</span><span class="type"> 
void</span> validateFirstName<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Here you can test the value (converted to QVariant type)
   // If an invalid value is detected, just add a message into 'invalidValues' collection

   // For example, if the value must be never equal to "admin" :
</span><span class="flow">   if</span><span class="operator"> (</span>value<span class="operator">.</span>toString<span class="operator">() ==</span><span class="string"> "admin"</span><span class="operator">)
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"value must not be equal to 'admin'"</span><span class="operator">); }
}</span><span class="type">

void</span> validateDateTime<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> value<span class="operator">,</span><span class="keyword"> const</span> qx<span class="operator">::</span>IxValidator<span class="operator"> *</span> validator<span class="operator">,</span> qx<span class="operator">::</span>QxInvalidValueX<span class="operator"> &amp;</span> invalidValues<span class="operator">)
{</span><span class="comment">
   // Here you can test the value (with its real type, in this example, the data-member is a 'QDateTime' type)
   // If an invalid value is detected, just add a message into 'invalidValues' collection

   // For example, if the date-time must be valid :
</span><span class="flow">   if</span><span class="operator"> (!</span> value<span class="operator">.</span>isValid<span class="operator">())
   {</span> invalidValues<span class="operator">.</span>insert<span class="operator">(</span><span class="string">"date-time value must not be empty and must be valid"</span><span class="operator">); }
}</span></pre>
            </td></tr></tbody></table>
            <br>
            * '<i>main.cpp</i>' file :<br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>person personValidate<span class="operator">;</span>
personValidate<span class="operator">.</span>_lastName<span class="operator"> =</span><span class="string"> "admin"</span><span class="operator">;</span>
qx<span class="operator">::</span>QxInvalidValueX invalidValues<span class="operator"> =</span> qx<span class="operator">::</span>validate<span class="operator">(</span>personValidate<span class="operator">);</span>
QString sInvalidValues<span class="operator"> =</span> invalidValues<span class="operator">.</span>text<span class="operator">();</span>
qDebug<span class="operator">(</span><span class="string">"[QxOrm] test 'QxValidator' module :\n%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sInvalidValues<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            During program execution of above source code, '<i>personValidate</i>' instance is not valid : '<i>invalidValues</i>' collection contains 4 items :<br>
            - "<i>property 'firstName' must not be empty</i>" ;<br>
            - "<i>person sex must be defined : male or female</i>" ;<br>
            - "<i>value must not be equal to 'admin'</i>" ;<br>
            - "<i>date-time value must not be empty and must be valid</i>".<br>
            <br>
            <b>QxValidator</b> module provides some built-in constraints, which cover most of the basic data checks.<br>
            As we'll see later, you're not limited to them, you can literally in a minute write your own constraints :
            <ul>
                <li><i>add_NotNull()</i> : checks if the value is not null ;</li>
                <li><i>add_NotEmpty()</i> : checks if the string is not empty ;</li>
                <li><i>add_MinValue()</i> : checks if the value is more than or equals to min ;</li>
                <li><i>add_MaxValue()</i> : checks if the value is less than or equals to max ;</li>
                <li><i>add_Range()</i> : checks if the value is between Min and Max (included) ;</li>
                <li><i>add_MinDecimal()</i> : checks if the decimal value is more than or equals to min ;</li>
                <li><i>add_MaxDecimal()</i> : checks if the decimal value is less than or equals to max ;</li>
                <li><i>add_RangeDecimal()</i> : checks if the decimal value is between Min and Max (included) ;</li>
                <li><i>add_MinLength()</i> : checks if the string length is more than or equals to min ;</li>
                <li><i>add_MaxLength()</i> : checks if the string length is less than or equals to max ;</li>
                <li><i>add_Size()</i> : checks if the string length is between the min-max range ;</li>
                <li><i>add_DatePast()</i> : checks if the date is in the past ;</li>
                <li><i>add_DateFuture()</i> : checks if the date is in the future ;</li>
                <li><i>add_RegExp()</i> : checks if the property matches the regular expression given a match flag ;</li>
                <li><i>add_EMail()</i> : checks whether the string conforms to the email address specification.</li>
            </ul>
            Like '<i>person</i>' class example, it's possible to define a custom validator : it's a function or a class method called automatically by <b>QxValidator</b> module to validate a property or an instance of class.<br>
            There are 3 kinds of custom validator :
            <ul>
                <li><i>add_CustomValidator()</i> : class method, method signature must be "<i>void my_class::my_method(qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_QVariant()</i> : global function with <i>QVariant</i> type (the property is converted into <i>QVariant</i> type), function signature must be "<i>void my_validator(const QVariant &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
                <li><i>add_CustomValidator_DataType()</i> : global function with real type, function signature must be "<i>void my_validator(const T &, const qx::IxValidator *, qx::QxInvalidValueX &)</i>" ;</li>
            </ul>
            <b>Note :</b> each validator can be associated with a group (optional parameter for each function <i>add_XXX()</i> of <i>qx::IxValidatorX</i> class).<br>
            So it's possible to create a context validation during program execution : for example, a person from IHM A can have different validation rules than a person from IHM B.<br>
            To execute a validation process by group (for example "<i>myGroup</i>"), you have to call the following function : "<i>qx::QxInvalidValueX invalidValues = qx::validate(personValidate, "myGroup");</i>".<br>
            <br>
            <b>Other note :</b> <b>QxValidator</b> module provides default messages when a constraint violation is detected.<br>
            It's possible to modify these default messages (for example, a translation) using the following collection : "<i>QHash<QString, QString> * lstMessage = QxClassX::getAllValidatorMessage();</i>".<br>
            For example : "<i>lstMessage->insert("min_value", "la valeur '%NAME%' doit être inférieure ou égale à '%CONSTRAINT%'");</i>".<br>
            <i>%NAME%</i> and <i>%CONSTRAINT%</i> fields will be automatically replaced by the good value.<br>
            To modify a message for a specific validator (and not globally), you have to use the optional parameter provided by each function <i>add_XXX()</i> of <i>qx::IxValidatorX</i> class.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_430">Manage NULL database value</a></p>
         <div class="manual_div_content">
            All databases manages NULL value : for more details about NULL value, <a href="https://en.wikipedia.org/wiki/Null_%28SQL%29" target="_blank">please read the Wikipedia web page</a>.<br>
            QxOrm library provides several ways to manage NULL value :
            <ul>
               <li>using <a href="#manual_4300">boost::optional</a> class provided by boost library ;</li>
               <li>using <a href="#manual_4310">QVariant</a> class provided by Qt framework ;</li>
               <li>using pointers or smart-pointers : a C++ NULL pointer is associated to a NULL value in database.</li>
            </ul>
            <br>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4300">boost::optional</a></p>
            <div class="manual_div_content">
               <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class provided by boost is the best solution to manage NULL value in C++.<br>
               To use <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> with QxOrm library, you must define <b><i>_QX_ENABLE_BOOST</i></b> compilation option, or include <b><i>&lt;QxExtras/QxBoostOptionalOnly.h&gt;</i></b> header file.<br>
               Here is an example where all properties (except primary key) can be NULL using <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional</a> class :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QString&gt; lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">boost::optional&lt;QDateTime&gt; birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class is very easy to use : please read <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">documentation on boost website</a> for more details.
               <br><br>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_4310">QVariant</a></p>
            <div class="manual_div_content">
               <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> class provided by Qt is another way to manage NULL value in C++.<br>
               Here is a class example where all values (except primary key) can be NULL using <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> class :<br>
               <br>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   <font style="background-color:yellow">QVariant firstName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant lastName<span class="operator">;</span></font>
   <font style="background-color:yellow">QVariant birthDate<span class="operator">;</span></font>  

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }  
};</span>

#endif <span class="comment">// _PERSON_H_</span></span></pre>
               </td></tr></tbody></table>
               <br>
               This solution is not perfect compared to <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> because you loose the property type.<br>
               So it is recommended to work with <a href="http://www.boost.org/doc/libs/release/libs/optional/doc/html/index.html" target="_blank">boost::optional&lt;T&gt;</a> class to manage NULL value with QxOrm library.
               <br><br>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_440">Inheritance and polymorphism</a></p>
         <div class="manual_div_content">
           With <i>ORM</i> tools, there are usually 3 strategies to manage inheritance and database :
           <ul>
           <li><i><a href="http://martinfowler.com/eaaCatalog/singleTableInheritance.html" target="_blank">Single Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/classTableInheritance.html" target="_blank">Class Table Inheritance</a></i> ;
           </li><li><i><a href="http://martinfowler.com/eaaCatalog/concreteTableInheritance.html" target="_blank">Concrete Table Inheritance</a></i>.
           </li></ul>
           <b>QxOrm</b> works by default with <i>Concrete Table Inheritance</i> strategy (others are not supported yet).<br>
           Many tutorials and forums are available on internet for more details about <i>ORM</i> inheritance and database.<br>
           You can find a sample in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_450">qx::IxPersistable interface (abstract class)</a></p>
         <div class="manual_div_content">
           <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface (or abstract class) provides only pure virtual methods.<br>
           Using <i>qx::IxPersistable</i>, you will have a common base class to call all persistents functions without knowing the real type of current instance (polymorphism concept).<br>
           QxOrm library doesn't force developers to work with a base class to register a persistent type in QxOrm context, however it's sometimes useful to have an interface to write some generic algorithms.<br>
           <br>
           <i>qx::IxPersistable</i> class provides following virtual methods (for more details about these methods, goto <a href="../doxygen/index.html" target="_blank">QxOrm library online class documentation</a>) :<br>
           <br>
           <div style="width:900px; height:290px; overflow:auto; background-color:white">
<pre><span class="keyword">virtual</span><span class="type"> long</span> qxCount<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchAll<span class="operator">(</span>qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxFetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> qx<span class="operator">::</span>IxCollection<span class="operator"> &amp;</span> list<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxInsert<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxUpdate<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxSave<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator"> =</span> QStringList<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDeleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyById<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyAll<span class="operator">(</span>QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> QSqlError qxDestroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx<span class="operator">::</span>QxSqlQuery<span class="operator"> &amp;</span> query<span class="operator">,</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx_bool qxExist<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> id<span class="operator"> =</span> QVariant<span class="operator">(),</span> QSqlDatabase<span class="operator"> *</span> pDatabase<span class="operator"> =</span> NULL<span class="operator">);</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>QxInvalidValueX qxValidate<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> groups<span class="operator"> =</span> QStringList<span class="operator">());</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxPersistableCollection_ptr qxNewPersistableCollection<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span><span class="keyword">
virtual</span> qx<span class="operator">::</span>IxClass<span class="operator"> *</span> qxClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></pre>
           </div>
           <br>
           For example, working with a list of <i>qx::IxPersistable</i> pointers, it's possible to save all items to several database tables, like this :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QList<span class="operator">&lt;</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *&gt;</span> lst<span class="operator"> = ...;</span>
foreach<span class="operator">(</span>qx<span class="operator">::</span>IxPersistable<span class="operator"> *</span> p<span class="operator">,</span> lst<span class="operator">)
{</span>
   QSqlError daoError<span class="operator"> =</span> p<span class="operator">-&gt;</span>qxSave<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (</span>daoError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="comment"> /* an error occured */</span><span class="operator"> }</span><span class="comment">
   // etc...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br>
           To implement <i>qx::IxPersistable</i> interface, it's necessary to :
           <ul>
           <li>inherit persistent class from <i>qx::IxPersistable</i> ;</li>
           <li>into class definition (<i>myClass.h</i> for example), add <i>QX_PERSISTABLE_HPP(myClass)</i> macro ;</li>
           <li>into class implementation (<i>myClass.cpp</i> for example), add <i>QX_PERSISTABLE_CPP(myClass)</i> macro.</li>
           </ul>
           For example, to implement <i>qx::IxPersistable</i> interface for <a href="./tutorial.html#tuto_6"><i>author</i></a> class from <i>qxBlog</i> tutorial, you have to write :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.h">
<pre><span class="pre">#ifndef _QX_BLOG_AUTHOR_H_
#define _QX_BLOG_AUTHOR_H_
</span><span class="keyword">
class</span> blog<span class="operator">;</span><span class="keyword">

class</span> QX_BLOG_DLL_EXPORT author : <font style="background-color:yellow"><b>public qx::IxPersistable</b></font><span class="operator">
{</span>
   <font style="background-color:yellow"><b>QX_PERSISTABLE_HPP(author)</b></font>
<span class="keyword">public</span><span class="operator">:</span><span class="comment">
// -- typedef
</span><span class="keyword">   typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
   typedef</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog_ptr<span class="operator">&gt;</span> list_blog<span class="operator">;</span><span class="comment">
// -- enum
</span><span class="keyword">   enum</span> enum_sex<span class="operator"> {</span> male<span class="operator">,</span> female<span class="operator">,</span> unknown<span class="operator"> };</span><span class="comment">
// -- properties
</span>   QString     m_id<span class="operator">;</span>
   QString     m_name<span class="operator">;</span>
   QDate       m_birthdate<span class="operator">;</span>
   enum_sex    m_sex<span class="operator">;</span>
   list_blog   m_blogX<span class="operator">;</span><span class="comment">
// -- contructor, virtual destructor
</span>   author<span class="operator">() :</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_sex<span class="operator">(</span>unknown<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>author<span class="operator">() { ; }</span><span class="comment">
// -- methods
</span><span class="type">   int</span> age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;
};</span>

QX_REGISTER_PRIMARY_KEY<span class="operator">(</span>author<span class="operator">,</span> QString<span class="operator">)</span>
QX_REGISTER_HPP_QX_BLOG<span class="operator">(</span>author<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>author<span class="operator">&gt;</span> author_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> author_ptr<span class="operator">&gt;</span> list_author<span class="operator">;</span><span class="pre">

#endif <span class="comment">// _QX_BLOG_AUTHOR_H_</span>
</span></pre>
        </td></tr></tbody></table>
        <br>
        <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="author.cpp">
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/blog.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span>
</span>
QX_REGISTER_CPP_QX_BLOG<span class="operator">(</span>author<span class="operator">)</span>
<font style="background-color:yellow"><b>QX_PERSISTABLE_CPP(author)</b></font>

<span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>author<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>id<span class="operator">(&amp;</span> author<span class="operator">::</span>m_id<span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_birthdate<span class="operator">,</span><span class="string"> "birthdate"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> author<span class="operator">::</span>m_sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">);</span>

   t<span class="operator">.</span>relationOneToMany<span class="operator">(&amp;</span> author<span class="operator">::</span>m_blogX<span class="operator">,</span><span class="string"> "list_blog"</span><span class="operator">,</span><span class="string"> "author_id"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(&amp;</span> author<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);
}}</span><span class="type">

int</span> author<span class="operator">::</span>age<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_birthdate<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span><span class="operator"> -</span><span class="int">1</span><span class="operator">; }</span><span class="flow">
   return</span><span class="operator"> (</span>QDate<span class="operator">::</span>currentDate<span class="operator">().</span>year<span class="operator">() -</span> m_birthdate<span class="operator">.</span>year<span class="operator">());
}</span>
</pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> project test from <i>./test/qxDllSample/dll1/</i> directory provides a kind of 'super base class' : <i>qx::QxPersistable</i> class implements <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface and inherits from <i>QObject</i>.<br>
           So <i>SIGNAL-SLOT</i> engine of Qt library can be used with this class and could be an interesting way to use QxOrm <a href="#manual_410"><i>triggers</i></a>.<br>
           <i>qx::QxPersistable</i> class provides also some virtual methods to override to manage for example data validation process from <a href="#manual_420"><i>QxValidator</i></a> module.<br>
           For information, <i>qx::QxPersistable</i> class is not a part of QxOrm library, but you can copy-past it into your own project to use all its features :
           <ul>
           <li>access to <a href="./resource/qx_persistable_hpp.html" target="_blank"><i>QxPersistable.hpp</i></a> file ;</li>
           <li>access to <a href="./resource/qx_persistable_cpp.html" target="_blank"><i>QxPersistable.cpp</i></a> file.</li>
           </ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_455">Use PIMPL C++ pattern (Private Implementation idiom or d-pointer)</a></p>
         <div class="manual_div_content">
           <a href="https://en.cppreference.com/w/cpp/language/pimpl" target="_blank">From cppreference website :</a> "Pointer to implementation" or "pImpl" is a C++ programming technique that removes implementation details of a class from its object representation by placing them in a separate class, accessed through an opaque pointer.
           This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.
           <br><br>
           <a href="https://dzone.com/articles/the-pimpl-pattern-what-you-should-know" target="_blank">Advantages of PIMPL pattern</a> for C++ persistent classes registered into QxOrm context :
           <ul>
             <li><b>Compilation Firewall</b> : if the private implementation changes, the client code doesn't have to be recompiled ;</li>
             <li>Reduce <b>compilation times</b> : headers files (*.h, *.hpp) are smaller ;</li>
             <li><b>Binary Compatibility</b> : as long as the binary interface stays the same, you can link your app to a different version of a library ;</li>
             <li>Reduce the <b>size of generated binaries</b> (*.dll, *.so, *.exe, etc...).</li>
           </ul>
           <a href="https://www.geeksforgeeks.org/pimpl-idiom-in-c-with-examples/" target="_blank">Disadvantages of PIMPL</a> :
           <ul>
             <li>Performance : one level of indirection is added ;</li>
             <li>Memory Management : a memory chunk has to be allocated (or preallocated) for the private implementation (can issue <i>memory fragmentation</i>).</li>
           </ul>
           <br>
           QxOrm library provides a sample project where all persistent classes are developed using the PIMPL pattern : <a href="https://github.com/QxOrm/QxOrm/tree/master/test/qxBlogPImpl" target="_blank"><i>qxBlogPImpl</i> (with relationships)</a>.<br>
           <font style="background-color:yellow">It is also possible (and recommended) to use <a href="./manual_qxee.html#cpp_export_settings_parameters"><b>QxEntityEditor</b> application</a></font> to export automatically all C++ persistent classes of a project <b>with the PIMPL option</b>.<br>
           <br>
           Here is an example of a C++ class registered into QxOrm context developed with the PIMPL idiom (with <i>1-n</i>, <i>n-1</i> and <i>n-n</i> relationships) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_BLOG_H_
#define _QX_BLOG_BLOG_H_</span>

<span class="keyword">class</span> author;
<span class="keyword">class</span> comment;
<span class="keyword">class</span> category;

<span class="keyword">class</span> QX_BLOG_DLL_EXPORT blog
{

   QX_REGISTER_FRIEND_CLASS(blog)

<font style="background-color:yellow">private:

   <span class="keyword">struct</span> blog_impl;
   std::unique_ptr&lt;blog_impl&gt; m_pImpl; <span class="comment">//!&lt; Private implementation idiom</span></font>

<span class="keyword">public</span>:

   blog();
   virtual ~blog();

   <font style="background-color:yellow">blog(<span class="keyword">const</span> blog & other);
   blog & operator=(<span class="keyword">const</span> blog & other);

#ifdef Q_COMPILER_RVALUE_REFS
   blog(blog && other) Q_DECL_NOEXCEPT;
   blog & operator=(blog && other) Q_DECL_NOEXCEPT;
#endif <span class="comment">// Q_COMPILER_RVALUE_REFS</span></font>

   <span class="type">long</span> id() <span class="keyword">const</span>;
   <span class="type">QString</span> text() <span class="keyword">const</span>;
   <span class="type">QDateTime</span> dateCreation() <span class="keyword">const</span>;

   <span class="type">void</span> setId(long l);
   <span class="type">void</span> setText(<span class="keyword">const</span> QString & s);
   <span class="type">void</span> setDateCreation(<span class="keyword">const</span> QDateTime & d);

   std::shared_ptr&lt;author&gt; & getAuthor();
   QList&lt; std::shared_ptr&lt;comment&gt; &gt; & listOfComments();
   qx::QxCollection&lt;long, QSharedPointer&lt;category&gt; &gt; & listOfCategories();

};

QX_REGISTER_HPP_QX_BLOG(blog, qx::trait::no_base_class_defined, 0)

<span class="keyword">typedef</span> std::shared_ptr&lt;blog&gt; blog_ptr;
<span class="keyword">typedef</span> std::vector&lt;blog_ptr&gt; list_blog;

<span class="pre">#endif <span class="comment">// _QX_BLOG_BLOG_H_</span></span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include <span class="string">"../include/precompiled.h"</span>

#include <span class="string">"../include/blog.h"</span>
#include <span class="string">"../include/author.h"</span>
#include <span class="string">"../include/comment.h"</span>
#include <span class="string">"../include/category.h"</span>

#include <span class="string">&lt;QxOrm_Impl.h&gt;</span></span>

QX_REGISTER_CPP_QX_BLOG(blog)

<font style="background-color:yellow"><span class="keyword">struct</span> Q_DECL_HIDDEN blog::blog_impl
{
   <span class="type">long</span>           m_id;
   <span class="type">QString</span>        m_text;
   <span class="type">QDateTime</span>      m_dt_creation;
   author_ptr     m_author;
   list_comment   m_commentX;
   list_category  m_categoryX;

   blog_impl() : m_id(0) { ; }
   ~blog_impl() { ; }
};</font>

<span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> register_class(QxClass&lt;blog&gt; & t)
{
   <font style="background-color:yellow">IxDataMember * pImpl = t.pimpl(& blog::m_pImpl);</font>

   t.id(<font style="background-color:yellow">& blog::blog_impl::m_id</font>, <span class="string">"blog_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);

   t.data(<font style="background-color:yellow">& blog::blog_impl::m_text</font>, <span class="string">"blog_text"</span>, 0, true, true, <font style="background-color:yellow">pImpl</font>);
   t.data(<font style="background-color:yellow">& blog::blog_impl::m_dt_creation</font>, <span class="string">"date_creation"</span>, 0, true, true, <font style="background-color:yellow">pImpl</font>);

   t.relationManyToOne(<font style="background-color:yellow">& blog::blog_impl::m_author</font>, <span class="string">"author_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
   t.relationOneToMany(<font style="background-color:yellow">& blog::blog_impl::m_commentX</font>, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
   t.relationManyToMany(<font style="background-color:yellow">& blog::blog_impl::m_categoryX</font>, <span class="string">"list_category"</span>, <span class="string">"category_blog"</span>, <span class="string">"blog_id"</span>, <span class="string">"category_id"</span>, 0, <font style="background-color:yellow">pImpl</font>);
}}

blog::blog() : <font style="background-color:yellow">m_pImpl(new blog_impl())</font> { ; }

blog::~blog() { ; }

<font style="background-color:yellow">blog::blog(<span class="keyword">const</span> blog & other) : m_pImpl(new blog_impl(* other.m_pImpl)) { ; }

blog & blog::operator=(<span class="keyword">const</span> blog & other)
{
   if (this != (& other)) { (* m_pImpl) = (* other.m_pImpl); }
   <span class="keyword">return</span> (* this);
}

#ifdef Q_COMPILER_RVALUE_REFS
blog::blog(blog && other) Q_DECL_NOEXCEPT : m_pImpl(std::move(other.m_pImpl)) { ; }
blog & blog::operator=(blog && other) Q_DECL_NOEXCEPT { if (this != (& other)) { m_pImpl = std::move(other.m_pImpl); }; <span class="keyword">return</span> (* this); }
#endif <span class="comment">// Q_COMPILER_RVALUE_REFS</span></font>

<span class="type">long</span> blog::id() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_id</font>; }

<span class="type">QString</span> blog::text() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_text</font>; }

<span class="type">QDateTime</span> blog::dateCreation() <span class="keyword">const</span> { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_dt_creation</font>; }

<span class="keyword">void</span> blog::setId(<span class="type">long</span> l) { <font style="background-color:yellow">m_pImpl-&gt;m_id</font> = l; }

<span class="keyword">void</span> blog::setText(<span class="keyword">const</span> <span class="type">QString</span> & s) { <font style="background-color:yellow">m_pImpl-&gt;m_text</font> = s; }

<span class="keyword">void</span> blog::setDateCreation(<span class="keyword">const</span> <span class="type">QDateTime</span> & d) { <font style="background-color:yellow">m_pImpl-&gt;m_dt_creation</font> = d; }

std::shared_ptr&lt;author&gt; & blog::getAuthor() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_author</font>; }

QList&lt; std::shared_ptr&lt;comment&gt; &gt; & blog::listOfComments() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_commentX</font>; }

qx::QxCollection&lt;long, QSharedPointer&lt;category&gt; &gt; & blog::listOfCategories() { <span class="keyword">return</span> <font style="background-color:yellow">m_pImpl-&gt;m_categoryX</font>; }</pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_460">Persist custom type</a></p>
         <div class="manual_div_content">
           QxOrm library can persist every types, not only classes registered in QxOrm context using <i>qx::register_class&lt;T&gt;()</i>.<br>
           <br>
           It's necessary to write serialization functions from boost framework, using the <b>non intrusive</b> method (because source code is not available or is read-only).
           For more details on boost serialization module, <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">goto official website</a>.<br>
           <br>
           For example, imagine that you have the class '<i>ExtObject3D</i>' from an external library and the source code is not available or is read-only.
           Here is the code to can persist an instance of '<i>ExtObject3D</i>' type into database :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _PERSIST_EXTOBJECT3D_H_
#define _PERSIST_EXTOBJECT3D_H_

#include "ExtObject3D.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/serialization/split_free.hpp&gt;
#include &lt;boost/serialization/nvp.hpp&gt;
</span><span class="keyword"> 
namespace</span> boost<span class="operator"> {</span><span class="keyword">
namespace</span> serialization<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> save<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span><span class="keyword"> const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span>t<span class="operator">.</span>getX<span class="operator">()),</span> y<span class="operator">(</span>t<span class="operator">.</span>getY<span class="operator">()),</span> z<span class="operator">(</span>t<span class="operator">.</span>getZ<span class="operator">()),</span> angle<span class="operator">(</span>t<span class="operator">.</span>getAngle<span class="operator">());</span>

   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &lt;&lt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">class</span> Archive<span class="operator">&gt;</span><span class="type">
void</span> load<span class="operator">(</span>Archive<span class="operator"> &amp;</span> ar<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="type"> unsigned int</span> version<span class="operator">)
{</span>
   Q_UNUSED<span class="operator">(</span>version<span class="operator">);</span><span class="type">
   double</span> x<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> y<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> z<span class="operator">(</span><span class="float">0.0</span><span class="operator">),</span> angle<span class="operator">(</span><span class="float">0.0</span><span class="operator">);</span>

   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"x"</span><span class="operator">,</span> x<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"y"</span><span class="operator">,</span> y<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"z"</span><span class="operator">,</span> z<span class="operator">);</span>
   ar<span class="operator"> &gt;&gt;</span> boost<span class="operator">::</span>serialization<span class="operator">::</span>make_nvp<span class="operator">(</span><span class="string">"angle"</span><span class="operator">,</span> angle<span class="operator">);</span>

   t<span class="operator">.</span>setX<span class="operator">(</span>x<span class="operator">);</span>
   t<span class="operator">.</span>setY<span class="operator">(</span>y<span class="operator">);</span>
   t<span class="operator">.</span>setZ<span class="operator">(</span>z<span class="operator">);</span>
   t<span class="operator">.</span>setAngle<span class="operator">(</span>angle<span class="operator">);
}

}</span><span class="comment"> // namespace serialization
</span><span class="operator">}</span><span class="comment"> // namespace boost
</span> 
BOOST_SERIALIZATION_SPLIT_FREE<span class="operator">(</span>ExtObject3D<span class="operator">)</span><span class="pre">

#endif // _PERSIST_EXTOBJECT3D_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           Now you can persist an instance of '<i>ExtObject3D</i>' type into database : so you can have a '<i>ExtObject3D</i>' property in a persistent class registered in QxOrm context.
           This property can be mapped with a column of type <i>TEXT</i> or <i>VARCHAR</i> into database.<br>
           <br>
           The default behaviour of QxOrm library is : the instance is serialized to XML format before being inserted or updated into database.
           This default behaviour can be useful, for example if you want to save a collection of items without to make relation (so you don't have to manage another table into database).
           For example, with a property of type <i>std::vector&lt;mon_objet&gt;</i> in a persistent class without relation, the list of items will be saved into database under XML format.<br>
           <br>
           <b>Note :</b> the default behaviour can be easily modified for a specific type.
           <i>QtSql</i> engine uses <i>QVariant</i> type to link C++ code and database.
           <i>QVariant</i> type can contain text, numeric, binary, etc.
           So it can be interesting to specialize the default behaviour (XML serialization) if you want to save datas under binary format or to optimize your application (XML serialization is not very fast).
           You just have to write (with boost serialization functions) a conversion into/from <i>QVariant</i> type, for example with '<i>ExtObject3D</i>' class :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
namespace</span> cvt<span class="operator"> {</span><span class="keyword">
namespace</span> detail<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_ToVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> QVariant toVariant<span class="operator">(</span><span class="keyword">const</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Here I convert from ExtObject3D to QVariant */</span><span class="operator"> } };</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><span class="keyword"> struct</span> QxConvert_FromVariant<span class="operator">&lt;</span> ExtObject3D<span class="operator"> &gt; {</span><span class="keyword">
static inline</span> qx_bool fromVariant<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">,</span> ExtObject3D<span class="operator"> &amp;</span> t<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> format<span class="operator">,</span><span class="type"> int</span> index, qx::cvt::context::ctx_type ctx<span class="operator">)
{</span><span class="comment"> /* Here I convert from QVariant to ExtObject3D */</span><span class="operator">;</span><span class="flow"> return</span> qx_bool<span class="operator">(</span><span class="bool">true</span><span class="operator">); } };

}</span><span class="comment"> // namespace detail
</span><span class="operator">}</span><span class="comment"> // namespace cvt
</span><span class="operator">}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br><br>
           <b>Note :</b> here is a template to create a custom persistable type :
           <br><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _MY_CUSTOM_PERSISTABLE_TYPE_H_
#define _MY_CUSTOM_PERSISTABLE_TYPE_H_

#ifdef _MSC_VER
#pragma once
#endif

#include &lt;QxOrm.h&gt;</span>

<span class="keyword">class</span> MyPersistableType
{
   <span class="comment">/* What you want here */</span>
};

QX_REGISTER_CLASS_NAME(MyPersistableType)
QX_CLASS_VERSION(MyPersistableType, 0)

QDataStream & operator&lt;&lt; (QDataStream & stream, const MyPersistableType & t)
{
   <span class="comment">/* Your implementation here */</span>
}

QDataStream & operator&gt;&gt; (QDataStream & stream, MyPersistableType & t)
{
   <span class="comment">/* Your implementation here */</span>
}

<span class="keyword">namespace</span> qx {
<span class="keyword">namespace</span> cvt {
<span class="keyword">namespace</span> detail {

<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> QxConvert_ToVariant&lt; MyPersistableType &gt; {
<span class="keyword">static</span> <span class="keyword">inline</span> QVariant toVariant(const MyPersistableType & t, const QString & format, int index, qx::cvt::context::ctx_type ctx)
{
   <span class="comment">/* Here I convert from MyPersistableType to QVariant */</span>
} };

<span class="keyword">template</span> <> <span class="keyword">struct</span> QxConvert_FromVariant&lt; MyPersistableType &gt; {
<span class="keyword">static</span> <span class="keyword">inline</span> qx_bool fromVariant(const QVariant & v, MyPersistableType & t, const QString & format, int index, qx::cvt::context::ctx_type ctx)
{
   <span class="comment">/* Here I convert from QVariant to MyPersistableType */</span>
   return qx_bool(true);
} };

} <span class="comment">// namespace detail</span>
} <span class="comment">// namespace cvt</span>
} <span class="comment">// namespace qx</span>

<span class="keyword">#ifndef</span> _QX_NO_JSON

<span class="keyword">namespace</span> qx {
<span class="keyword">namespace</span> cvt {
<span class="keyword">namespace</span> detail {

<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct</span> QxConvert_ToJson&lt; MyPersistableType &gt;
{
   <span class="keyword">static inline</span> QJsonValue toJson(const MyPersistableType & t, const QString & format)
   {
      <span class="comment">/* Your implementation here */</span>
   }
};

<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct</span> QxConvert_FromJson&lt; MyPersistableType &gt;
{
   <span class="keyword">static inline</span> qx_bool fromJson(const QJsonValue & j, MyPersistableType & t, const QString & format)
   {
      <span class="comment">/* Your implementation here */</span>
   }
};

} <span class="comment">// namespace detail</span>
} <span class="comment">// namespace cvt</span>
} <span class="comment">// namespace qx</span>

<span class="keyword">#endif</span> <span class="comment">// _QX_NO_JSON</span>

<span class="comment">// ------------------------------------</span>
<span class="comment">// If you are using boost serialization, you have also to implement save/load functions like above 'ExtObject3D' example</span>
<span class="comment">// ------------------------------------</span>

<span class="keyword">#endif</span> <span class="comment">// _MY_CUSTOM_PERSISTABLE_TYPE_H_</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_470">Generate database DDL SQL schema</a></p>
         <div class="manual_div_content">
           <a href="#manual_110"><b><font style="background-color:yellow">!!! It's strongly recommended to use <b>QxEntityEditor</b> application to manage DDL SQL schema generation !!!</font></b></a><br>
           <br>
           QxOrm library doesn't provide a generator to create and to update automatically tables into database.<br>
           Indeed, <i>qx::dao::create_table&lt;T&gt;</i> function must be used only to create prototypes or samples.<br>
           It's strongly recommended to work with a tool provided by each SGBD to design and to manage tables into database (for example <i>Navicat</i> with <i>MySql</i>, <i>pgAdmin</i> with <i>PostgreSQL</i>, <i>SQLite Manager</i> with <i>SQLite</i>, etc.).<br>
           Moreover, each tool provided by each SGBD can add some optimizations to the database (add some indexes for example).<br>
           <br>
           But sometimes, it can be useful to not have to manage manually tables into database.<br>
           In this case, it's possible to create a C++ function to iterate over all persistents classes registered in QxOrm context (using introspection engine of QxOrm library) : so you can build a SQL script to create and to update tables into database.<br>
           <br>
           QxOrm library provides an example of a C++ function : based on this function, you can create your own function to build SQL schema.<br>
           This QxOrm function is written in the file <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">./src/QxRegister/QxClassX.cpp</a></i> and is called <i><a href="./resource/qxclassx_dump_sql_schema.html" target="_blank">QString qx::QxClassX::dumpSqlSchema()</a></i>.<br>
           This QxOrm function builds a SQL script and returns a <i>QString</i> value : it's also possible to modify the function to generate a file with SQL script or to execute each SQL process directly to the SGBD.<br>
           <br>
           Here is a sample implementation provided by <a href="http://www.developpez.net/forums/u449556/dodobibi/" target="_blank">dodobibi</a> to manage a <i>PostgreSQL</i> database : this sample works with a version number to add columns to existing tables, to add some indexes to existing columns, etc.<br>
           When you start your application, a version number is provided and incremented when a new version of your application is released :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QApplication app<span class="operator">(</span>argc<span class="operator">,</span> argv<span class="operator">);</span>
app<span class="operator">.</span>setProperty<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span><span class="comment"></span></pre>
           </td></tr></tbody></table>
           <br>
           A table into the database must be created to store this version number.<br>
           A C++ persistent class is mapped to this table :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _DATABASE_VERSION_H_
#define _DATABASE_VERSION_H_
</span><span class="keyword"> 
class</span> MY_DLL_EXPORT DatabaseVersion<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span>
  QString name<span class="operator">;</span><span class="type">
  long</span> version<span class="operator">;
};</span>

QX_REGISTER_HPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _DATABASE_VERSION_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "../include/precompiled.h"
#include "../include/DatabaseVersion.h"
#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_MY_APP<span class="operator">(</span>DatabaseVersion<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>DatabaseVersion<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>name<span class="operator">,</span><span class="string"> "name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> DatabaseVersion<span class="operator">::</span>version<span class="operator">,</span><span class="string"> "version"</span><span class="operator">);
}}</span></pre>
           </td></tr></tbody></table>
           <br>
           With <i>DatabaseVersion</i> class, it's possible to verify that the database must be updated or not.<br>
           This is the goal of <i>isDatabaseVersionOld()</i> function :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">bool</span> isDatabaseVersionOld<span class="operator">()
{</span>
  DatabaseVersion dbVersion<span class="operator">;</span>
  dbVersion<span class="operator">.</span>name<span class="operator"> =</span><span class="string"> "MyAppName"</span><span class="operator">;</span>
  QSqlError err<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="flow">
  if</span><span class="operator"> (</span>err<span class="operator">.</span>isValid<span class="operator">()) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="bool"> false</span><span class="operator">; }</span><span class="flow">
  return</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &lt;</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">());
}</span></pre>
           </td></tr></tbody></table>
           <br>
           If <i>isDatabaseVersionOld()</i> function returns <i>true</i> when you start your application, then you must update your SQL schema :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">void</span> updateDatabaseVersion<span class="operator">()
{</span><span class="flow">
  try</span><span class="operator">
  {</span><span class="type">
    int</span> domainVersion<span class="operator"> =</span> qApp<span class="operator">-&gt;</span>property<span class="operator">(</span><span class="string">"DomainVersion"</span><span class="operator">).</span>toInt<span class="operator">();</span><span class="comment">

    // Connect to the database with a user with modifications rights on SQL schema
</span>    QSqlDatabase db<span class="operator"> =</span> qx<span class="operator">::</span>QxSqlDatabase<span class="operator">::</span>getSingleton<span class="operator">()-&gt;</span>getDatabaseCloned<span class="operator">();</span>
    db<span class="operator">.</span>setUserName<span class="operator">(</span><span class="string">"MyAdminLogin"</span><span class="operator">);</span>
    db<span class="operator">.</span>setPassword<span class="operator">(</span><span class="string">"MyAdminPassword"</span><span class="operator">);</span><span class="comment">

    // Create a session, open automatically a transaction and throw an exception when an error occured
</span>    qx<span class="operator">::</span>QxSession session<span class="operator">(</span>db<span class="operator">,</span><span class="bool"> true</span><span class="operator">,</span><span class="bool"> true</span><span class="operator">);</span><span class="comment">

    // Fetch the database version with a lock to protect the database
</span>    DatabaseVersion dbVersion<span class="operator">;</span>
    session<span class="operator">.</span>fetchByQuery<span class="operator">(</span>qx_query<span class="operator">(</span><span class="string">"WHERE name='MyAppName' FOR UPDATE"</span><span class="operator">),</span> dbVersion<span class="operator">);</span><span class="comment">

    // When unlocked for other users, verify that the database must be updated or not
</span><span class="flow">    if</span><span class="operator"> (</span>dbVersion<span class="operator">.</span>version<span class="operator"> &gt;=</span> domainVersion<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // Execute each SQL process with "query" variable
</span>    QSqlQuery query<span class="operator">(</span>db<span class="operator">);</span><span class="comment">

    // Fetch all C++ persistents classes registered in QxOrm context
</span>    qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> qx<span class="operator">::</span>IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
    if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

    // Fetch all tables into database (this is a Qt function)
</span>    QStringList tables<span class="operator"> =</span> db<span class="operator">.</span>tables<span class="operator">();</span><span class="flow">

    for</span><span class="operator"> (</span><span class="type">long</span> k<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> k<span class="operator"> &lt;</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span> k<span class="operator">++)
    {</span>
      qx<span class="operator">::</span>IxClass<span class="operator"> *</span> pClass<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>getByIndex<span class="operator">(</span>k<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (!</span> pClass<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filter non persitents classes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxParameter"</span><span class="operator">) ||</span> pClass<span class="operator">-&gt;</span>isKindOf<span class="operator">(</span><span class="string">"qx::service::IxService"</span><span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // Filter already updated classes
</span><span class="flow">      if</span><span class="operator"> (</span>pClass<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span><span class="comment">

      // If table doesn't exist, create it and set the owner
</span><span class="flow">      if</span><span class="operator"> (!</span> tables<span class="operator">.</span>contains<span class="operator">(</span>pClass<span class="operator">-&gt;</span>getName<span class="operator">()))
      {</span>
        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ( ) WITH (OIDS = FALSE);"
                   "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " OWNER TO \"MyAdminLogin\";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
      }</span><span class="comment">

      // If a column doesn't exist, add it to the table
</span>      qx<span class="operator">::</span>IxDataMemberX<span class="operator"> *</span> pDataMemberX<span class="operator"> =</span> pClass<span class="operator">-&gt;</span>getDataMemberX<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">; (</span>pDataMemberX<span class="operator"> &amp;&amp; (</span>l<span class="operator"> &lt;</span> pDataMemberX<span class="operator">-&gt;</span>count_WithDaoStrategy<span class="operator">()));</span> l<span class="operator">++)
      {</span>
        qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> pDataMemberX<span class="operator">-&gt;</span>get_WithDaoStrategy<span class="operator">(</span>l<span class="operator">);</span><span class="flow">
        if</span><span class="operator"> (!</span> p<span class="operator"> || (</span>p<span class="operator">-&gt;</span>getVersion<span class="operator">() &lt;=</span> dbVersion<span class="operator">.</span>version<span class="operator">)) {</span><span class="flow"> continue</span><span class="operator">; }</span>

        query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getSqlType<span class="operator">() +</span><span class="string"> ";"</span><span class="operator">);</span>
        session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getIsPrimaryKey<span class="operator">())</span><span class="comment"> // PRIMARY KEY
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ADD PRIMARY KEY ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAllPropertyBagKeys<span class="operator">().</span>contains<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">))</span><span class="comment"> // INDEX
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE INDEX "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_idx"</span><span class="operator"> +</span><span class="string"> 
                     " ON "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " USING "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getPropertyBag<span class="operator">(</span><span class="string">"INDEX"</span><span class="operator">).</span>toString<span class="operator">() +</span><span class="string"> " ("</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> ");"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getNotNull<span class="operator">())</span><span class="comment"> // NOT NULL
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " SET NOT NULL;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getAutoIncrement<span class="operator">())</span><span class="comment"> // AUTO INCREMENT
</span><span class="operator">        {</span>
          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"CREATE SEQUENCE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> " OWNER TO \"MyAdminLogin\"; "
                     "ALTER TABLE "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " ALTER COLUMN "</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " "</span><span class="operator"> +</span><span class="string">
                     "SET DEFAULT nextval('"</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "_seq"</span><span class="operator"> +</span><span class="string"> "'::regclass);"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }</span><span class="flow">

        if</span><span class="operator"> (</span>p<span class="operator">-&gt;</span>getDescription<span class="operator">() !=</span><span class="string"> ""</span><span class="operator">)</span><span class="comment"> // DESCRIPTION
</span><span class="operator">        {</span>          query<span class="operator">.</span>exec<span class="operator">(</span><span class="string">"COMMENT ON COLUMN "</span><span class="operator"> +</span> pClass<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> "."</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getName<span class="operator">() +</span><span class="string"> " IS $$"</span><span class="operator"> +</span> p<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span><span class="string"> "$$ ;"</span><span class="operator">);</span>
          session<span class="operator"> +=</span> query<span class="operator">.</span>lastError<span class="operator">();
        }
      }
    }</span><span class="comment">

    // Save current version of the database
</span>    dbVersion<span class="operator">.</span>version<span class="operator"> =</span> domainVersion<span class="operator">;</span>
    session<span class="operator">.</span>save<span class="operator">(</span>dbVersion<span class="operator">);</span><span class="comment">

    // End of "try" scope : session is destroyed =&gt; commit or rollback automatically
    // Moreover, a commit or a rollback unlock the process for all users
</span><span class="operator">  }</span><span class="flow">
  catch</span><span class="operator"> (</span><span class="keyword">const</span> qx<span class="operator">::</span>dao<span class="operator">::</span>sql_error<span class="operator"> &amp;</span> err<span class="operator">)
  {</span>
    QSqlError sqlError<span class="operator"> =</span> err<span class="operator">.</span>get<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>databaseText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>driverText<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>number<span class="operator">();</span>
    qDebug<span class="operator">() &lt;&lt;</span> sqlError<span class="operator">.</span>type<span class="operator">();
  }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> this code (like <a href="./resource/qxclassx_dump_sql_schema.html" target="_blank"><i>qx::QxClassX::dumpSqlSchema()</i></a> function) can be modified to provide more features.<br>
           For example, it could be interesting to create by default another table (like <i>DatabaseVersion</i> table) to store the list of all persistents classes registered in QxOrm context : instead of using "<i>db.tables()</i>" Qt function, it could be possible to fetch all tables with more information (version number for each table, columns count registered in QxOrm context, table description, etc.).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_475">Associate a SQL type to a C++ class</a></p>
         <div class="manual_div_content">
           Each database provides its own SQL types to store datas.<br>
           QxOrm library associates by default some C++ classes frequently used in a program :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="string">"bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"qx_bool"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"float"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"long double"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "FLOAT"
"unsigned short"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "SMALLINT"
"unsigned int"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"unsigned long long"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "INTEGER"
"std::string"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"std::wstring"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QString"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QVariant"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QUuid"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"QDate"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "DATE"
"QTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIME"
"QDateTime"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TIMESTAMP"
"QByteArray"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "BLOB"
"qx::QxDateNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"
"qx::QxDateTimeNeutral"</span><span class="operator"> &lt;-&gt;</span><span class="string"> "TEXT"</span></pre>
           </td></tr></tbody></table>
           <br>
           If a SQL type provided by default by QxOrm library is not supported by the database, it can be easily modified (globally for all the application) using the following collection :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QHash<span class="operator">&lt;</span>QString<span class="operator">,</span> QString<span class="operator">&gt; *</span> lstSqlType<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getAllSqlTypeByClassName<span class="operator">();</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"QString"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span>
lstSqlType<span class="operator">-&gt;</span>insert<span class="operator">(</span><span class="string">"std::string"</span><span class="operator">,</span><span class="string"> "VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
// etc.</span></pre>
           </td></tr></tbody></table>
           <br>
           To modify a SQL type for a specific column of a table, you have to define the new SQL type in the mapping function of QxOrm library :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>MyClass<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span><span class="comment">
  //...
</span>  IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span>  t<span class="operator">.</span>data<span class="operator">(&amp;</span> MyClass<span class="operator">::</span>m_MyProperty<span class="operator">,</span><span class="string"> "my_property"</span><span class="operator">);</span>
  p<span class="operator">-&gt;</span>setSqlType<span class="operator">(</span><span class="string">"VARCHAR(255)"</span><span class="operator">);</span><span class="comment">
  //...
</span><span class="operator">}}</span></pre>
           </td></tr></tbody></table>
           <br>
           For all classes not supported by default by QxOrm library (read chapter : <i><a href="#manual_460">Persist custom type</a></i>), it's possible to associate a default SQL type using the following macro (outside all <i>namespace</i>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_TRAIT_GET_SQL_TYPE<span class="operator">(</span>MyClass<span class="operator">,</span><span class="string"> "my_sql_type"</span><span class="operator">)</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_480">Async database queries</a></p>
         <div class="manual_div_content">
           Sometimes, it's necessary to execute some queries to database in asynchronous way (multi-thread), for example to avoid to freeze a GUI if a query is too long to execute.<br>
           To make easier to work with asynchronous queries, QxOrm library provides <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i> class.<br>
           This class executes a query in another thread and returns the <i>queryFinished()</i> <i>SIGNAL</i> when query is terminated.<br>
           To use <i><a href="../doxygen/html/classqx_1_1_qx_dao_async.html" target="_blank">qx::QxDaoAsync</a></i> class, you just have to :
           <ul>
           <li>be careful to work only with classes implementing <i><a href="../doxygen/html/classqx_1_1_ix_persistable.html" target="_blank">qx::IxPersistable</a></i> interface ;</li>
           <li>create an instance of <i>qx::QxDaoAsync</i> type (for example, a property of a <i>QWidget</i> derived class) ;</li>
           <li>connect a <i>SLOT</i> to the <i>qx::QxDaoAsync::queryFinished()</i> <i>SIGNAL</i> (for example, a <i>SLOT</i> of a <i>QWidget</i> derived class) ;</li>
           <li>run a query using one of <i>qx::QxDaoAsync::asyncXXXX()</i> methods.</li>
           </ul>
           Here is an example with a class called <i>MyWidget</i> :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MyWidget<span class="operator"> :</span><span class="keyword"> public</span> QWidget<span class="operator">
{</span> Q_OBJECT<span class="comment">

   //...
</span>   qx<span class="operator">::</span>QxDaoAsync m_daoAsync<span class="operator">;</span><span class="comment">
   //...
</span>Q_SLOTS<span class="operator">:</span><span class="type">
   void</span> onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">);</span><span class="comment">
   //...

</span><span class="operator">};</span></pre>
           </td></tr></tbody></table>
           <br>
           And here is the implementation of <i>MyWidget</i> class :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>MyWidget<span class="operator">::</span>MyWidget<span class="operator">() :</span> QObject<span class="operator">()
{</span><span class="comment">
   //...
</span>   QObject<span class="operator">::</span>connect<span class="operator">((&amp;</span> m_daoAsync<span class="operator">),</span> SIGNAL<span class="operator">(</span>queryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)),</span><span class="keyword"> 
                    this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr<span class="operator">)));</span><span class="comment">
   //...
</span><span class="operator">}</span><span class="type">

void</span> MyWidget<span class="operator">::</span>onQueryFinished<span class="operator">(</span><span class="keyword">const</span> QSqlError<span class="operator"> &amp;</span> daoError<span class="operator">,</span> qx<span class="operator">::</span>dao<span class="operator">::</span>detail<span class="operator">::</span>QxDaoAsyncParams_ptr pDaoParams<span class="operator">)
{</span><span class="flow">
   if</span><span class="operator"> (!</span> pDaoParams<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>
   qx<span class="operator">::</span>QxSqlQuery query<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>query<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (!</span> daoError<span class="operator">.</span>isValid<span class="operator">()) { ; }</span><span class="comment">
   // If the async query is associated to a simple object, just use 'pDaoParams-&gt;pInstance' method
</span>   qx<span class="operator">::</span>IxPersistable_ptr ptr<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pInstance<span class="operator">;</span><span class="comment">
   // If the async query is associated to a list of objects, just use 'pDaoParams-&gt;pListOfInstances' method
</span>   qx<span class="operator">::</span>IxPersistableCollection_ptr lst<span class="operator"> =</span> pDaoParams<span class="operator">-&gt;</span>pListOfInstances<span class="operator">;</span><span class="comment">
   //...
</span><span class="operator">}</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_490">Cache to store C++ instances (QxCache module)</a></p>
         <div class="manual_div_content">
           Cache engine provided by QxOrm library (<a href="../doxygen/html/group___qx_cache.html" target="_blank"><i>QxCache</i> module</a>) is <i>thread-safe</i> and can store easily any kind of objects.<br>
           Functions to access to the cache engine are inside <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>.<br>
           <i>qx::cache</i> engine can provide a program optimization : you can for example store items fetched by a query to database.<br>
           <br>
           Each item into the cache is associated with a key of type <i>QString</i> : this key provides a quick access to an item stored into the cache.<br>
           If a new item is inserted with a key already in the cache, then the old item associated with this key is removed automatically from the cache.<br>
           <br>
           Cache engine of QxOrm library doesn't manage memory : there is no <i>delete</i> called by the cache engine.<br>
           This is why it's strongly recommended (but not an obligation) to store smart-pointers into the cache : for example, <a href="http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm" target="_blank"><i>boost::shared_ptr&lt;T&gt;</i></a> of <i>boost</i> library or <a href="http://doc-snapshots.qt.io/4.8/qsharedpointer.html" target="_blank"><i>QSharedPointer&lt;T&gt;</i></a> of <i>Qt</i> library.<br>
           <br>
           Cache engine can have a max cost to avoid too much memory usage : each item inserted to the cache can be associated with a cost (for example, element's count of a collection).<br>
           When the limit (max cost) of the cache engine is reached, first items inserted to the cache are automatically removed (insertion order) until limit of the cache is ok.<br>
           <br>
           It's also possible to associate a date-time insertion when an item is added to the cache.<br>
           If there is no date-time, then the current date-time is taken into account.<br>
           This feature provides a way to verify that an item stored into the cache must be updated or not.<br>
           <br>
           Here is an example using cache engine of QxOrm library (functions into <a href="../doxygen/html/namespaceqx_1_1cache.html" target="_blank"><i>namespace</i> <i>qx::cache</i></a>) :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Define max cost of cache engine to 500
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>max_cost<span class="operator">(</span><span class="int">500</span><span class="operator">);</span><span class="comment">

// Fetch a list of 'author' from database
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span> QList<span class="operator">&lt;</span>author<span class="operator">&gt; &gt;</span> list_author<span class="operator">;</span>
QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_author<span class="operator">);</span><span class="comment">

// Insert the list of 'author' to the cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">,</span> list_author<span class="operator">);</span><span class="comment">

// Fetch a list of 'blog' from database
</span>QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt;</span> list_blog<span class="operator">;</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_blog<span class="operator">);</span><span class="comment">

// Insert the list of 'blog' to the cache (cost = 'blog' count)
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">,</span> list_blog<span class="operator">.</span>count<span class="operator">());</span><span class="comment">

// Pointer to an object of type 'comment'
</span>comment_ptr my_comment<span class="operator">;</span>
my_comment<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> comment<span class="operator">(</span><span class="int">50</span><span class="operator">));</span>
daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>my_comment<span class="operator">);</span><span class="comment">

// Insert 'comment' to the cache with a date-time insertion
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>set<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span><span class="int"> 1</span><span class="operator">,</span> my_comment<span class="operator">-&gt;</span>dateModif<span class="operator">());</span><span class="comment">

// Get the list of 'blog' stored into the cache
</span>list_blog<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">&lt;</span> QSharedPointer<span class="operator">&lt;</span> std<span class="operator">::</span>vector<span class="operator">&lt;</span>blog<span class="operator">&gt; &gt; &gt;(</span><span class="string">"list_blog"</span><span class="operator">);</span><span class="comment">

// Get the list of 'blog' without providing the type
</span>qx_bool bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"list_blog"</span><span class="operator">,</span> list_blog<span class="operator">);</span><span class="comment">

// Remove list of 'author' from cache
</span><span class="type">bool</span> bRemoveOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>remove<span class="operator">(</span><span class="string">"list_author"</span><span class="operator">);</span><span class="comment">

// Get items count stored into the cache
</span><span class="type">long</span> lCount<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>count<span class="operator">();</span><span class="comment">

// Get current cost of items stored into the cache
</span><span class="type">long</span> lCurrentCost<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>current_cost<span class="operator">();</span><span class="comment">

// Verify that an element with the key "comment" exists into the cache
</span><span class="type">bool</span> bExist<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>exist<span class="operator">(</span><span class="string">"comment"</span><span class="operator">);</span><span class="comment">

// Get 'comment' stored into the cache with its date-time insertion
</span>QDateTime dt<span class="operator">;</span>
bGetOk<span class="operator"> =</span> qx<span class="operator">::</span>cache<span class="operator">::</span>get<span class="operator">(</span><span class="string">"comment"</span><span class="operator">,</span> my_comment<span class="operator">,</span> dt<span class="operator">);</span><span class="comment">

// Clear the cache
</span>qx<span class="operator">::</span>cache<span class="operator">::</span>clear<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_500">Working with several databases</a></p>
         <div class="manual_div_content">
            In the <a href="#manual_310">Connection to database</a> chapter, we have seen how to configure default connection to database using singleton class : <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a>.
            QxOrm library is based on Qt <a href="http://doc.qt.io/qt-5/sql-programming.html" target="_blank">QtSql</a> engine, so QxOrm uses internally the Qt <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank">QSqlDatabase</a> class.
            All functions to communicate with databases (<a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao</a> namespace, <a href="../doxygen/html/classqx_1_1_qx_session.html" target="_blank">qx::QxSession</a> class, etc...) have an optional parameter named : <b><i>QSqlDatabase * pDatabase = NULL</i></b> :
            <ul>
               <li>if value of this parameter is NULL (which is the default value) : then QxOrm library uses <a href="../doxygen/html/classqx_1_1_qx_sql_database.html" target="_blank">qx::QxSqlDatabase</a> settings to connect to database (support multi-threading) ;</li>
               <li>if value is not NULL : then QxOrm library uses connection provided by this <a href="http://doc.qt.io/qt-5/qsqldatabase.html" target="_blank"><i>QSqlDatabase * pDatabase</i></a> pointer.</li>
            </ul>
            So this optional parameter can be used to manage your own connection pool and/or to connect to several databases.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_510">Register an abstract class in QxOrm context</a></p>
         <div class="manual_div_content">
           A C++ abstract class (with at least one pure virtual method) cannot be mapped to a database table (because it cannot be instantiated).<br>
           However, in some cases, it can be interesting to define properties into abstract class used by a persistent object (by inheritance).<br>
           A sample of abstract class registered in QxOrm context is available in <i>./test/qxDllSample/dll2/</i> directory of QxOrm package with <i>BaseClassTrigger</i> class.<br>
           To register an abstract class in QxOrm context, you have to :
           <ul>
           <li>register the class with '<i>void register_class</i>' like any other class ;
           </li><li>use <b>QX_REGISTER_ABSTRACT_CLASS(className)</b> macro just after the class definition.
           </li></ul>
           <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_520">Register automatically Qt meta-properties (<i>Q_PROPERTY</i> macro)</a></p>
         <div class="manual_div_content">
           All classes inherited from <i>QObject</i> type can use <i><a href="http://doc-snapshots.qt.io/4.8/properties.html" target="_blank">Q_PROPERTY</a></i> macro : these properties become meta-properties.
           This is how Qt framework provides an introspection engine using the <i>moc</i> process.
           Meta-properties can be used for example by <i>QML</i> engine, <i>QtScript</i>, etc.<br>
           <br>
           <b>QxOrm</b> library requires to register all properties per class in the <i>void qx::register_class&lt;T&gt;()</i> mapping function to provide all features (persistence, XML, JSON and binary serialization, etc.).
           It's possible to register automatically all Qt meta-properties in QxOrm context without having to manage any mapping function per class <i>void qx::register_class&lt;T&gt;()</i> : <b>QX_REGISTER_ALL_QT_PROPERTIES()</b> macro works with Qt introspection engine to iterate over all meta-properties.<br>
           <br>
           Here is an example with <i>TestQtProperty</i> class in <i>./test/qxDllSample/dll1/include/</i> directory of QxOrm package :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.h">
<pre><span class="pre">#ifndef _QX_TEST_QT_META_PROPERTY_H_
#define _QX_TEST_QT_META_PROPERTY_H_
</span><span class="keyword"> 
class</span> QX_DLL1_EXPORT TestQtProperty<span class="operator"> :</span><span class="keyword"> public</span> QObject<span class="operator">
{</span>

   Q_OBJECT
   <font style="background-color:yellow">Q_PROPERTY<span class="operator">(</span><span class="type">int</span> id READ id WRITE setId<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span><span class="type">long</span> number READ number WRITE setNumber<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QString desc READ desc WRITE setDesc<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QDateTime birthDate READ birthDate WRITE setBirthDate<span class="operator">)</span>
   Q_PROPERTY<span class="operator">(</span>QVariant photo READ photo WRITE setPhoto<span class="operator">)</span></font><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   int</span>         m_id<span class="operator">;</span><span class="type">
   long</span>        m_number<span class="operator">;</span>
   QString     m_desc<span class="operator">;</span>
   QDateTime   m_birthDate<span class="operator">;</span>
   QVariant    m_photo<span class="operator">;</span><span class="keyword">

public</span><span class="operator">:</span>

   TestQtProperty<span class="operator">() :</span> QObject<span class="operator">(),</span> m_id<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> m_number<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>TestQtProperty<span class="operator">() { ; }</span><span class="type">

   int</span> id<span class="operator">()</span><span class="keyword"> const</span><span class="operator">                {</span><span class="flow"> return</span> m_id<span class="operator">; }</span><span class="type">
   long</span> number<span class="operator">()</span><span class="keyword"> const</span><span class="operator">           {</span><span class="flow"> return</span> m_number<span class="operator">; }</span>
   QString desc<span class="operator">()</span><span class="keyword"> const</span><span class="operator">          {</span><span class="flow"> return</span> m_desc<span class="operator">; }</span>
   QDateTime birthDate<span class="operator">()</span><span class="keyword"> const</span><span class="operator">   {</span><span class="flow"> return</span> m_birthDate<span class="operator">; }</span>
   QVariant photo<span class="operator">()</span><span class="keyword"> const</span><span class="operator">        {</span><span class="flow"> return</span> m_photo<span class="operator">; }</span><span class="type">

   void</span> setId<span class="operator">(</span><span class="type">int</span> i<span class="operator">)                         {</span> m_id<span class="operator"> =</span> i<span class="operator">; }</span><span class="type">
   void</span> setNumber<span class="operator">(</span><span class="type">long</span> l<span class="operator">)                    {</span> m_number<span class="operator"> =</span> l<span class="operator">; }</span><span class="type">
   void</span> setDesc<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> s<span class="operator">)           {</span> m_desc<span class="operator"> =</span> s<span class="operator">; }</span><span class="type">
   void</span> setBirthDate<span class="operator">(</span><span class="keyword">const</span> QDateTime<span class="operator"> &amp;</span> dt<span class="operator">)   {</span> m_birthDate<span class="operator"> =</span> dt<span class="operator">; }</span><span class="type">
   void</span> setPhoto<span class="operator">(</span><span class="keyword">const</span> QVariant<span class="operator"> &amp;</span> v<span class="operator">)         {</span> m_photo<span class="operator"> =</span> v<span class="operator">; }
 
};</span>

QX_REGISTER_HPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">,</span> QObject<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _QX_TEST_QT_META_PROPERTY_H_</span></pre>
           </td></tr></tbody></table>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="TestQtProperty.cpp">
<pre><span class="pre">#include "../include/precompiled.h"

#include "../include/TestQtProperty.h"

#include &lt;QxOrm_Impl.h&gt;
</span> 
QX_REGISTER_CPP_QX_DLL1<span class="operator">(</span>TestQtProperty<span class="operator">)</span>
<font style="background-color:yellow">QX_REGISTER_ALL_QT_PROPERTIES<span class="operator">(</span>TestQtProperty<span class="operator">,</span><span class="string"> "id"</span><span class="operator">)</span></font></pre>
           </td></tr></tbody></table>
           <br>
           If you don't want to use <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro, you can write 4 lines of code :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span> <font style="background-color:yellow">qx<span class="operator">::</span>register_all_qt_properties<span class="operator">&lt;</span>TestQtProperty<span class="operator">&gt;(</span>t<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span></font> <span class="operator">}
}</span><span class="comment"> // namespace qx</span></pre>
           </td></tr></tbody></table>
           <br>
           <b>Note :</b> the second parameter of <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro is the name of the property mapped to the primary key into database.
           If this parameter is empty, then the class doesn't have any primary key or the primary key has been registered in a base class.<br>
           <br>
           All properties defined with <i>Q_PROPERTY</i> macro can be registered in QxOrm context in two different ways :<br>
           <b>1-</b> with the classic method : <i>t.data(& MyQObject::my_property, "my_property", 0);</i><br>
           <b>2-</b> or without writing the data-member pointer : <i>t.data("my_property", 0);</i><br>
           <br>
           You can use the first or the second method to register your properties in QxOrm context and access to the same functionalities using the common interface <i><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a></i>.
           You can also mix Qt meta-properties and classic registration data-member into the same mapping function <i>void qx::register_class&lt;T&gt;()</i>.
           Each registration method has some advantages and disadvantages.<br>
           <br>
           Here is the list of advantages using the second registration method in QxOrm context :
           <ul>
             <li>much more faster to compile ;</li>
             <li>reduce exec size ;</li>
             <li>strong integration with Qt introspection/<i>moc</i> engine ;</li>
             <li>no need to manage any mapping function per class using <i>QX_REGISTER_ALL_QT_PROPERTIES</i> macro.</li>
           </ul>
           Here is the list of disadvantages compared to the classic registration method :
           <ul>
             <li>need to inherit from <i>QObject</i> class to use <i>Q_PROPERTY</i> macro ;</li>
             <li>program execution more slower (<i>QVariant</i> type versus C++ <i>template</i>) ;</li>
             <li>doesn't support relationship between tables into database (<i>one-to-one</i>, <i>one-to-many</i>, <i>many-to-one</i> and <i>many-to-many</i>) ;</li>
             <li>cannot access to the data-member pointer of a class (need to convert to <i>QVariant</i> type before to access or to modify a value).</li>
           </ul>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_60">Serialization</a></p>
      <div class="manual_div_content_1">
         <a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">From Wikipedia web page :</a> <b>serialization</b> is the process of translating data structures or object state into a format that can be stored (for example, in a file or memory buffer, or transmitted across a network connection link) and reconstructed later in the same or another computer environment.
         When the resulting series of bits is reread according to the serialization format, it can be used to create a semantically identical clone of the original object.
         The opposite operation, extracting a data structure from a series of bytes, is named <b>deserialization</b>.
         <br><br>
         Each C++ class registered in QxOrm context can be serialized in several ways :
         <ul>
            <li><a href="#manual_600">binary format of Qt QDataStream engine</a> ;</li>
            <li><a href="#manual_606">JSON format with Qt QJson engine</a> ;</li>
            <li><a href="#manual_610">XML format with boost::serialization engine</a> ;</li>
            <li><a href="#manual_620">binary format with boost::serialization engine</a> ;</li>
            <li><a href="#manual_630">other formats provided by boost::serialization engine</a>.</li>
         </ul>
         <b>Note :</b> serialization engine of QxOrm library provides extra features like : <a href="#manual_640">clone entity</a>, <a href="#manual_650">dump entity</a> (XML or JSON format) and <a href="#manual_80">QxService module</a>.
         <br><br>
         <b>Other note :</b> by default, all properties registered in QxOrm context are serializable. To remove a property from the serialization engine, you can write :<br>
         <br>
         <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>age<span class="operator">,</span><span class="string"> "age"</span><span class="operator">);</span>
  <font style="background-color:yellow">pDataMember<span class="operator">-&gt;</span>setSerialize<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span></font>
<span class="operator">}}</span></pre>
         </td></tr></tbody></table>
         <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_605">Version number to manage ascendant compatibility</a></p>
         <div class="manual_div_content">
            Ascendant compatibility allows deserialization process (so restore a data structure) from a stream generated by a previous version of an application.
            QxOrm library requires a version number per class and a version number for each property registered in QxOrm context to provide ascendant compatibility.
            <br><br>
            For example, imagine a <i>person</i> class created in <b>a version A of your application</b> : we put in <i>QX_REGISTER_HPP</i> macro a class version equals to 0 (means first version of our <i>person</i> class), and each property class have also a version equals to 0 (0 is the default value, optional parameter).
            So our <i>person</i> class looks like :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">)</span>

<span class="pre">#endif <span class="comment">// _PERSON_H_</span></span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"><font style="background-color:yellow"> 0</font></span><span class="operator">);
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>In version B of the application</b>, we modify our <i>person</i> class and we add 2 properties : <i>sex</i> and <i>address</i>.
            Our class has changed, so we have to increment its class version number, and new properties must have a version equals to 1.
            Now, our <i>person</i> class looks like :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.h">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>
   <font style="background-color:yellow">QString sex<span class="operator">;</span></font>
   <font style="background-color:yellow">QString address<span class="operator">;</span></font>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }
};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"><font style="background-color:yellow"> 1</font></span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="person.cpp">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">,</span><span class="int"> 0</span><span class="operator">);</span>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>sex<span class="operator">,</span><span class="string"> "sex"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>address<span class="operator">,</span><span class="string"> "address"</span><span class="operator">,</span><span class="int"> 1</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> QxOrm library can serialize this <i>person</i> class from application in version A, then deserialize this version A stream to create a cloned instance of <i>person</i> class in version B of our application.
            <br><br>
            <b>Other note :</b> remove a property breaks ascendant compatibility.
            So it is recommended to never remove a property to work with QxOrm serialization engine : it is possible for example to put a <i>private</i> visibility and to delete <i>get/set</i> accessors, so property is hidden and can be considered as obsolete.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_600">Qt QDataStream engine</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be serialized using <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">Qt QDataStream engine</a>.
            Functions to use Qt QDataStream serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_byte_array()</a> : serialize a C++ instance (registered in QxOrm context) to a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_byte_array()</a> : restore a C++ instance based on a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_string()</a> : same serialization as <i>to_byte_array()</i> function + base 64 conversion to <a href="http://doc.qt.io/qt-5/qstring.html" target="_blank">QString</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_string()</a> : restore a C++ instance based on a binary stream converted to base 64 ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file()</a> : binary serialization of a C++ instance (registered in QxOrm context) to a file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file()</a> : restore a C++ instance from a file which contains serialized binary stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::to_file_compressed()</a> : binary serialization of a C++ instance (registered in QxOrm context) to a compressed file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1qt.html" target="_blank">qx::serialization::qt::from_file_compressed()</a> : restore a C++ instance from a compressed file which contains serialized binary stream ;</li>
            </ul>
            <b>Note :</b> <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> serialization is portable (support serialization/deserialization on all environments : Windows, Linux, Mac OS X, etc...).
            The output serialized stream is in binary format : so stream size is smaller than XML or JSON for example.
            <a href="http://doc.qt.io/qt-5/qdatastream.html" target="_blank">QDataStream</a> serialization is based on introspection engine of QxOrm library, so it is slower than <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine (based on C++ template).
            <br><br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt QDataStream serialization">
<pre><span class="comment">   // Fetch a drug with id '3' in a new variable
   // drug is a C++ class registered in QxOrm context
</span>   drug d<span class="operator">;</span>
   d<span class="operator">.</span>id<span class="operator"> =</span><span class="int"> 3</span><span class="operator">;</span>
   QSqlError daoError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id<span class="operator">(</span>d<span class="operator">);</span><span class="comment">

   // Serialize the drug to a file
</span>   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>to_file<span class="operator">(</span>d<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Import drug from file in a new instance
</span>   drug d2<span class="operator">;</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>qt<span class="operator">::</span>from_file<span class="operator">(</span>d2<span class="operator">,</span><span class="string"> "export_drug.txt"</span><span class="operator">);</span><span class="comment">

   // Check if d == d2
</span>   qAssert<span class="operator">(</span>d<span class="operator"> ==</span> d2<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Note :</b> in above example, we serialize a C++ instance.
            All functions in <a href="../doxygen/html/namespaceqx_1_1serialization.html" target="_blank">qx::serialization</a> namespace can serialize list of objects.
            For more details about supported containers, please read this chapter : <a href="#manual_390">Supported containers</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_606">Qt JSON engine</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be serialized to JSON using <a href="http://doc.qt.io/qt-5/json.html" target="_blank">Qt QJson engine</a> (requires Qt5).
            Functions to use Qt JSON serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json</a>.
            <ul>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_string()</a> : serialize a C++ instance (registered in QxOrm context) to JSON ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_string()</a> : restore a C++ instance from a JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file()</a> : JSON serialization of a C++ instance (registered in QxOrm context) to a file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file()</a> : restore a C++ instance from a file which contains serialized JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_file_compressed()</a> : JSON serialization of a C++ instance (registered in QxOrm context) to a compressed file ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_file_compressed()</a> : restore a C++ instance from a compressed file which contains serialized JSON stream ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::to_byte_array()</a> : serialize a C++ instance (registered in QxOrm context) to a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type ;</li>
               <li><a href="../doxygen/html/namespaceqx_1_1serialization_1_1json.html" target="_blank">qx::serialization::json::from_byte_array()</a> : restore a C++ instance based on a binary stream of <a href="http://doc.qt.io/qt-5/qbytearray.html" target="_blank">QByteArray</a> type.</li>
            </ul>
            <b>Note :</b> <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> serialization engine is the most permissive (compared to <a href="#manual_610">XML engine</a> for example) : indeed, properties can be defined in any order, and properties can be removed or added.
            JSON deserialization doesn't generate errors or throw exceptions : the engine ignores invalid or removed properties (but JSON stream must be valid) : so JSON engine is much more flexible than <a href="#manual_610">XML engine</a>.
            <br><br>
            <b>Other note :</b> <a href="http://doc.qt.io/qt-5/json.html" target="_blank">JSON</a> serialization is based on introspection engine of QxOrm library, so it is slower than <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine (based on C++ template).
            <br><br>
            <b>For example :</b><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">   // Fetch a list of authors from database and serialize them to a JSON file
</span>   list_author list_of_author<span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_all<span class="operator">(</span>list_of_author<span class="operator">);</span>
   qx<span class="operator">::</span>serialization<span class="operator">::</span>json<span class="operator">::</span>to_file<span class="operator">(</span>list_of_author<span class="operator">,</span><span class="string"> "list_of_author.json"</span><span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br>
            Above example generates following JSON stream :<br>
            <div class="json_pretty">
<pre>{
    "author_id_2": {
        "author_id": "author_id_2",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_2",
        "sex": 1
    },
    "author_id_3": {
        "author_id": "author_id_3",
        "birthdate": "2016-03-24",
        "list_blog": [
        ],
        "name": "author_3",
        "sex": 1
    }
}</pre>
            </div>
            <br><br>
            <b>Note :</b> <a href="#manual_97">QxRestApi module</a> provided by QxOrm library is based on JSON serialization engine.
            <br><br>
            <b>Other note :</b> you can customize output JSON format (to filter some properties generated by JSON serialization process).
            All JSON serialization functions provide an optional parameter of type <i>QString</i> named <i>format</i>.
            Prerequisites to use this <i>format</i> parameter are :
            <ul>
               <li><i>format</i> parameter must start with prefix : <i><b>filter:</b></i> ;</li>
               <li>output properties can be defined inside <i><b>{ }</b></i> ;</li>
               <li>relationships are splitted by character <i><b>|</b></i> ;</li>
               <li>character <i><b>*</b></i> means : <i>all relationships for 1 level</i> ;</li>
               <li>character <i><b>-</b></i> before <i><b>{ }</b></i> means : <i>all properties except</i>.</li>
            </ul>
            <br>
            <b>Example :</b> here is a JSON serialization example defining an output format to filter some properties on several levels of relationships :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Qt JSON serialization">
<pre><span class="comment">// Serialize a C++ instance to a JSON string</span>
QString jsonFormat = <font style="background-color:yellow"><span class="string">"filter: { blog_text } | author_id { name, birthdate } | list_comment { comment_text } -&gt; blog_id -&gt; *"</span></font>;
QString outputJsonFiltered = qx::serialization::json::to_string(blog, <span class="int">1</span>, <font style="background-color:yellow">jsonFormat</font>);
qDebug(<span class="string">"[QxOrm] custom JSON serialization process (filtered) : \n%s"</span>, qPrintable(outputJsonFiltered));

<span class="comment">// Fill a C++ instance based on a JSON string</span>
blog_ptr blogFromJsonFiltered; blogFromJsonFiltered.reset(<span class="operator">new</span> blog());
qx::serialization::json::from_string(blogFromJsonFiltered, outputJsonFiltered, <span class="int">1</span>, <font style="background-color:yellow">jsonFormat</font>);
qx::dump(blogFromJsonFiltered);
qAssert(blogFromJsonFiltered-&gt;m_text != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_dt_creation.isNull()); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_author->m_sex == author::unknown); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_author->m_name != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX.size() > <span class="int">0</span>);
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_dt_create.isNull()); <span class="comment">// Not fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_text != <span class="string">""</span>); <span class="comment">// Fetched</span>
qAssert(blogFromJsonFiltered-&gt;m_commentX[0]->m_blog);</pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_610">XML boost serialization</a></p>
         <div class="manual_div_content">
            XML <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine is disabled by default : to enable this feature, it is necessary to define <b>_QX_ENABLE_BOOST_SERIALIZATION</b> and <b>_QX_ENABLE_BOOST_SERIALIZATION_XML</b> compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            It is also required to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary (because this module is not <i>header only</i>), and to set the path to this boost serialization binary to <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> and <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> variables of <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            <br><br>
            Each C++ class registered in QxOrm context can be serialized using <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">XML boost::serialization engine</a>.
            Functions to work with XML boost serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">qx::serialization::xml</a> (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace).
            <br><br>
            XML boost serialization engine is :
            <ul>
               <li><i>portable</i> : support serialization/deserialization on all environments : Windows, Linux, Mac OS X, etc... ;</li>
               <li><i>slowest</i> : slower than <i>binary</i> and <i>text</i> serialization ;</li>
               <li><i>largest</i> : generated stream are bigger than <i>binary</i> and <i>text</i> serialization ;</li>
               <li><i>human-readable</i> : a XML stream can easily be parsed by a text editor and can be read by a human.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_620">Binary boost serialization</a></p>
         <div class="manual_div_content">
            Binary <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine is disabled by default : to enable this feature, it is necessary to define <b>_QX_ENABLE_BOOST_SERIALIZATION</b> and <b>_QX_ENABLE_BOOST_SERIALIZATION_BINARY</b> compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            It is also required to build <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> binary (because this module is not <i>header only</i>), and to set the path to this boost serialization binary to <b>QX_BOOST_LIB_PATH</b>, <b>QX_BOOST_LIB_SERIALIZATION_DEBUG</b> and <b>QX_BOOST_LIB_SERIALIZATION_RELEASE</b> variables of <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a>.
            <br><br>
            Each C++ class registered in QxOrm context can be serialized using <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">binary boost::serialization engine</a>.
            Functions to work with binary boost serialization are available in namespace : <a href="../doxygen/html/namespaceqx_1_1serialization_1_1xml.html" target="_blank">qx::serialization::binary</a> (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace).
            <br><br>
            Binary boost serialization engine is : 
            <ul>
               <li><i>non-portable</i> : an instance serialized on Windows cannot be deserialized on Linux for example : so you have to stay on the same environment ;</li>
               <li><i>fastest</i> : faster than <i>XML</i> and <i>text</i> serialization ;</li>
               <li><i>smallest</i> : generated stream are smaller than <i>XML</i> and <i>text</i> serialization ;</li>
               <li><i>non-human-readable</i> : a binary stream cannot be read (not useful to log for example).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_630">Other boost serialization</a></p>
         <div class="manual_div_content">
            <a href="http://www.boost.org/doc/libs/release/libs/serialization/doc/index.html" target="_blank">boost::serialization</a> engine provides several formats to serialize C++ classes.
            All boost serialization process are disabled by default, so to use them (same functions as <a href="#manual_600">qx::serialization::qt</a> namespace), it is necessary to define compilation options in <a href="#manual_220">QxOrm.pri (or QxOrm.cmake) configuration file</a> :
            <ul>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_POLYMORPHIC :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__binary.html" target="_blank">qx::serialization::polymorphic_binary</a>, <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__xml.html" target="_blank">qx::serialization::polymorphic_xml</a> and <a href="../doxygen/html/namespaceqx_1_1serialization_1_1polymorphic__text.html" target="_blank">qx::serialization::polymorphic_text</a> namespaces ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_TEXT :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1text.html" target="_blank">qx::serialization::text</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_PORTABLE_BINARY :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1portable__binary.html" target="_blank">qx::serialization::portable_binary</a> namespace (not officially supported by boost library) ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_BINARY :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1binary.html" target="_blank">qx::serialization::wide::binary</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_TEXT :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1text.html" target="_blank">qx::serialization::wide::text</a> namespace ;</li>
               <li><b>_QX_ENABLE_BOOST_SERIALIZATION_WIDE_XML :</b> enable functions from <a href="../doxygen/html/namespaceqx_1_1serialization_1_1wide_1_1xml.html" target="_blank">qx::serialization::wide::xml</a> namespace.</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_640">Clone a C++ instance</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be cloned using :
            <ul>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>std::shared_ptr&lt;T&gt;</i> type (by default equals to <i>boost::shared_ptr&lt;T&gt;</i> type, if C++11 enabled then equals to <i>std::shared_ptr&lt;T&gt;</i> type) ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_boost_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>boost::shared_ptr&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_qt_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>QSharedPointer&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_std_shared_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> of <i>std::shared_ptr&lt;T&gt;</i> type ;</li>
               <li><a href="../doxygen/html/_qx_clone_8h.html" target="_blank">qx::clone_to_nude_ptr&lt;T&gt;(const T & t) :</a> create a new instance similar to <i>t</i> in a raw pointer : be careful because you have to free memory (using <i>delete</i>) once you have finished to work with this nude pointer (to avoid memory leak).</li>
            </ul>
            <b>For example :</b>
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone">
<pre>   drug_ptr d1<span class="operator">;</span>
   d1<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> drug<span class="operator">());</span>
   d1<span class="operator">-&gt;</span>name<span class="operator"> =</span><span class="string"> "name1"</span><span class="operator">;</span>
   d1<span class="operator">-&gt;</span>description<span class="operator"> =</span><span class="string"> "desc1"</span><span class="operator">;</span><span class="comment">

   // Clone a drug
</span>   <font style="background-color:yellow">drug_ptr d_clone<span class="operator"> =</span> qx<span class="operator">::</span>clone<span class="operator">(*</span> d1<span class="operator">);</span></font><span class="comment">

   // Check if (d1 == d_clone)
</span>   qAssert<span class="operator">((*</span> d1<span class="operator">) == (*</span> d_clone<span class="operator">));</span></pre>
            </td></tr></tbody></table>
            <br>
            <b>Important note :</b> be careful when you clone a smart-pointer (<i>boost::shared_ptr</i> or <i>QSharedPointer</i> for example) where the root item can be referenced several times in its hierarchy (tree structure for example).
            In this case, to protect the root pointer of a double deletion (2 smart-pointers which take ownership of the same raw pointer), it is recommended to clone this way :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::clone smart-pointer">
<pre><span class="comment">// 'pOther' type is boost::shared_ptr&lt;myClass&gt; (smart-pointer)
</span>boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt; *</span> pCloneTemp<span class="operator"> =</span> qx<span class="operator">::</span>clone_to_nude_ptr<span class="operator">(</span>pOther<span class="operator">);</span>
boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;</span> pClone<span class="operator"> = (</span>pCloneTemp<span class="operator"> ? (*</span> pCloneTemp<span class="operator">) :</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>myClass<span class="operator">&gt;());</span><span class="flow">
if</span><span class="operator"> (</span>pCloneTemp<span class="operator">) {</span><span class="keyword"> delete</span> pCloneTemp<span class="operator">;</span> pCloneTemp<span class="operator"> =</span> NULL<span class="operator">; }</span><span class="comment">
// Now use 'pClone' ...</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_650">Dump a C++ instance (XML or JSON format)</a></p>
         <div class="manual_div_content">
            Each C++ class registered in QxOrm context can be displayed to <a href="#manual_606">JSON format</a>.
            If <a href="#manual_610">XML boost::serialization engine</a> is enabled, then it is also possible to display a XML dump of a C++ instance (second input parameter of <i>qx::dump</i> function).
            QxOrm dump feature can be useful to debug or to log for example.
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="qx::dump">
<pre>   blog_ptr b<span class="operator">;</span>
   b<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> blog<span class="operator">());</span>
   b<span class="operator">-&gt;</span>id<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span>
   qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_all_relation<span class="operator">(</span>b<span class="operator">);</span><span class="comment">

   // Dump 'b' instance result from database (XML or JSON serialization)
   // Second parameter is optional : 'true' = JSON format, 'false' = XML format
</span>   <font style="background-color:yellow">qx<span class="operator">::</span>dump<span class="operator">(</span>b, false<span class="operator">);</span></font></pre>
            </td></tr></tbody></table>
            <br>
            Above source code generates output XML :
            <br><br>
            <div style="width:900px; height:200px; overflow:auto; background-color:white">
<pre>
[QxOrm] start dump 'boost::shared_ptr&lt;blog&gt;'
&lt;boost.shared_ptr-blog- class_id="0" tracking_level="0" version="1"&gt;
	&lt;px class_id="1" tracking_level="1" version="0" object_id="_0"&gt;
		&lt;blog_id&gt;113&lt;/blog_id&gt;
		&lt;blog_text class_id="2" tracking_level="0" version="0"&gt;update blog_text_1&lt;/blog_text&gt;
		&lt;date_creation class_id="3" tracking_level="0" version="0"&gt;20100409162612000&lt;/date_creation&gt;
		&lt;author_id class_id="4" tracking_level="0" version="1"&gt;
			&lt;px class_id="5" tracking_level="1" version="0" object_id="_1"&gt;
				&lt;author_id&gt;author_id_2&lt;/author_id&gt;
				&lt;name&gt;author_2&lt;/name&gt;
				&lt;birthdate class_id="6" tracking_level="0" version="0"&gt;20100409&lt;/birthdate&gt;
				&lt;sex&gt;1&lt;/sex&gt;
				&lt;list_blog class_id="7" tracking_level="0" version="0"&gt;
					&lt;count&gt;0&lt;/count&gt;
					&lt;item_version&gt;1&lt;/item_version&gt;
				&lt;/list_blog&gt;
			&lt;/px&gt;
		&lt;/author_id&gt;
		&lt;list_comment class_id="8" tracking_level="0" version="0"&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="9" tracking_level="0" version="1"&gt;
				&lt;px class_id="10" tracking_level="1" version="0" object_id="_2"&gt;
					&lt;comment_id&gt;209&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_1 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_3"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category class_id="11" tracking_level="0" version="0"&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;px class_id_reference="10" object_id="_4"&gt;
					&lt;comment_id&gt;210&lt;/comment_id&gt;
					&lt;comment_text&gt;comment_2 text&lt;/comment_text&gt;
					&lt;date_creation&gt;20100409162612000&lt;/date_creation&gt;
					&lt;blog_id&gt;
						&lt;px class_id_reference="1" object_id="_5"&gt;
							&lt;blog_id&gt;113&lt;/blog_id&gt;
							&lt;blog_text&gt;&lt;/blog_text&gt;
							&lt;date_creation&gt;&lt;/date_creation&gt;
							&lt;author_id&gt;
								&lt;px class_id="-1"&gt;&lt;/px&gt;
							&lt;/author_id&gt;
							&lt;list_comment&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_comment&gt;
							&lt;list_category&gt;
								&lt;count&gt;0&lt;/count&gt;
							&lt;/list_category&gt;
						&lt;/px&gt;
					&lt;/blog_id&gt;
				&lt;/px&gt;
			&lt;/item&gt;
		&lt;/list_comment&gt;
		&lt;list_category&gt;
			&lt;count&gt;2&lt;/count&gt;
			&lt;item class_id="12" tracking_level="0" version="0"&gt;
				&lt;first&gt;355&lt;/first&gt;
				&lt;second class_id="13" tracking_level="0" version="0"&gt;
					&lt;qt_shared_ptr class_id="14" tracking_level="1" version="0" object_id="_6"&gt;
						&lt;category_id&gt;355&lt;/category_id&gt;
						&lt;name&gt;category_1&lt;/name&gt;
						&lt;description&gt;desc_1&lt;/description&gt;
						&lt;list_blog class_id="15" tracking_level="0" version="0"&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
			&lt;item&gt;
				&lt;first&gt;357&lt;/first&gt;
				&lt;second&gt;
					&lt;qt_shared_ptr class_id_reference="14" object_id="_7"&gt;
						&lt;category_id&gt;357&lt;/category_id&gt;
						&lt;name&gt;category_3&lt;/name&gt;
						&lt;description&gt;desc_3&lt;/description&gt;
						&lt;list_blog&gt;
							&lt;count&gt;0&lt;/count&gt;
						&lt;/list_blog&gt;
					&lt;/qt_shared_ptr&gt;
				&lt;/second&gt;
			&lt;/item&gt;
		&lt;/list_category&gt;
	&lt;/px&gt;
&lt;/boost.shared_ptr-blog-&gt;
[QxOrm] end dump 'boost::shared_ptr&lt;blog&gt;'
</pre>
            </div>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_70">Introspection - Reflection</a></p>
      <div class="manual_div_content_1">
           All C++ classes registered in QxOrm context (with <i>qx::register_class&lt;T&gt;()</i> function) can be used by introspection engine (or reflection engine) of QxOrm library.
           Introspection engine provides dynamically (so during program execution) some information about types.
           These information are called <i>meta-datas</i> and list some classes characteristics (properties, methods, etc.).
           Many programming languages (for example Java or C#) have natively this mechanism, but not C++, that's why QxOrm library emulates an introspection engine.
           For more details about introspection (or reflection), please <a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" target="_blank">read the Wikipedia web page</a>.
           <br><br>
           Here is a list of QxOrm library classes to register/access to <i>meta-datas</i> :
           <ul>
             <li><a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX</a> : singleton class to iterate over all classes registered in QxOrm context (with <i>qx::register_class&lt;T&gt;()</i> function) ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank">qx::IxClass</a> : interface for a class registered in QxOrm context ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank">qx::IxDataMemberX</a> : list of properties associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> : interface for a class property ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunctionX</a> : list of methods associated to a class ;</li>
             <li><a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> : interface for a class method.</li>
           </ul>
           A <a href="../doxygen/html/classqx_1_1_ix_class.html" target="_blank"><i>qx::IxClass</i></a> instance contains the list of class properties (<a href="../doxygen/html/classqx_1_1_ix_data_member_x.html" target="_blank"><i>qx::IxDataMemberX</i></a>) and the list of class methods (<a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank"><i>qx::IxFunctionX</i></a>).<br>
           <br>
           Introspection engine of QxOrm library provides :
           <ul>
             <li><a href="#manual_740">create dynamically an instance of a class using class name as string format (<i>qx::create()</i>)</a> ;</li>
             <li><a href="#manual_710">access/modify dynamically the value of an object field</a> (<i>qx::IxDataMember::getValue()</i> and <i>qx::IxDataMember::setValue()</i>) ;</li>
             <li><a href="#manual_730">invoke dynamically a class method (<i>qx::IxFunction::invoke()</i>)</a> ;</li>
             <li><a href="#manual_750">access to the class hierarchy (for example <i>qx::IxClass::getBaseClass()</i>)</a>.</li>
           </ul>
           <br>
           <b>Note :</b> <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module of QxOrm library (<a href="./tutorial_2.html" target="_blank">click here to go to the tutorial</a>) is based on introspection engine to provide an easy and powerful way to create C++ application server calling dynamically services methods (client request) on server side, and creating automatically input/ouput services parameters instances.<br>
           <br>
           <b>Other note :</b> you can add extra information to introspection engine using <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank"><i>property bag</i> pattern</a>.
           Indeed, <i>qx::IxClass</i>, <i>qx::IxDataMember</i> and <i>qx::IxFunction</i> classes contain a list of <i>QVariant</i> items associated to a <i>QString</i> key (read <a href="../doxygen/html/classqx_1_1_qx_property_bag.html" target="_blank"><i>qx::QxPropertyBag</i> class documentation</a> for more details).
           <br><br>
           <b>Other note :</b> to initialize QxOrm introspection engine, it is recommanded to call following function once in your <i>main</i> for example :
           <br><br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Register introspection engine">
<pre><span class="comment">// Following command is recommanded to initialize QxOrm introspection engine</span>
qx::QxClassX::registerAllClasses(true);</pre>
           </td></tr></tbody></table>
           <br><br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_710">Get a data member value dynamically</a></p>
         <div class="manual_div_content">
            To get dynamically a data member value using introspection engine of QxOrm library, you have to work with <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> base class (interface).
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class provides several methods to get a data member value (each method has a generic pointer <i>void *</i> as parameter which is the address of the current instance) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">toVariant()</a> : returns data member value converted to <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> type ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValue&lt;T&gt;()</a> : returns data member value in its real type (template T) ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">getValueAnyPtr()</a> : returns data member value encapsulated in <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any</a> type (possibility to cast using <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any_cast</a> function).</li>
            </ul>
            <b>For example :</b> we have a generic pointer <i>void *</i> to a <i>person</i> class.
            We can get the <i>QString</i> value of <i>firstName</i> property writing :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to get the data member value with the real type
</span>QString sFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">);</span><span class="comment">

// Second method to get the data member value converted in QVariant
</span>QVariant vFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>toVariant<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Third method to get the value encapsulated in qx::any type
</span>boost<span class="operator">::</span>any aFirstName<span class="operator"> =</span> pDataMember<span class="operator">-&gt;</span>getValueAnyPtr<span class="operator">(</span>p<span class="operator">);</span><span class="comment">

// Check if all values are equals
</span>qAssert<span class="operator">((</span>sFirstName<span class="operator"> ==</span> vFirstName<span class="operator">.</span>toString<span class="operator">()) &amp;&amp; (</span>sFirstName<span class="operator"> == (*</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span>QString<span class="operator"> *&gt;(</span>aFirstName<span class="operator">))));</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_720">Set a data member value dynamically</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> base class (interface) is able to set dynamically a new value to a property class (modify its value).
            <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember</a> class provides 2 methods (each method has a generic pointer <i>void *</i> as parameter which is the address of the current instance, and the new value to change) :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">fromVariant()</a> : set a new data member value based on a <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariant</a> parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">setValue&lt;T&gt;()</a> : set a new data member value based on a real type parameter (template T).</li>
            </ul>
            <b>For example :</b> we have a generic pointer <i>void *</i> to a <i>person</i> class.
            We can modify <i>firstName</i> property of <i>QString</i> type writing :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine">
<pre><span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

// Get a pointer to the registered data member 'firstName' of class 'person'
</span>qx<span class="operator">::</span>IxDataMember<span class="operator"> *</span> pDataMember<span class="operator"> =</span> qx<span class="operator">::</span>QxClassX<span class="operator">::</span>getDataMember<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "firstName"</span><span class="operator">);</span><span class="comment">

// First method to change the data member value
</span>QVariant vFirstName<span class="operator"> =</span> QVariant<span class="operator">(</span><span class="string">"my new firstname 1"</span><span class="operator">);</span>
pDataMember<span class="operator">-&gt;</span>fromVariant<span class="operator">(</span>p<span class="operator">,</span> vFirstName<span class="operator">);</span><span class="comment">

// Other method to change the data member value (using real type)
</span>QString sFirstName<span class="operator"> =</span><span class="string"> "other firstname 2"</span><span class="operator">;</span>
pDataMember<span class="operator">-&gt;</span>setValue<span class="operator">&lt;</span>QString<span class="operator">&gt;(</span>p<span class="operator">,</span> sFirstName<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_730">Call function dynamically</a></p>
         <div class="manual_div_content">
            Like data members (class properties), it is possible to register class methods (functions) in QxOrm context (support <i>static</i> and <i>non static</i> methods).
            Introspection engine of QxOrm library can invoke dynamically class methods.
            All functions registered in QxOrm context are associated to a <a href="../doxygen/html/classqx_1_1_ix_function.html" target="_blank">qx::IxFunction</a> instance.
            To register a class method in QxOrm context, you have to use these functions :
            <ul>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_0()</a> : register a class method without parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_1()</a> : register a class method with 1 parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_2()</a> : register a class method with 2 parameters ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fct_X()</a> : the <i>X</i> suffix means parameters count of a class method ;</li>
               <br>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_0()</a> : register a <i>static</i> class method without parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_1()</a> : register a <i>static</i> class method with 1 parameter ;</li>
               <li><a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_2()</a> : register a <i>static</i> class method with 2 parameters ;</li>
               <li>etc... <a href="../doxygen/html/classqx_1_1_qx_class.html" target="_blank">qx::QxClass&lt;T&gt;::fctStatic_X()</a> : the <i>X</i> suffix means parameters count of a <i>static</i> class method ;</li>
            </ul>
            <b>For example :</b> we want to register in QxOrm context several methods of a <i>person</i> class :
            <br><br>
            <i>* person.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="pre">#ifndef _PERSON_H_
#define _PERSON_H_
</span><span class="keyword">
class</span> person<span class="operator">
{</span><span class="keyword">
public</span><span class="operator">:</span><span class="type">
   long</span> id<span class="operator">;</span>
   QString firstName<span class="operator">;</span>
   QString lastName<span class="operator">;</span>
   QDateTime birthDate<span class="operator">;</span>

   person<span class="operator">() :</span> id<span class="operator">(</span><span class="int">0</span><span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>person<span class="operator">() { ; }</span>

   <font style="background-color:yellow"><span class="type">long</span> getId<span class="operator">()</span><span class="keyword"> const</span><span class="operator">;</span></font>
   <font style="background-color:yellow"><span class="type">void</span> myMethodWith2Params<span class="operator">(</span><span class="type">int</span> param1<span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> param2<span class="operator">);</span></font>

   <font style="background-color:yellow"><span class="keyword">static</span><span class="type"> double</span> myStaticMethodWith1Param<span class="operator">(</span><span class="type">long</span> param1<span class="operator">);</span></font>

<span class="operator">};</span>

QX_REGISTER_HPP_MY_TEST_EXE<span class="operator">(</span>person<span class="operator">,</span> qx<span class="operator">::</span>trait<span class="operator">::</span>no_base_class_defined<span class="operator">,</span><span class="int"> 0</span><span class="operator">)</span><span class="pre">

#endif // _PERSON_H_</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* person.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre><span class="keyword">namespace</span> qx<span class="operator"> {</span><span class="keyword">
template</span><span class="operator"> &lt;&gt;</span><span class="type"> void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>person<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
  t<span class="operator">.</span>id<span class="operator">(&amp;</span> person<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>firstName<span class="operator">,</span><span class="string"> "first_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>lastName<span class="operator">,</span><span class="string"> "last_name"</span><span class="operator">);</span>
  t<span class="operator">.</span>data<span class="operator">(&amp;</span> person<span class="operator">::</span>birthDate<span class="operator">,</span><span class="string"> "birth_date"</span><span class="operator">);</span>

  <font style="background-color:yellow">t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>getId<span class="operator">,</span><span class="string"> "getId"</span><span class="operator">);</span></font>
  <font style="background-color:yellow">t<span class="operator">.</span>fct_2<span class="operator">&lt;</span><span class="type">void</span><span class="operator">,</span><span class="type"> int</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;&gt;(&amp;</span> person<span class="operator">::</span>myMethodWith2Params<span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">);</span></font>

  <font style="background-color:yellow">t<span class="operator">.</span>fctStatic_1<span class="operator">&lt;</span><span class="type">double</span><span class="operator">,</span><span class="type"> long</span><span class="operator">&gt;(&amp;</span> person<span class="operator">::</span>myStaticMethodWith1Param<span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">);</font>
}}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Once registered in QxOrm context, it is possible to call functions dynamically using <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invoke()</a> and <a href="../doxygen/html/classqx_1_1_qx_class_x.html" target="_blank">qx::QxClassX::invokeStatic()</a> :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - function">
<pre>   <span class="comment">// Generic pointer of type void * : we know that p is of type 'person'
</span><span class="type">   void</span><span class="operator"> *</span> p<span class="operator"> = ...;</span><span class="comment">

   // Call method 'long getId() const' and get return value
</span>   boost<span class="operator">::</span>any returnValue<span class="operator">;</span>
   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "getId"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> ""</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   long</span> lId<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">long</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a string (default separator for parameters is character '|')
   // This way to pass parameters to the function works only if parameters are numeric or string
   // If parameters are more complex, then you have to encapsulate parameters in a list of qx::any, as shown below
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span><span class="string"> "36|my string param 2"</span><span class="operator">);</span><span class="comment">

   // Call method 'myMethodWith2Params' with 2 parameters encapsulated in a list of qx::any : std::vector&lt;qx::any&gt;
</span>   std<span class="operator">::</span>vector<span class="operator">&lt;</span>boost<span class="operator">::</span>any<span class="operator">&gt;</span> lstParams<span class="operator">;</span><span class="type">
   int</span> iParam1<span class="operator"> =</span><span class="int"> 36</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>iParam1<span class="operator">);</span><span class="comment"> // Parameter at position 1
</span>   QString sParam2<span class="operator"> =</span><span class="string"> "my string param 2"</span><span class="operator">;</span> lstParams<span class="operator">.</span>push_back<span class="operator">(</span>sParam2<span class="operator">);</span><span class="comment"> // Parameter at position 2
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invoke<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myMethodWith2Params"</span><span class="operator">,</span> p<span class="operator">,</span> lstParams<span class="operator">);</span><span class="comment">

   // Call static method 'myStaticMethodWith1Param' with 1 parameter and get return value
</span>   qx<span class="operator">::</span>QxClassX<span class="operator">::</span>invokeStatic<span class="operator">(</span><span class="string">"person"</span><span class="operator">,</span><span class="string"> "myStaticMethodWith1Param"</span><span class="operator">,</span><span class="string"> "19"</span><span class="operator">, (&amp;</span> returnValue<span class="operator">));</span><span class="type">
   double</span> dValue<span class="operator"> =</span> boost<span class="operator">::</span>any_cast<span class="operator">&lt;</span><span class="type">double</span><span class="operator">&gt;(</span>returnValue<span class="operator">);</span></pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_740">Create a C++ instance dynamically</a></p>
         <div class="manual_div_content">
            Introspection engine of QxOrm library is able to create class instances dynamically based on class name (<a href="../doxygen/html/group___qx_factory.html" target="_blank">QxFactory module</a>, design pattern factory) using following functions :
            <ul>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type encapsulated in <a href="http://www.boost.org/doc/libs/release/doc/html/any.html" target="_blank">qx::any</a> type (which contains a <i>std::shared_ptr</i> smart-pointer, equals to <i>boost::shared_ptr</i> by default) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_nude_ptr&lt;T&gt;(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type in a nude pointer of <i>T *</i> type (you have to delete yourself this nude pointer to avoid memory leak) ;</li>
               <li><a href="../doxygen/html/group___qx_factory.html" target="_blank">qx::create_void_ptr(const QString & sKey)</a> : create a C++ instance of <i>sKey</i> type in a nude pointer of <i>void *</i> type (you have to delete yourself this nude pointer to avoid memory leak).</li>
            </ul>
            <b>For example :</b> <a href="#manual_80">QxService module</a> of QxOrm library creates services instances dynamically (based on service name) to execute server routines automatically :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="Introspection engine - factory">
<pre>   qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator"> *</span> ptr<span class="operator"> =</span> qx<span class="operator">::</span>create_nude_ptr<span class="operator">&lt;</span>qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">&gt;(</span>m_sServiceName<span class="operator">);</span>   </pre>
            </td></tr></tbody></table>
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_750">Iterate over all classes/properties registered in QxOrm context</a></p>
         <div class="manual_div_content">
           Here is an example based on introspection engine of QxOrm library : <i>how to iterate over all classes, properties and methods registered in QxOrm context ?</i><br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QString QxClassX<span class="operator">::</span>dumpAllClasses<span class="operator">()
{</span>
   QxClassX<span class="operator">::</span>registerAllClasses<span class="operator">();</span>
   QxCollection<span class="operator">&lt;</span>QString<span class="operator">,</span> IxClass<span class="operator"> *&gt; *</span> pAllClasses<span class="operator"> =</span> QxClassX<span class="operator">::</span>getAllClasses<span class="operator">();</span><span class="flow">
   if</span><span class="operator"> (!</span> pAllClasses<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span><span class="string"> ""</span><span class="operator">; }</span>

   QString sDump<span class="operator">;</span><span class="type">
   long</span> lCount<span class="operator"> =</span> pAllClasses<span class="operator">-&gt;</span>count<span class="operator">();</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] start dump all registered classes (%ld)"</span><span class="operator">,</span> lCount<span class="operator">);</span>
   _foreach<span class="operator">(</span>IxClass<span class="operator"> *</span> pClass<span class="operator">, (*</span> pAllClasses<span class="operator">))
   {</span><span class="flow"> if</span><span class="operator"> (</span>pClass<span class="operator">) {</span> sDump<span class="operator"> +=</span> pClass<span class="operator">-&gt;</span>dumpClass<span class="operator">(); } }</span>
   qDebug<span class="operator">(</span><span class="string">"[QxOrm] %s"</span><span class="operator">,</span><span class="string"> "end dump all registered classes"</span><span class="operator">);</span><span class="flow">

   return</span> sDump<span class="operator">;
}</span>

QString IxClass<span class="operator">::</span>dumpClass<span class="operator">()</span><span class="keyword"> const</span><span class="operator">
{</span>
   QString sDump<span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "-- class '"</span><span class="operator"> +</span> m_sKey<span class="operator"> +</span><span class="string"> "' (name '"</span><span class="operator"> +</span> m_sName<span class="operator"> +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "description '"</span><span class="operator"> +</span> m_sDescription<span class="operator"> +</span><span class="string"> "', version '"</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>m_lVersion<span class="operator">) +</span><span class="string"> "', "</span><span class="operator">;</span>
   sDump<span class="operator"> +=</span><span class="string"> "base class '"</span><span class="operator"> + (</span>getBaseClass<span class="operator">() ?</span> getBaseClass<span class="operator">()-&gt;</span>getKey<span class="operator">() :</span><span class="string"> ""</span><span class="operator">) +</span><span class="string"> "')\n"</span><span class="operator">;</span><span class="type">

   long</span> lCount<span class="operator"> = (</span>m_pDataMemberX<span class="operator"> ?</span> m_pDataMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered properties ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDataMemberX<span class="operator">)
   {</span>
      IxDataMember<span class="operator"> *</span> pId<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getId<span class="operator">();</span><span class="flow">
      for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span> lCount<span class="operator">;</span> l<span class="operator">++)
      {</span>
         IxDataMember<span class="operator"> *</span> p<span class="operator"> =</span> m_pDataMemberX<span class="operator">-&gt;</span>get<span class="operator">(</span>l<span class="operator">);</span><span class="flow"> if</span><span class="operator"> (!</span> p<span class="operator">) {</span><span class="flow"> continue</span><span class="operator">; }</span>
         IxSqlRelation<span class="operator"> *</span> pRelation<span class="operator"> =</span> p<span class="operator">-&gt;</span>getSqlRelation<span class="operator">();</span>
         QString sInfos<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">() + ((</span>p<span class="operator"> ==</span> pId<span class="operator">) ?</span> QString<span class="operator">(</span><span class="string">" (id)"</span><span class="operator">) :</span> QString<span class="operator">());</span>
         sInfos<span class="operator"> += (</span>pRelation<span class="operator"> ? (</span>QString<span class="operator">(</span><span class="string">" ("</span><span class="operator">) +</span> pRelation<span class="operator">-&gt;</span>getDescription<span class="operator">() +</span> QString<span class="operator">(</span><span class="string">")"</span><span class="operator">)) :</span> QString<span class="operator">());</span>
         sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sInfos<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">;
      }
   }</span>

   lCount<span class="operator"> = (</span>m_pFctMemberX<span class="operator"> ?</span> m_pFctMemberX<span class="operator">-&gt;</span>count<span class="operator">() :</span><span class="int"> 0</span><span class="operator">);</span>
   sDump<span class="operator"> +=</span><span class="string"> "\t* list of registered functions ("</span><span class="operator"> +</span> QString<span class="operator">::</span>number<span class="operator">(</span>lCount<span class="operator">) +</span><span class="string"> ")\n"</span><span class="operator">;</span><span class="flow">
   if</span><span class="operator"> (</span>m_pFctMemberX<span class="operator">)
   {</span>
      _foreach_if<span class="operator">(</span>IxFunction_ptr p<span class="operator">, (*</span> m_pFctMemberX<span class="operator">), (</span>p<span class="operator">))
      {</span> QString sKey<span class="operator"> =</span> p<span class="operator">-&gt;</span>getKey<span class="operator">();</span> sDump<span class="operator"> +=</span><span class="string"> "\t\t"</span><span class="operator"> +</span> sKey<span class="operator"> +</span><span class="string"> "\n"</span><span class="operator">; }
   }</span>

   qDebug<span class="operator">(</span><span class="string">"%s"</span><span class="operator">,</span> qPrintable<span class="operator">(</span>sDump<span class="operator">));</span><span class="flow">
   return</span> sDump<span class="operator">;
}</span></pre>
           </td></tr></tbody></table>
           <br>
           If we execute the <i>qx::QxClassX::dumpAllClasses()</i> function with <a href="./tutorial.html" target="_blank">qxBlog tutorial</a>, here are output logs :<br>
           <br>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="operator">[</span>QxOrm<span class="operator">]</span> start dump all registered classes<span class="operator"> (</span><span class="int">4</span><span class="operator">)
--</span><span class="keyword"> class</span><span class="char"> 'author'</span><span class="operator"> (</span>name<span class="char"> 'author'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">5</span><span class="operator">)</span>
		author_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		birthdate
		sex
		list_blog<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">1</span><span class="operator">)</span>
		age<span class="operator">

--</span><span class="keyword"> class</span><span class="char"> 'blog'</span><span class="operator"> (</span>name<span class="char"> 'blog'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">6</span><span class="operator">)</span>
		blog_id<span class="operator"> (</span>id<span class="operator">)</span>
		blog_text
		date_creation
		author_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)</span>
		list_comment<span class="operator"> (</span>relation one<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)</span>
		list_category<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'comment'</span><span class="operator"> (</span>name<span class="char"> 'comment'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		comment_id<span class="operator"> (</span>id<span class="operator">)</span>
		comment_text
		date_creation
		blog_id<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>one<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

--</span><span class="keyword"> class</span><span class="char"> 'category'</span><span class="operator"> (</span>name<span class="char"> 'category'</span><span class="operator">,</span> description<span class="char"> ''</span><span class="operator">,</span> version<span class="char"> '0'</span><span class="operator">,</span> base<span class="keyword"> class</span><span class="char"> ''</span><span class="operator">)
	*</span> list of registered properties<span class="operator"> (</span><span class="int">4</span><span class="operator">)</span>
		category_id<span class="operator"> (</span>id<span class="operator">)</span>
		name
		description
		list_blog<span class="operator"> (</span>relation many<span class="operator">-</span>to<span class="operator">-</span>many<span class="operator">)
	*</span> list of registered functions<span class="operator"> (</span><span class="int">0</span><span class="operator">)

[</span>QxOrm<span class="operator">]</span> end dump all registered classes</pre>
           </td></tr></tbody></table>
           <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_80">Services : transfer persistent data layer over network (QxService module)</a></p>
      <div class="manual_div_content_1">
         <a href="../doxygen/html/group___qx_service.html" target="_blank"><b>QxService</b></a> module of <b>QxOrm</b> library provides an easy and powerful way to create <b>C++ application server</b> (<i>services</i> with <i>request</i> from client and <i>response</i> from server).
         <font style="background-color:yellow"><b><a href="./tutorial_2.html">A tutorial is available on QxOrm web site</a></b></font> to show how to work with <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a>.
         <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module is based on <a href="#manual_70">introspection engine</a> and <a href="#manual_60">serialization engine</a> of QxOrm library to transfer persistent data layer over network and execute automatically server routines on server side.
         <br><br>
         <b>Note :</b> to enable <b>QxService</b> module, you have to define <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> compilation option in <a href="#manual_220"><i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file</a>.
         This compilation option adds a dependency to QxOrm library : <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> provided by Qt framework.
         <br><br>
         <b>Other note :</b> <b>QxEntityEditor</b> application is deployed with <i>QxEECppServicesExport</i> plugin : this plugin generates automatically all C++ source code to transfer all project entities over network.
         A list of client/server methods are generated automatically (to manage CRUD operations) :
         <ul>
            <li><i>count() :</i> client/server query to count entities (possibility to add a SQL query filter) ;</li>
            <li><i>fetchById() :</i> client/server query to fetch entity properties based on its identifier ;</li>
            <li><i>fetchAll() :</i> client/server query to fetch properties of all entities (mapped to a database table) ;</li>
            <li><i>fetchByQuery() :</i> client/server query to fetch properties of entities filtered by a SQL query ;</li>
            <li><i>insert() :</i> client/server query to insert entity values ;</li>
            <li><i>update() :</i> client/server query to update entity values ;</li>
            <li><i>save() :</i> client/server query to save entity values (insert or update) ;</li>
            <li><i>deleteById() :</i> client/server query to delete an entity based on its identifier ;</li>
            <li><i>deleteAll() :</i> client/server query to delete all entities (mapped to a database table) ;</li>
            <li><i>deleteByQuery() :</i> client/server query to delete entities filtered by a SQL query ;</li>
            <li><i>destroyById() :</i> client/server query to delete an entity based on its identifier (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>destroyAll() :</i> client/server query to delete all entities mapped to a database table (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>destroyByQuery() :</i> client/server query to delete entities filtered by a SQL query (manage <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>executeQuery() :</i> client/server query to execute <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
            <li><i>exist() :</i> client/server query to check if an entity already exists based on its identifier ;</li>
            <li><i>isValid() :</i> client/server query to check entity validity (<a href="#manual_420">QxValidator module</a>).</li>
         </ul>
         It is possible to add and to customize services generated by <b>QxEntityEditor</b> application.
         <br><br>
         The goal of this chapter is to show <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a> concepts :
         <ul>
            <li><a href="#manual_810">Input/output service parameters (request/response)</a> ;</li>
            <li><a href="#manual_820">Define service functions exposed to clients</a> ;</li>
            <li><a href="#manual_825">List of options available on server side</a> ;</li>
            <li><a href="#manual_826">Connection settings on client side</a> ;</li>
            <li><a href="#manual_830">Service authentication</a> ;</li>
            <li><a href="#manual_840">Async client/server queries</a>.</li>
         </ul>
         <br>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_810">Input/output service parameters (request/response)</a></p>
         <div class="manual_div_content">
            Each function exposed by a service has input parameters (request from client) and output parameters (response from server).
            These input/output parameters must inherit from <a href="../doxygen/html/classqx_1_1service_1_1_ix_parameter" target="_blank">qx::service::IxParameter</a> interface and must be registered in QxOrm context (with <i>void qx::register_class&lt;T&gt;</i> function).
            <br><br>
            <b>For example :</b> here is an example of input/output parameters generated by <b>QxEntityEditor</b> application based on <i>blog</i> class of <a href="./tutorial.html" target="_blank">qxBlog tutorial</a> :
            <br><br>
            <i>* blog.services.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_ptr<span class="operator">;</span><span class="keyword">
typedef</span> qx<span class="operator">::</span>QxCollection<span class="operator">&lt;</span><span class="type">long</span><span class="operator">,</span> blog_ptr<span class="operator">&gt;</span> list_of_blog<span class="operator">;</span><span class="keyword">
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>list_of_blog<span class="operator">&gt;</span> list_of_blog_ptr<span class="operator">;</span><span class="comment">

/* -- Service Input Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_input<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_input<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_input<span class="operator">();</span><span class="type">

   long</span> id<span class="operator">;</span><span class="comment">                   //!&lt; Id to fetch or delete
</span>   blog_ptr instance<span class="operator">;</span><span class="comment">         //!&lt; Single instance to fetch, insert, update, delete or validate
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">     //!&lt; List of instances to fetch, insert, update, delete or validate
</span>   qx_query query<span class="operator">;</span><span class="comment">            //!&lt; Query to execute when fetching, updating or deleting
</span>   QStringList columns<span class="operator">;</span><span class="comment">       //!&lt; List of columns to fetch or update
</span>   QStringList relations<span class="operator">;</span><span class="comment">     //!&lt; List of relations to fetch
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt;</span> blog_input_ptr<span class="operator">;</span><span class="comment">

/* -- Service Output Parameters -- */</span><span class="keyword">

<font style="background-color:yellow">class</span> QXBLOG_SERVICES_EXPORT blog_output<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter</font><span class="operator">
{</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_output<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_output<span class="operator">();</span>

   blog_ptr instance<span class="operator">;</span><span class="comment">            //!&lt; Single instance from server
</span>   list_of_blog_ptr list<span class="operator">;</span><span class="comment">        //!&lt; List of instances from server
</span>   QSqlError error<span class="operator">;</span><span class="comment">              //!&lt; If a SQL error occurred, this output parameter is not empty
</span>   qx<span class="operator">::</span>QxInvalidValueX invalid<span class="operator">;</span><span class="comment">  //!&lt; Check if a single instance (or a list of instances) is valid
</span>   qx_query query<span class="operator">;</span><span class="comment">               //!&lt; Query which contains all results
</span><span class="type">   long</span> count<span class="operator">;</span><span class="comment">                   //!&lt; Count how many items in database using a query or not
</span>   qx_bool exist<span class="operator">;</span><span class="comment">                //!&lt; Check if a single instance (or a list of instances) exist in database
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt;</span> blog_output_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_output<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* blog.services.gen.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_input<span class="operator">,</span> services_blog_input<span class="operator">)</span>
QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_output<span class="operator">,</span> services_blog_output<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_input<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>id<span class="operator">,</span><span class="string"> "id"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>columns<span class="operator">,</span><span class="string"> "columns"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_input<span class="operator">::</span>relations<span class="operator">,</span><span class="string"> "relations"</span><span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;&gt;</span><font style="background-color:yellow"><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_output<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>instance<span class="operator">,</span><span class="string"> "instance"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>list<span class="operator">,</span><span class="string"> "list"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>error<span class="operator">,</span><span class="string"> "error"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>invalid<span class="operator">,</span><span class="string"> "invalid"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>query<span class="operator">,</span><span class="string"> "query"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>count<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> services<span class="operator">::</span>blog_output<span class="operator">::</span>exist<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> input/output parameters can contain complex structures (containers, smart-pointers, etc...).
            So it is very easy to transfer complex classes (for example with relationships) with <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService module</a>.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_820">Define service functions exposed to clients</a></p>
         <div class="manual_div_content">
            Each service registered in <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module exposes a list of functions to clients (client/server queries).
            All services must inherit from <a href="../doxygen/html/classqx_1_1service_1_1_qx_service.html" target="_blank">qx::service::QxService&lt;INPUT, OUTPUT&gt;</a> base class (<i>INPUT</i> and <i>OUTPUT</i> template parameters are explained in chapter : <a href="#manual_810">Input/output service parameters, request/response</a>) and must be registered in QxOrm context (with <i>void qx::register_class&lt;T&gt;</i> function).
            <br><br>
            <b>For example :</b> here is a service example generated by <b>QxEntityEditor</b> application based on <i>blog</i> class of <a href="./tutorial.html" target="_blank">qxBlog tutorial</a> :
            <br><br>
            <i>* blog.services.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> services<span class="operator"> {</span><span class="comment">

/* -- Service Definition -- */</span>

<font style="background-color:yellow"><span class="keyword">typedef</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span> blog_input<span class="operator">,</span> blog_output<span class="operator"> &gt;</span> blog_base_class<span class="operator">;</span><span class="keyword">
class</span> QXBLOG_SERVICES_EXPORT blog_services<span class="operator"> :</span><span class="keyword"> public</span> blog_base_class</font><span class="operator">
{</span>

   QX_REGISTER_FRIEND_CLASS<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">)</span><span class="keyword">

public</span><span class="operator">:</span>

   blog_services<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_services<span class="operator">();</span><span class="keyword">

protected</span><span class="operator">:</span><span class="type">

   void</span> fetchById_<span class="operator">();</span><span class="type">
   void</span> fetchAll_<span class="operator">();</span><span class="type">
   void</span> fetchByQuery_<span class="operator">();</span><span class="type">

   void</span> insert_<span class="operator">();</span><span class="type">
   void</span> update_<span class="operator">();</span><span class="type">
   void</span> save_<span class="operator">();</span><span class="type">
   void</span> deleteById_<span class="operator">();</span><span class="type">
   void</span> deleteAll_<span class="operator">();</span><span class="type">
   void</span> deleteByQuery_<span class="operator">();</span><span class="type">
   void</span> destroyById_<span class="operator">();</span><span class="type">
   void</span> destroyAll_<span class="operator">();</span><span class="type">
   void</span> destroyByQuery_<span class="operator">();</span><span class="type">

   void</span> executeQuery_<span class="operator">();</span><span class="type">
   void</span> callQuery_<span class="operator">();</span><span class="type">
   void</span> exist_<span class="operator">();</span><span class="type">
   void</span> count_<span class="operator">();</span><span class="type">
   void</span> isValid_<span class="operator">();</span><span class="pre">

#ifdef _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="keyword">
public</span><span class="operator">:</span>

   blog_ptr fetchById<span class="operator">(</span><span class="type">long</span> id<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchAll<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError fetchByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span>
                                      <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError insert<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError insert<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError update<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">(),</span>
                             <span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> columns<span class="operator"> =</span> QStringList<span class="operator">(),</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>
   QSqlError save<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relations<span class="operator"> =</span> QStringList<span class="operator">());</span>

   QSqlError deleteById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError deleteById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError deleteAll<span class="operator">();</span>
   QSqlError deleteByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span><span class="type">long</span> id<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError destroyById<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError destroyAll<span class="operator">();</span>
   QSqlError destroyByQuery<span class="operator">(</span><span class="keyword">const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>

   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   QSqlError executeQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">,</span> list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError callQuery<span class="operator">(</span>qx_query<span class="operator"> &amp;</span> query<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx_bool exist<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span>
   QSqlError count<span class="operator">(</span><span class="type">long</span><span class="operator"> &amp;</span> lCount<span class="operator">,</span><span class="keyword"> const</span> qx_query<span class="operator"> &amp;</span> query<span class="operator"> =</span> qx_query<span class="operator">());</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>blog_ptr<span class="operator"> &amp;</span> p<span class="operator">);</span>
   qx<span class="operator">::</span>QxInvalidValueX isValid<span class="operator">(</span>list_of_blog_ptr<span class="operator"> &amp;</span> lst<span class="operator">);</span><span class="pre">

#endif // _QXBLOG_SERVICES_MODE_CLIENT
</span><span class="operator">
};</span><span class="keyword">

typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt;</span> blog_services_ptr<span class="operator">;

}</span><span class="comment"> // namespace services
</span>
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxService<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> services_blog_services<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* blog.services.gen.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_QXBLOG_SERVICES<span class="operator">(</span>services<span class="operator">::</span>blog_services<span class="operator">,</span> services_blog_services<span class="operator">)</span><span class="keyword">

namespace</span> qx<span class="operator"> {</span>

<font style="background-color:yellow"><span class="keyword">template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>services<span class="operator">::</span>blog_services<span class="operator">&gt; &amp;</span> t<span class="operator">)</span></font>
<span class="operator">{</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchById_<span class="operator">,</span><span class="string"> "fetchById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchAll_<span class="operator">,</span><span class="string"> "fetchAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>fetchByQuery_<span class="operator">,</span><span class="string"> "fetchByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>insert_<span class="operator">,</span><span class="string"> "insert"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>update_<span class="operator">,</span><span class="string"> "update"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>save_<span class="operator">,</span><span class="string"> "save"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteById_<span class="operator">,</span><span class="string"> "deleteById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteAll_<span class="operator">,</span><span class="string"> "deleteAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>deleteByQuery_<span class="operator">,</span><span class="string"> "deleteByQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyById_<span class="operator">,</span><span class="string"> "destroyById"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyAll_<span class="operator">,</span><span class="string"> "destroyAll"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>destroyByQuery_<span class="operator">,</span><span class="string"> "destroyByQuery"</span><span class="operator">);</span>

   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>executeQuery_<span class="operator">,</span><span class="string"> "executeQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>callQuery_<span class="operator">,</span><span class="string"> "callQuery"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>exist_<span class="operator">,</span><span class="string"> "exist"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>count_<span class="operator">,</span><span class="string"> "count"</span><span class="operator">);</span>
   t<span class="operator">.</span>fct_0<span class="operator">&lt;</span><span class="type">void</span><span class="operator">&gt;(&amp;</span> services<span class="operator">::</span>blog_services<span class="operator">::</span>isValid_<span class="operator">,</span><span class="string"> "isValid"</span><span class="operator">);
}

}</span><span class="comment"> // namespace qx

// Then there is the implementation of all functions provided by the service...</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> once registered in QxOrm context, all clients connected to server can call these functions exposed by the service : server routines are executed automatically.
            Data serialization and network layer to transfer persistent classes are managed automatically by <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_825">List of options available on server side</a></p>
         <div class="manual_div_content">
            C++ application server based on <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides several parameters in <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class :
            <ul>
               <li><i>setPort() :</i> listening port number to receive request from client and send response from server ;</li>
               <li><i>setThreadCount() :</i> threads count available on server side to manage several client requests at the same time ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">serialization type</a> used to send response from server to client ;</li>
               <li><i>setCompressData() :</i> define if data sent from server to client are compressed or not ;</li>
               <li><i>setEncryptData() :</i> define if data sent from server to client are encrypted or not (with possibility to configure an encryption key).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_826">Connection settings on client side</a></p>
         <div class="manual_div_content">
            Client layer based on <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides several parameters in <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class :
            <ul>
               <li><i>setIp() :</i> IP address of C++ application server ;</li>
               <li><i>setPort() :</i> port number used by C++ application server ;</li>
               <li><i>setSerializationType() :</i> <a href="#manual_60">serialization type</a> used by client layer to send requests from client to server ;</li>
               <li><i>setCompressData() :</i> define if data sent from client to server are compressed or not ;</li>
               <li><i>setEncryptData() :</i> define if data sent from client to server are encrypted or not (with possibility to configure an encryption key).</li>
            </ul>
            <br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_830">Service authentication</a></p>
         <div class="manual_div_content">
            It is often necessary to add a control on server side to check users connected on client side.
            <a href="../doxygen/html/classqx_1_1service_1_1_ix_service.html" target="_blank">qx::service::IxService</a> interface (base class for all services registered in <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module) provides virtual methods which can be overridden to manage authentication :
            <ul>
               <li><i>onBeforeProcess() :</i> virtual method called before server routine execution ;</li>
               <li><i>onAfterProcess() :</i> virtual method called after server routine execution.</li>
            </ul>
            <br>
            <b>For example :</b> here is a class named <i>ParameterAuthentication</i> which can be used as base class for all other parameters, this class provides 3 properties <i>login</i>, <i>password</i> and <i>token</i> :
            <br><br>
            <i>* ParameterAuthentication.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">class</span> MY_DLL_EXPORT ParameterAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ParameterAuthentication<span class="operator">();</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ParameterAuthentication<span class="operator">();</span>
 
   QString login<span class="operator">;</span>
   QString password<span class="operator">;</span>
   QString token<span class="operator">;</span><span class="comment">
   // etc..., put here all properties required by the authentication process
</span><span class="operator"> 
};</span><span class="keyword">
 
typedef</span> boost<span class="operator">::</span>shared_ptr<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt;</span> ParameterAuthentication_ptr<span class="operator">;</span>
 
QX_REGISTER_COMPLEX_CLASS_NAME_HPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> qx<span class="operator">::</span>service<span class="operator">::</span>IxParameter<span class="operator">,</span><span class="int"> 0</span><span class="operator">,</span> ParameterAuthentication<span class="operator">)</span></pre>
            </td></tr></tbody></table>
            <br>
            <i>* ParameterAuthentication.cpp file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>QX_REGISTER_COMPLEX_CLASS_NAME_CPP_MY_DLL<span class="operator">(</span>ParameterAuthentication<span class="operator">,</span> ParameterAuthentication<span class="operator">)</span><span class="keyword">
 
namespace</span> qx<span class="operator"> {</span><span class="keyword">
 
template</span><span class="operator"> &lt;&gt;</span><span class="type">
void</span> register_class<span class="operator">(</span>QxClass<span class="operator">&lt;</span>ParameterAuthentication<span class="operator">&gt; &amp;</span> t<span class="operator">)
{</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>login<span class="operator">,</span><span class="string"> "login"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>password<span class="operator">,</span><span class="string"> "password"</span><span class="operator">);</span>
   t<span class="operator">.</span>data<span class="operator">(&amp;</span> ParameterAuthentication<span class="operator">::</span>token<span class="operator">,</span><span class="string"> "token"</span><span class="operator">);
}
 
}</span><span class="comment"> // namespace qx</span></pre>
            </td></tr></tbody></table>
            <br><br>
            We have a base class for all parameters (<i>ParameterAuthentication</i>), we will now create a base class for all services named <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i>.
            This service base class will override <i>onBeforeProcess()</i> virtual method to manage authentication before each service routine execution :
            <br><br>
            <i>* ServiceAuthentication.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#include "ParameterAuthentication.h"
</span><span class="keyword"> 
template</span><span class="operator"> &lt;</span><span class="keyword">class</span> INPUT<span class="operator">,</span><span class="keyword"> class</span> OUTPUT<span class="operator">&gt;</span><span class="keyword">
class</span> ServiceAuthentication<span class="operator"> :</span><span class="keyword"> public</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;
{</span><span class="keyword">
 
public</span><span class="operator">:</span>
 
   ServiceAuthentication<span class="operator">(</span><span class="keyword">const</span> QString<span class="operator"> &amp;</span> sServiceName<span class="operator">) :</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxService<span class="operator">&lt;</span>INPUT<span class="operator">,</span> OUTPUT<span class="operator">&gt;(</span>sServiceName<span class="operator">) { ; }</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>ServiceAuthentication<span class="operator">() { ; }</span>
 
   <font style="background-color:yellow"><span class="keyword">virtual</span><span class="type"> void</span> onBeforeProcess<span class="operator">()</span></font>
   <span class="operator">{</span><span class="comment">
      // Here you can implement your own authentication control (checking login/password for example)
      // You can get input authentication parameters like this :
</span>      ParameterAuthentication_ptr pParams<span class="operator"> =</span> getInputParameter<span class="operator">();</span>
      <i>pParams<span class="operator">-&gt;</span>login<span class="operator">,</span> pParams<span class="operator">-&gt;</span>password<span class="operator">,</span> etc<span class="operator">...</span></i><span class="comment">
 
      // If authentication is not valid, then you can throw an exception (and stop process before executing service function)
</span><span class="flow">      throw</span> qx<span class="operator">::</span>exception<span class="operator">(</span><span class="string">"Authentication error !"</span><span class="operator">);
   }
 
};</span></pre>
            </td></tr></tbody></table>
            <br><br>
            Now we have <i>ParameterAuthentication</i> base class and <i>ServiceAuthentication&lt;INPUT, OUTPUT&gt;</i> base class : all parameters and services must inherit from these classes to manage automatically authentication, and return an error message to client when user settings are not valid.
            <br><br>
            <b>Note :</b> like authentication, it is possible to manage logs on server side using <i>onBeforeProcess()</i> and <i>onAfterProcess()</i> virtual methods.
            <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_840">Async client/server queries</a></p>
         <div class="manual_div_content">
            By default, all client/server queries are synchronous operations : that means that client layer waits for server response to continue its execution.
            With a user interface (<i>GUI</i>), a client/server query locks application (<i>freeze</i>) if it is executed in the main thread : so if server response is not sent quickly, users could think that the application is crashed.
            <a href="../doxygen/html/group___qx_service.html" target="_blank">QxService</a> module provides an easy way to perform asynchronous client/server queries (so without freezing GUI user interface) with <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class.
            <br><br>
            <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class is based on <a href="#manual_70">introspection engine</a> of QxOrm library and <a href="http://doc.qt.io/qt-5/signalsandslots.html" target="_blank">Qt <i>SIGNAL-SLOT</i> feature</a>.
            <a href="../doxygen/html/classqx_1_1service_1_1_qx_client_async.html" target="_blank">qx::service::QxClientAsync</a> class requires :
            <ul>
               <li>a service instance ;</li>
               <li>input/output service parameters ;</li>
               <li>server routine name to execute (string format) ;</li>
               <li>a callback function called at the end of the transaction (connection to <i>finished()</i> <i>signal</i> event).</li>
            </ul>
            <br>
            Here is an example from <a href="./tutorial_2.html#tuto_302">qxClientServer tutorial</a> which runs a server routine asynchronously :
            <br><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td title="main_dlg::onClickBtnDateTimeAsync(), main_dlg::onDateTimeAsyncFinished()">
<pre><span class="type">void</span> main_dlg<span class="operator">::</span>onClickBtnDateTimeAsync<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (</span>m_pDateTimeAsync<span class="operator">) {</span> qDebug<span class="operator">(</span><span class="string">"[QxOrm] '%s' transaction is already running"</span><span class="operator">,</span><span class="string"> "server_infos::get_current_date_time"</span><span class="operator">);</span><span class="flow"> return</span><span class="operator">; }</span><span class="comment">

   // Création d'une instance de service et appel à la méthode pour recevoir la date-heure courante du serveur (mode asynchrone)
</span>   server_infos_ptr service<span class="operator"> =</span> server_infos_ptr<span class="operator">(</span><span class="keyword">new</span> server_infos<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">(</span><span class="keyword">new</span> qx<span class="operator">::</span>service<span class="operator">::</span>QxClientAsync<span class="operator">());</span>
   QObject<span class="operator">::</span>connect<span class="operator">(</span>m_pDateTimeAsync<span class="operator">.</span>get<span class="operator">(),</span> SIGNAL<span class="operator">(</span>finished<span class="operator">()),</span><span class="keyword"> this</span><span class="operator">,</span> SLOT<span class="operator">(</span>onDateTimeAsyncFinished<span class="operator">()));</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>setService<span class="operator">(</span>service<span class="operator">,</span><span class="string"> "get_current_date_time"</span><span class="operator">);</span>
   m_pDateTimeAsync<span class="operator">-&gt;</span>start<span class="operator">();
}</span><span class="type">

void</span> main_dlg<span class="operator">::</span>onDateTimeAsyncFinished<span class="operator">()
{</span><span class="flow">
   if</span><span class="operator"> (!</span> m_pDateTimeAsync<span class="operator"> || !</span> m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()) {</span><span class="flow"> return</span><span class="operator">; }</span>
   updateLastTransactionLog<span class="operator">(</span>m_pDateTimeAsync<span class="operator">-&gt;</span>getService<span class="operator">()-&gt;</span>getTransaction<span class="operator">());</span>
   m_pDateTimeAsync<span class="operator">.</span>reset<span class="operator">();
}</span></pre>
            </td></tr></tbody></table>
            <br><br>
            <b>Note :</b> above example shows how to perform an asynchronous client/server query with these steps :
            <ul>
               <li>create a service instance (of <i>server_infos_ptr</i> type in this example) ;</li>
               <li>create a <i>qx::service::QxClientAsync</i> instance ;</li>
               <li>connect <i>finished</i> event to a callback function (named <i>onDateTimeAsyncFinished()</i> in this example) ;</li>
               <li>pass service instance and service function name to execute to <i>qx::service::QxClientAsync</i> object ;</li>
               <li>run the transaction calling <i>start()</i> method.</li>
            </ul>
            <br>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_90">Model View engine (QxModelView module)</a></p>
      <div class="manual_div_content_1">
         <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module provides an easy way to work with <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a> with all C++ classes registered in QxOrm context :
         <ul>
           <li><a href="#manual_940">QML</a> : each property defined in QxOrm context is exposed to QML engine : <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module makes easier integration between QML and databases ;</li>
           <li><a href="#manual_950">Qt widgets</a> : <i>QTableView</i> or <i>QListView</i> for example to display/modify a database table content.</li>
         </ul>
         <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides a generic way for all models linked to persistent classes registered in QxOrm context.
         All methods of this class prefixed by '<i>qx</i>' call functions from <a href="../doxygen/html/namespaceqx_1_1dao.html" target="_blank">qx::dao namespace</a> and then communicate with database.
         <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides also <b>Q_INVOKABLE</b> methods which can be called in <a href="#manual_940">QML</a> files :
         <ul>
            <li><i>qxCount_() :</i> entities count in table mapped to model (possibility to add a SQL query filter) ;</li>
            <li><i>qxFetchById_() :</i> fetch model properties based on its identifier ;</li>
            <li><i>qxFetchAll_() :</i> fetch model with all entities in table mapped to model ;</li>
            <li><i>qxFetchByQuery_() :</i> fetch model with entities in table mapped to model filtered by a SQL query ;</li>
            <li><i>qxFetchRow_() :</i> fetch (update) a model row (each model row provides its own identifier) ;</li>
            <li><i>qxInsert_() :</i> insert all model entities (all model rows) to database ;</li>
            <li><i>qxInsertRow_() :</i> insert a model row to database ;</li>
            <li><i>qxUpdate_() :</i> update all model entities (all model rows) to database ;</li>
            <li><i>qxUpdateRow_() :</i> update a model row to database ;</li>
            <li><i>qxSave_() :</i> save all model entities (all model rows) to database (insert or update) ;</li>
            <li><i>qxSaveRow_() :</i> save a model row to database (insert or update) ;</li>
            <li><i>qxDeleteById_() :</i> delete an entity from database based on the identifier parameter ;</li>
            <li><i>qxDeleteAll_() :</i> delete all entities in table mapped to model ;</li>
            <li><i>qxDeleteByQuery_() :</i> delete entities in table mapped to model based on a SQL query ;</li>
            <li><i>qxDeleteRow_() :</i> delete a model row in database (each model row provides its own identifier) ;</li>
            <li><i>qxDestroyById_() :</i> delete an entity from database based on the identifier parameter (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyAll_() :</i> delete all entities in table mapped to model (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyByQuery_() :</i> delete entities in table mapped to model based on a SQL query (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
            <li><i>qxDestroyRow_() :</i> delete a model row in database (each model row provides its own identifier), support <a href="#manual_3400">soft delete behaviour, logical delete</a> ;</li>
            <li><i>qxExecuteQuery_() :</i> fetch model using <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
            <li><i>qxExist_() :</i> check if an entity already exists based on the identifier parameter ;</li>
            <li><i>qxValidate_() :</i> check validity of all model content (<a href="#manual_420">QxValidator module</a>) ;</li>
            <li><i>qxValidateRow_() :</i> check validity of a model row (<a href="#manual_420">QxValidator module</a>).</li>
         </ul>
         <br/>
         <b>Note :</b> <i>qxBlogModelView</i> sample project in <i>./test/</i> directory of QxOrm package shows how to create quickly a QxOrm model and associate it to the Qt <i>model/view</i> engine (first with <a href="#manual_950">a Qt widget</a>, then with a <a href="#manual_940">QML view</a>).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_910">Simple model (without relationship)</a></p>
         <div class="manual_div_content">
            All classes registered in QxOrm context can be used as a model to display/modify values in views.
            <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> QxOrm model base class inherits from Qt <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a> base class : so QxOrm models are full compatible with <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a>.
            <br/><br/>
            Only 1 line in C++ source code to instantiate a QxOrm model :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   <font style="background-color:yellow">qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>MyClass<span class="operator">&gt;();</span></font>   </pre>
            </td></tr></tbody></table>
            <br/>
            <b>Note :</b> the QxOrm model created with this line of code exposes automatically all properties registered in QxOrm context to Qt <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">model/view</a> engine.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_920">Model with relationships (nested models)</a></p>
         <div class="manual_div_content">
            Associate class relationships (<i>1-n</i>, <i>n-1</i> and <i>n-n</i>) to Qt model/view engine is complex : the solution provided by QxOrm library is based on <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">nested models</a> concept.
            For more details about nested models concept, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">a french tutorial is available on famous developpez.com forum</a>.
            <br/><br/>
            To use relationships (<i>1-n</i>, <i>n-1</i> and <i>n-n</i>) with <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView module</a>, it is very important to understand that there is <b>a hierarchy between models</b> (a parent model can be associated to several child models, this is the <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">nested models</a> concept).
            <br/><br/>
            To be able to work with relationships (nested models), it is necessary to create derived classes based on <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> base class.
            This way, all simple properties (not relationship) are automatically exposed to views (thanks to the base class), the only thing to do is to write accessors to manage relationships.
            <b>QxEntityEditor</b> application is deployed with <i>QxEECppModelViewExport</i> plugin : <b>this plugin generates source code automatically to work with nested models</b>.
            <br/><br/>
            Here is a source code example generated by <b>QxEntityEditor</b> application to create a QxOrm model based on <i>blog</i> class (read <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> for more details).
            <i>blog</i> class defines 3 relationships : <i>author (n-1)</i>, <i>list_of_comment (1-n)</i> and <i>list_of_category (n-n)</i> :
            <br/><br/>
            <i>* blog.model_view.gen.h file :</i><br>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span><span class="keyword">

typedef</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>blog<span class="operator">&gt;</span> blog_model_base_class<span class="operator">;</span><span class="keyword">

class</span> QXBLOG_MODEL_VIEW_EXPORT blog_model<span class="operator"> :</span><span class="keyword"> public</span> blog_model_base_class<span class="operator">
{</span>

   Q_OBJECT<span class="keyword">

public</span><span class="operator">:</span>

   blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="operator"> =</span><span class="int"> 0</span><span class="operator">);</span>
   blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">);</span><span class="keyword">
   virtual</span><span class="operator"> ~</span>blog_model<span class="operator">();</span>

   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>
   <font style="background-color:yellow">Q_INVOKABLE QObject<span class="operator"> *</span> list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="operator"> =</span><span class="bool"> false</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="operator"> =</span> QString<span class="operator">());</span></font>

   <span class="comment">/* List of properties exposed by the model (3) :
      - blog_id
      - title
      - text
   */</span><span class="keyword">

protected</span><span class="operator">:</span><span class="keyword">

   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="keyword">
   <font style="background-color:yellow">virtual</span><span class="type"> void</span> syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">);</span></font><span class="operator">

};

}</span><span class="comment"> // namespace model_view</span></pre>
            </td></tr></tbody></table>
            <br/>
            <i>* blog.model_view.gen.cpp file :</i><br>
            <div style="width:1000px; height:300px; overflow:auto; background-color:white;">
<pre><span class="keyword">namespace</span> model_view<span class="operator"> {</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>QObject<span class="operator"> *</span> parent<span class="comment"> /* = 0 */</span><span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::</span>blog_model<span class="operator">(</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> other<span class="operator">,</span> QObject<span class="operator"> *</span> parent<span class="operator">) :</span> blog_model_base_class<span class="operator">(</span>other<span class="operator">,</span> parent<span class="operator">) { ; }</span>

blog_model<span class="operator">::~</span>blog_model<span class="operator">() { ; }</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>author<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "author"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_author value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getauthor<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getauthor<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>author_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_comment<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_comment"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_comment value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_comment<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_comment<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>comment_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span>

<font style="background-color:yellow">QObject<span class="operator"> *</span> blog_model<span class="operator">::</span>list_of_category<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="type"> bool</span> bLoadFromDatabase<span class="comment"> /* = false */</span><span class="operator">,</span><span class="keyword"> const</span> QString<span class="operator"> &amp;</span> sAppendRelations<span class="comment"> /* = QString() */</span><span class="operator">)</span></font><span class="operator">
{</span>
   QString sRelation<span class="operator"> =</span><span class="string"> "list_of_category"</span><span class="operator">;</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pChild<span class="operator"> = (</span>bLoadFromDatabase<span class="operator"> ?</span> NULL<span class="operator"> :</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span> sRelation<span class="operator">));</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="flow"> return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">); }</span><span class="flow">

   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span> qAssert<span class="operator">(</span><span class="bool">false</span><span class="operator">);</span><span class="flow"> return</span> NULL<span class="operator">; }</span><span class="type">
   long</span> id<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getblog_id<span class="operator">();</span>
   blog<span class="operator">::</span>type_list_of_category value<span class="operator"> =</span> ptr<span class="operator">-&gt;</span>getlist_of_category<span class="operator">();</span><span class="flow">

   if</span><span class="operator"> (</span>bLoadFromDatabase<span class="operator">)
   {</span><span class="flow">
      if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">() &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"-&gt;"</span><span class="operator">) &amp;&amp; !</span> sAppendRelations<span class="operator">.</span>startsWith<span class="operator">(</span><span class="string">"&gt;&gt;"</span><span class="operator">)) {</span> sRelation<span class="operator"> +=</span><span class="string"> "-&gt;"</span><span class="operator"> +</span> sAppendRelations<span class="operator">; }</span><span class="flow">
      else if</span><span class="operator"> (!</span> sAppendRelations<span class="operator">.</span>isEmpty<span class="operator">()) {</span> sRelation<span class="operator"> +=</span> sAppendRelations<span class="operator">; }</span>
      blog tmp<span class="operator">;</span>
      tmp<span class="operator">.</span>setblog_id<span class="operator">(</span>id<span class="operator">);</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>m_lastError<span class="operator"> =</span> qx<span class="operator">::</span>dao<span class="operator">::</span>fetch_by_id_with_relation<span class="operator">(</span>sRelation<span class="operator">,</span> tmp<span class="operator">);</span><span class="flow">
      if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lastError<span class="operator">.</span>isValid<span class="operator">()) {</span><span class="flow"> return</span> NULL<span class="operator">; }</span>
      value<span class="operator"> =</span> tmp<span class="operator">.</span>getlist_of_category<span class="operator">();</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }</span>

   model_view<span class="operator">::</span>category_model<span class="operator"> *</span> pNewChild<span class="operator"> =</span> NULL<span class="operator">;</span>
   pChild<span class="operator"> =</span> qx<span class="operator">::</span>model_view<span class="operator">::</span>create_nested_model_with_type<span class="operator">(</span><span class="keyword">this</span><span class="operator">,</span> QModelIndex<span class="operator">(),</span> value<span class="operator">,</span> pNewChild<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pChild<span class="operator">) {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>insertChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">,</span> pChild<span class="operator">); }</span><span class="flow">
   return</span><span class="keyword"> static_cast</span><span class="operator">&lt;</span>QObject<span class="operator"> *&gt;(</span>pChild<span class="operator">);
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncNestedModel<span class="operator">(</span><span class="type">int</span> row<span class="operator">,</span><span class="keyword"> const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span>
   Q_UNUSED<span class="operator">(</span>relation<span class="operator">);</span>
   qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pNestedModel<span class="operator"> =</span> NULL<span class="operator">;</span><span class="flow">
   if</span><span class="operator"> ((</span>row<span class="operator"> &lt;</span><span class="int"> 0</span><span class="operator">) || (</span>row<span class="operator"> &gt;=</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">())) {</span><span class="flow"> return</span><span class="operator">; }</span>
   blog_model_base_class<span class="operator">::</span>type_ptr ptr<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>getByIndex<span class="operator">(</span>row<span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (!</span> ptr<span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "author"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_author value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setauthor<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_comment"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_comment value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_comment<span class="operator">(</span>value<span class="operator">);
   }</span>

   pNestedModel<span class="operator"> =</span><span class="keyword"> this</span><span class="operator">-&gt;</span>getChild<span class="operator">(</span>row<span class="operator">,</span><span class="string"> "list_of_category"</span><span class="operator">);</span><span class="flow">
   if</span><span class="operator"> (</span>pNestedModel<span class="operator">)
   {</span><span class="keyword">
      this</span><span class="operator">-&gt;</span>syncNestedModelRecursive<span class="operator">(</span>pNestedModel<span class="operator">,</span> relation<span class="operator">);</span>
      blog<span class="operator">::</span>type_list_of_category value<span class="operator">;</span>
      qx<span class="operator">::</span>model_view<span class="operator">::</span>sync_nested_model<span class="operator">(</span>pNestedModel<span class="operator">,</span> value<span class="operator">);</span>
      ptr<span class="operator">-&gt;</span>setlist_of_category<span class="operator">(</span>value<span class="operator">);
   }
}</span><span class="type">

<font style="background-color:yellow">void</span> blog_model<span class="operator">::</span>syncAllNestedModel<span class="operator">(</span><span class="keyword">const</span> QStringList<span class="operator"> &amp;</span> relation<span class="operator">)</span></font><span class="operator">
{</span><span class="flow">
   if</span><span class="operator"> (</span><span class="keyword">this</span><span class="operator">-&gt;</span>m_lstChild<span class="operator">.</span>count<span class="operator">() &lt;=</span><span class="int"> 0</span><span class="operator">) {</span><span class="flow"> return</span><span class="operator">; }</span><span class="flow">
   for</span><span class="operator"> (</span><span class="type">long</span> l<span class="operator"> =</span><span class="int"> 0</span><span class="operator">;</span> l<span class="operator"> &lt;</span><span class="keyword"> this</span><span class="operator">-&gt;</span>m_model<span class="operator">.</span>count<span class="operator">();</span> l<span class="operator">++)
   {</span><span class="keyword"> this</span><span class="operator">-&gt;</span>syncNestedModel<span class="operator">(</span><span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;(</span>l<span class="operator">),</span> relation<span class="operator">); }
}

}</span><span class="comment"> // namespace model_view</span></pre>
            </div>
            <br/><br/>
            <b>Note :</b> above example shows that the source code required to work with nested models is verbose.
            <b>So to be able to work with models and relationships, it is strongly recommended to use QxEntityEditor application to generate all C++ source code automatically.</b>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_940">Interaction with QML views</a></p>
         <div class="manual_div_content">
           Here is an example in QML (with Qt5, <b><a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a></b> module supports Qt4 too).
           This example uses '<i>author</i>' table defined in <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> (source code of this QML example is available in <i>qxBlogModelView</i> project sample of QxOrm package) :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QML view and display it
</span>QQuickView qmlView<span class="operator">;</span>
qmlView<span class="operator">.</span>rootContext<span class="operator">()-&gt;</span>setContextProperty<span class="operator">(</span><span class="string">"myModel"</span><span class="operator">,</span> pModel<span class="operator">);</span>
qmlView<span class="operator">.</span>setSource<span class="operator">(</span>QUrl<span class="operator">(</span><span class="string">"qrc:/documents/main.qml"</span><span class="operator">));</span>
qmlView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           Here is the '<i>main.qml</i>' file content :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>import QtQuick<span class="float"> 2.1</span>
import QtQuick<span class="operator">.</span>Controls<span class="float"> 1.0</span>

Item<span class="operator"> {</span>
   width<span class="operator">:</span><span class="int"> 400</span>
   height<span class="operator">:</span><span class="int"> 300</span>
   Row<span class="operator"> {</span>
      height<span class="operator">:</span><span class="int"> 20</span>
      spacing<span class="operator">:</span><span class="int"> 20</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Clear"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>clear<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Fetch All"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxFetchAll_<span class="operator">()
      }</span>
      Button<span class="operator"> {</span>
         text<span class="operator">:</span><span class="string"> "Save"</span>
         onClicked<span class="operator">:</span> myModel<span class="operator">.</span>qxSave_<span class="operator">()
      }
   }</span>
   ListView<span class="operator"> {</span>
      y<span class="operator">:</span><span class="int"> 30</span>
      height<span class="operator">:</span><span class="int"> 270</span>
      model<span class="operator">:</span> myModel
      delegate<span class="operator">:</span> Row<span class="operator"> {</span>
         height<span class="operator">:</span><span class="int"> 20</span>
         spacing<span class="operator">:</span><span class="int"> 10</span>
         Text<span class="operator"> {</span> text<span class="operator">:</span><span class="string"> "id: "</span><span class="operator"> +</span> author_id<span class="operator"> }</span>
         TextField<span class="operator"> {</span>
            text<span class="operator">:</span> name
            onTextChanged<span class="operator">:</span> name<span class="operator"> =</span> text<span class="operator">
         }
      }
   }
}</span></pre>
           </td></tr></tbody></table>
           <br>
           After executing this code, following window should be displayed :<br/>
           <br/>
           <img alt="qx_model_view_02" src="./resource/qx_model_view_02.png" border="0" /><br/>
           <br/>
           <b>Note :</b> as you can see in the '<i>main.qml</i>' file, '<i>author_id</i>' and '<i>name</i>' properties of '<i>author</i>' model (<i>myModel</i> variable) can be automatically read and write (because they are registered in QxOrm context).<br/>
           Moreover, <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> interface provides a list of methods for QML side (<i>Q_INVOKABLE</i>) to communicate with database : for example, the '<i>Save</i>' button will save the model in database without having to write a C++ function.<br/>
           <br/>
           <b>Other note :</b> <a href="#manual_920">a <b>QxEntityEditor</b> plugin generates automatically source code to manage relationships using nested models concept</a> (for more details about nested models concept, <a href="http://christophe-dumez.developpez.com/tutoriels/qt/qml/exposer-modeles-imbriques/" target="_blank">please read this french tutorial on famous developpez.com web site</a>).
           <br><br>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_950">Interaction with QtWidget views</a></p>
         <div class="manual_div_content">
           Here is an example to display/modify data from '<i>author</i>' table (read <a href="./tutorial.html" target="_blank"><i>qxBlog</i> tutorial</a> for '<i>author</i>' class definition) in a <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a> (source code of this example is available in <i>qxBlogModelView</i> project sample of QxOrm package) :<br/>
           <br/>
           <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Create a model and fetch all data from database
</span>qx<span class="operator">::</span>IxModel<span class="operator"> *</span> pModel<span class="operator"> =</span><span class="keyword"> new</span> qx<span class="operator">::</span>QxModel<span class="operator">&lt;</span>author<span class="operator">&gt;();</span>
pModel<span class="operator">-&gt;</span>qxFetchAll<span class="operator">();</span><span class="comment">

// Associate the model to a QTableView and display it
</span>QTableView tableView<span class="operator">;</span>
tableView<span class="operator">.</span>setModel<span class="operator">(</span>pModel<span class="operator">);</span>
tableView<span class="operator">.</span>show<span class="operator">();</span></pre>
           </td></tr></tbody></table>
           <br>
           After executing this code, following window should be displayed :<br/>
           <br/>
           <img alt="qx_model_view_01" src="./resource/qx_model_view_01.png" border="0" /><br/>
           <br/>
           <b>Note :</b> Qt provides several <i>QtWidget</i> views which can be mapped to a model, for example : <a href="http://doc.qt.io/qt-5/qlistview.html" target="_blank">QListView</a>, <a href="http://doc.qt.io/qt-5/qtableview.html" target="_blank">QTableView</a>, <a href="http://doc.qt.io/qt-5/qtreeview.html" target="_blank">QTreeView</a>.
           It is also possible to use <a href="http://doc.qt.io/qt-4.8/qdatawidgetmapper.html" target="_blank">QDataWidgetMapper</a> class to create your own form based on a model (<a href="http://qt-quarterly.developpez.com/qq-21/widget-correspondance-donnees/" target="_blank">a french tutorial is available on developpez.com web site</a>).
           <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_960">Connect model to QxService module</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/group___qx_model_view.html" target="_blank">QxModelView</a> module provides <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> class template (which inherits from : <a href="../doxygen/html/classqx_1_1_qx_model.html" target="_blank">qx::QxModel&lt;T&gt;</a> &gt;&gt; <a href="../doxygen/html/classqx_1_1_ix_model.html" target="_blank">qx::IxModel</a> &gt;&gt; <a href="http://doc.qt.io/qt-5/qabstractitemmodel.html" target="_blank">QAbstractItemModel</a>).
            This class has 2 template parameters :
            <ul>
               <li><i>T</i> : class registered in QxOrm context with all properties exposed to <a href="http://doc.qt.io/qt-5/modelview.html" target="_blank">Qt model/view engine</a> ;</li>
               <li><i>S</i> : service class of <a href="#manual_80">QxService module</a> to access/modify data from model (client/server requests).</li>
            </ul>
            Data provided by this model comes from client/server requests thanks to <a href="#manual_80">QxService module</a> (so data are not received from a database SQL query).
            The <i>S</i> service class must provide some methods :
            <ul>
               <li><i>count() :</i> client/server request to count entities in table mapped to model (with possibility to add a SQL query filter) ;</li>
               <li><i>fetchById() :</i> client/server request to fetch model properties based on identifier parameter ;</li>
               <li><i>fetchAll() :</i> client/server request to fetch model with all entities in table mapped to model ;</li>
               <li><i>fetchByQuery() :</i> client/server request to fetch model with entities in table mapped to model filtered by a SQL query ;</li>
               <li><i>insert() :</i> client/server request to insert model data to database ;</li>
               <li><i>update() :</i> client/server request to update model data to database ;</li>
               <li><i>save() :</i> client/server request to save model data to database (insert or update) ;</li>
               <li><i>deleteById() :</i> client/server request to delete an entity based on identifier parameter ;</li>
               <li><i>deleteAll() :</i> client/server request to delete all entities in table mapped to model ;</li>
               <li><i>deleteByQuery() :</i> client/server request to delete entities in table mapped to model based on a SQL query ;</li>
               <li><i>destroyById() :</i> client/server request to delete an entity based on identifier parameter (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>destroyAll() :</i> client/server request to delete all entities in table mapped to model (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>destroyByQuery() :</i> client/server request to delete entities in table mapped to model based on a SQL query (support <a href="#manual_3400">soft delete behaviour, logical delete</a>) ;</li>
               <li><i>executeQuery() :</i> client/server request to execute <a href="#manual_3610">a custom SQL query or stored procedure</a> ;</li>
               <li><i>exist() :</i> client/server request to check if model exists based on its identifier ;</li>
               <li><i>isValid() :</i> client/server request to check model validity (<a href="#manual_420">QxValidator module</a>).</li>
            </ul>
            <br/>
            <b>Note :</b> <b>QxEntityEditor</b> application is deployed with <i>QxEECppServicesExport</i> and <i>QxEECppModelViewExport</i> plugins : these plugins generate automatically all C++ source code required to work with QxOrm models and the <a href="#manual_80">QxService module</a>.
            <b>So to use <a href="../doxygen/html/classqx_1_1_qx_model_service.html" target="_blank">qx::QxModelService&lt;T, S&gt;</a> class, it is strongly recommended to use QxEntityEditor application to generate source code automatically.</b>
            <br/><br/>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_95">QxOrm and MongoDB database (C++ ODM Object Document Mapper)</a></p>
      <div class="manual_div_content_1">
         QxOrm library is able to connect to standard relational databases (MySQL, PostgreSQL, SQLite, Oracle, Microsoft SQLServer, MariaDB, etc...), and is also able to connect to <a href="https://www.mongodb.com/" target="_blank">the NoSQL <b>MongoDB</b> database</a>.
         <br/><br/>
         <a href="https://en.wikipedia.org/wiki/MongoDB" target="_blank">From Wikipedia website :</a> MongoDB is a free and open-source cross-platform document-oriented database program.
         Classified as a NoSQL database program, MongoDB uses JSON-like documents with schemas.
         <br/><br/>
         MongoDB database has several advantages compared to standard relational databases (non-exhaustive list) :
         <ul>
            <li><b>Schema-less</b> : you don't have to maintain tables and columns (so you don't need to write some complex scripts to migrate your database from one version to another version). MongoDB <i>Collections</i> can contain <i>Documents</i> with different fields, of different sizes, etc... About QxOrm library, that means that you can write your C++ persistent classes without having to deal with DDL database schema (useful in <b>AGILE development environment</b> for example) ;</li>
            <li><b>Data are stored in BSON format (similar to JSON)</b> : easy to read even with complex data structures ;</li>
            <li>Powerful and flexible <b>JSON query engine</b> with possibility to put indexes on any fields of MongoDB <i>Documents</i> ;</li>
            <li>MongoDB database is <b>free of charge</b>, and provides <b>a support for professionals</b> ;</li>
            <li>From MongoDB version 3.6 : MongoDB query engine provides a way to simulate <b>JOINS</b> queries (between <i>Documents</i>) like standard relational databases.</li>
         </ul>
         <br/>
         QxOrm library API is the same for MongoDB database and any other standard relational databases.
         All QxOrm library features are available for MongoDB database : so everything in this user guide can be applied to MongoDB database.
         Main differences to take into account are :
         <ul>
            <li>It is recommended to define a C++ primary key of type <i>QString</i>. There is no numeric auto-incremented value : <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB provides an ObjectId type</a> which can be mapped to QString C++ type and generated automatically (you can also create your own custom C++ type to map to MongoDB ObjectId).</li>
            <li>Queries are not SQL : <a href="#manual_992">MongoDB provides a JSON query engine</a>.</li>
         </ul>
         <br/>
         <b>Note :</b> QxOrm package provides a sample project named <b>qxBlogMongoDB</b> (in <i>./test/</i> directory).
         This sample project shows how to connect and work with MongoDB database and QxOrm library.
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_980">Prerequisites : driver <i>libmongoc</i> and <i>libbson</i></a></p>
         <div class="manual_div_content">
            QxOrm library is based on <a href="http://doc.qt.io/qt-5/qtsql-index.html" target="_blank">QtSql module</a> from Qt framework : this module doesn't provide connectors to MongoDB database.
            So QxOrm library requires 2 extra-dependencies to connect to MongoDB database :
            <ul>
               <li><a href="http://mongoc.org/libmongoc/current/" target="_blank">MongoDB C Driver (libmongoc)</a></li>
               <li><a href="http://mongoc.org/libbson/current/index.html" target="_blank">Libbson</a> : a cross-platform BSON library for C</li>
            </ul>
            <br/>
            <a href="http://mongoc.org/libmongoc/current/installing.html" target="_blank">A guide is available</a> to install these libraries (<i>libmongoc</i> and <i>libbson</i>) on your development environment.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_981">QxOrm.pri (or QxOrm.cmake) configuration file</a></p>
         <div class="manual_div_content">
            Once <i>libmongoc</i> and <i>libbson</i> libraries are installed on your development environment, you have to enable <b>_QX_ENABLE_MONGODB</b> compilation option in <i>QxOrm.pri</i> (or <i>QxOrm.cmake</i>) configuration file.
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>#######################################
# MongoDB Driver Library Dependencies #
#######################################

# If you enable <font style="background-color:yellow">_QX_ENABLE_MONGODB</font> option, then QxOrm library will be able to use mongoc driver to store all QxOrm registered classes in a MongoDB database
# When _QX_ENABLE_MONGODB compilation option is defined, you must provide following paths to manage mongoc library dependencies :
#  - a BSON_INCLUDE environment variable to define where bson library source code is located (or a QX_BSON_INCLUDE_PATH qmake variable)
#  - a MONGOC_INCLUDE environment variable to define where mongoc library source code is located (or a QX_MONGOC_INCLUDE_PATH qmake variable)
#  - a BSON_LIB environment variable to define where bson library is located (or a QX_BSON_LIB_PATH qmake variable)
#  - a MONGOC_LIB environment variable to define where mongoc library is located (or a QX_MONGOC_LIB_PATH qmake variable)</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Note :</b> once <b>_QX_ENABLE_MONGODB</b> compilation option is defined, you can build and execute <b>qxBlogMongoDB</b> sample project in <i>./test/</i> directory to validate your development environment with QxOrm and MongoDB.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_982">Connection to MongoDB database</a></p>
         <div class="manual_div_content">
            Here is an example of settings to connect to MongoDB database :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Parameters to connect to MongoDB database</span>
qx::QxSqlDatabase * pDatabase = qx::QxSqlDatabase::getSingleton();
pDatabase->setDriverName(<font style="background-color:yellow"><span class="string">"QXMONGODB"</span></font>);
pDatabase->setDatabaseName(<span class="string">"qxBlog"</span>);
pDatabase->setHostName(<span class="string">"localhost"</span>);
pDatabase->setPort(<span class="int">27017</span>);
pDatabase->setUserName(<span class="string">""</span>);
pDatabase->setPassword(<span class="string">""</span>);</pre>
            </td></tr></tbody></table>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_983">Register a MongoDB persistent class (Collection) in QxOrm context (mapping)</a></p>
         <div class="manual_div_content">
            Register a MongoDB persistent class in QxOrm context is similar to <a href="#manual_300">register a persistent class for any other standard relational databases</a>.
            Here is a persistent class example from <i>qxBlogMongoDB</i> sample project :
            <br/><br/>
            File <i>blog.h</i> :
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="pre">#ifndef _QX_BLOG_BLOG_H_
#define _QX_BLOG_BLOG_H_</span>

<span class="keyword">#include</span> <span class="string">"author.h"</span>
<span class="keyword">#include</span> <span class="string">"comment.h"</span>
<span class="keyword">#include</span> <span class="string">"category.h"</span>

<span class="keyword">class</span> QX_BLOG_DLL_EXPORT blog
{
<span class="keyword">public:</span>
<span class="comment">// -- properties</span>
   <font style="background-color:yellow">QString        m_id;</font>
   QString        m_text;
   QDateTime      m_dt_creation;
   author_ptr     m_author;
   list_comment   m_commentX;
   list_category  m_categoryX;
<span class="comment">// -- contructor, virtual destructor</span>
   blog() { ; }
   virtual ~blog() { ; }
};

<font style="background-color:yellow">QX_REGISTER_PRIMARY_KEY(blog, QString)</font>
QX_REGISTER_HPP_QX_BLOG(blog, qx::trait::no_base_class_defined, 0)

<span class="keyword">typedef</span> std::shared_ptr&lt;blog&gt; blog_ptr;
<span class="keyword">typedef</span> std::vector&lt;blog_ptr&gt; list_blog;

<span class="pre">#endif</span> <span class="comment">// _QX_BLOG_BLOG_H_</span></pre>
            </td></tr></tbody></table>
            <br/>
            File <i>blog.cpp</i> :
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">#include</span> <span class="string">"../include/precompiled.h"</span>
<span class="keyword">#include</span> <span class="string">"../include/blog.h"</span>
<span class="keyword">#include</span> <span class="string">&lt;QxOrm_Impl.h&gt;</span>

QX_REGISTER_CPP_QX_BLOG(blog)

<span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; void register_class(QxClass&lt;blog&gt; & t)
{
   t.id(& blog::m_id, <span class="string">"blog_id"</span>);

   t.data(& blog::m_text, <span class="string">"blog_text"</span>);
   t.data(& blog::m_dt_creation, <span class="string">"date_creation"</span>);
   <font style="background-color:yellow">t.data(& blog::m_categoryX, <span class="string">"list_category"</span>); <span class="comment">// Embedded relationship</span></font>

   <font style="background-color:yellow">t.relationManyToOne(& blog::m_author, <span class="string">"author_id"</span>); <span class="comment">// Referenced relationship</span></font>
   <font style="background-color:yellow">t.relationOneToMany(& blog::m_commentX, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>); <span class="comment">// Referenced relationship</span></font>
}}</pre>
            </td></tr></tbody></table>
            <br/>
            <b>Note :</b> this example shows how to define :
            <ul>
               <li><a href="#manual_9830">a primary key of type <i>QString</i> (mapped to MongoDB ObjectId)</a> ;</li>
               <li><a href="#manual_9930">relationships : Embedded vs Referenced</a>.</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9830">Manage ObjectId (primary key)</a></p>
            <div class="manual_div_content">
               It is recommended to define a C++ primary key of type <i>QString</i>.
               There is no numeric auto-incremented value : <a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB provides an ObjectId type</a> which can be mapped to QString C++ type and generated automatically (you can also create your own custom C++ type to map to MongoDB ObjectId).
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_984">Insert a C++ instance (Document) in MongoDB database</a></p>
         <div class="manual_div_content">
            Here is an example to insert a document in MongoDB database with primary key generated automatically (<a href="https://docs.mongodb.com/manual/reference/method/ObjectId/" target="_blank">MongoDB ObjectId</a>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert one author without id</span>
author_ptr author_1 = std::make_shared&lt;author&gt;();
author_1->m_name = <span class="string">"author_1"</span>;
author_1->m_sex = author::male;
author_1->m_birthdate = QDate(1998, 07, 12);
daoError = qx::dao::insert(author_1);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is an example to insert a document in MongoDB database providing a custom primary key :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert one author with a custom id</span>
author_ptr author_2 = std::make_shared&lt;author&gt;();
<font style="background-color:yellow">author_2->m_id = <span class="string">"my_custom_id_author_2"</span>;</font>
author_2->m_name = <span class="string">"author_2"</span>;
author_2->m_sex = author::female;
author_2->m_birthdate = QDate(2003, 02, 28);
daoError = qx::dao::insert(author_2);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9840">Insert many C++ instances (list of Documents) in MongoDB database</a></p>
            <div class="manual_div_content">
               Here is an example to insert several documents in MongoDB database :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Insert many authors with/without ids</span>
QList&lt;author&gt; authorX;
author author_3; author_3.m_name = <span class="string">"author_3"</span>; author_3.m_sex = author::female; author_3.m_birthdate = QDate(1968, 05, 01);
author author_4; author_4.m_id = <span class="string">"my_custom_id_author_4"</span>; author_4.m_name = <span class="string">"author_4"</span>; author_4.m_sex = author::male;
author author_5; author_5.m_name = <span class="string">"author_5"</span>; author_5.m_sex = author::female; author_5.m_birthdate = QDate(1978, 03, 03);
authorX.append(author_3); authorX.append(author_4); authorX.append(author_5);
daoError = qx::dao::insert(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> <a href="#manual_390">QxOrm library supports several C++ types to manage lists and collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_986">Update a C++ instance (Document) in MongoDB database</a></p>
         <div class="manual_div_content">
            Here is an example to update a document in MongoDB database :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Update one author</span>
author author_4;
author_4.m_id = <span class="string">"my_custom_id_author_4"</span>;
author_4.m_name = <span class="string">"author_4_modified"</span>;
daoError = qx::dao::update(author_4);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9860">Update many C++ instances (list of Documents) in MongoDB database</a></p>
            <div class="manual_div_content">
               Here is an example to update several documents in MongoDB database :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Update many authors</span>
QList&lt;author&gt; authorX;
author_3.m_name = <span class="string">"author_3_modified_twice"</span>; authorX.append(author_3);
author_2->m_name = <span class="string">"author_2_modified"</span>; authorX.append(* author_2);
author_1->m_name = <span class="string">"author_1_modified"</span>; authorX.append(* author_1);
daoError = qx::dao::update(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> <a href="#manual_390">QxOrm library supports several C++ types to manage lists and collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_988">Delete a C++ instance (Document) from MongoDB database</a></p>
         <div class="manual_div_content">
            Here is an example to delete a document from MongoDB database :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete one author by id</span>
author_ptr pAuthor = std::make_shared&lt;author&gt;();
pAuthor->m_id = <span class="string">"my_custom_id_author_4"</span>;
daoError = qx::dao::delete_by_id(pAuthor);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9880">Delete many C++ instances (list of Documents) from MongoDB database</a></p>
            <div class="manual_div_content">
               Here is an example to delete several documents from MongoDB database by identifier (primary key) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete many authors by id</span>
QList&lt;author&gt; authorX;
author_3.m_id = <span class="string">"id_author_3"</span>; authorX.append(author_3);
author_2->m_id = <span class="string">"id_author_2"</span>; authorX.append(* author_2);
author_1->m_id = <span class="string">"id_author_1"</span>; authorX.append(* author_1);
daoError = qx::dao::delete_by_id(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Here is an example to delete several documents from MongoDB database by <a href="#manual_992">JSON query</a> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete authors by query (all male)</span>
qx_query query{ { <span class="string">"sex"</span>, author::male } };
daoError = qx::dao::delete_by_query&lt;author&gt;(query);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               To delete all documents from <i>author</i> collection :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Delete all authors</span>
daoError = qx::dao::delete_all&lt;author&gt;();</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> <a href="#manual_390">QxOrm library supports several C++ types to manage lists and collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_990">Fetch a C++ instance (Document) from MongoDB database</a></p>
         <div class="manual_div_content">
            Here is an example to fetch a document from MongoDB database by identifier (primary key) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch one author by id</span>
author_ptr pAuthor = std::make_shared&lt;author&gt;();
pAuthor->m_id = <span class="string">"my_custom_id_author_2"</span>;
daoError = qx::dao::fetch_by_id(pAuthor);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9900">Fetch many C++ instances (list of Documents) from MongoDB database</a></p>
            <div class="manual_div_content">
               Here is an example to fetch several documents from MongoDB database by identifier (primary key) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by id</span>
QList&lt;author&gt; authorX;
author_3.m_id = <span class="string">"id_author_3"</span>; authorX.append(author_3);
author_2->m_id = <span class="string">"id_author_2"</span>; authorX.append(* author_2);
author_1->m_id = <span class="string">"id_author_1"</span>; authorX.append(* author_1);
daoError = qx::dao::fetch_by_id(authorX);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Here is an example to fetch several documents from MongoDB database by <a href="#manual_992">JSON query</a> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by query (only female)</span>
list_author list_of_female_author;
qx_query query{ { <span class="string">"sex"</span>, author::female } };
daoError = qx::dao::fetch_by_query(query, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Here is an example to fetch all documents from <i>author</i> collection in MongoDB database :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch all authors</span>
list_author allAuthors;
daoError = qx::dao::fetch_all(allAuthors);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               Here is an example to fetch all documents from <i>author</i> collection in MongoDB database (providing which fields/columns to fetch) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch all authors (with only 'date_creation' and 'name' properties)</span>
list_author allAuthors;
QStringList columns = QStringList() &lt;&lt; <span class="string">"date_creation"</span> &lt;&lt; <span class="string">"name"</span>;
daoError = qx::dao::fetch_all(allAuthors, NULL, columns);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> <a href="#manual_390">QxOrm library supports several C++ types to manage lists and collections</a>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_992">JSON queries</a></p>
         <div class="manual_div_content">
            The main difference between standard relational databases and MongoDB database is query format : instead of SQL, MongoDB provides a <a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank">JSON query engine</a>.
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9920">Using qx::QxSqlQuery class (or qx_query alias)</a></p>
            <div class="manual_div_content">
               <a href="#manual_3600">qx::QxSqlQuery class (or qx_query alias)</a> used to build standard SQL queries is also able to build JSON queries for MongoDB database.
               This class is based on <a href="https://fr.cppreference.com/w/cpp/utility/initializer_list" target="_blank">C++11 std::initializer_list feature</a> to write C++ queries like JSON queries (similar syntax).
               Please note that you can also write your JSON query with a string (if your compiler doesn't support <a href="https://fr.cppreference.com/w/cpp/utility/initializer_list" target="_blank">C++11 std::initializer_list feature</a> for example).
               For example :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch many authors by query (only female)</span>
list_author list_of_female_author;
qx_query query <font style="background-color:yellow">{ { <span class="string">"sex"</span>, author::female } }</font>;
daoError = qx::dao::fetch_by_query(query, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9921">Using MongoDB aggregation framework</a></p>
            <div class="manual_div_content">
               MongoDB database provides <a href="https://docs.mongodb.com/manual/aggregation/" target="_blank">a powerful aggregation framework</a> to build queries.
               Here is an example to call this MongoDB aggregation engine with <a href="#manual_3600">qx::QxSqlQuery class (or qx_query alias)</a>, the first constructor parameter must be equal to <i>aggregate</i> :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch by query using MongoDB aggregation framework (only female)</span>
list_author list_of_female_author;
qx_query queryAggregate(<font style="background-color:yellow"><span class="string">"aggregate"</span></font>,
               <span class="string">"[ { \"$match\" : { \"sex\" : " + QString::number(static_cast&lt;int&gt;(author::female)) + " } } ]"</span>);
daoError = qx::dao::fetch_by_query(queryAggregate, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9922">Add 'sort', 'limit', 'skip', etc..., properties to JSON query</a></p>
            <div class="manual_div_content">
               It is often required to limit data received from database, or to sort them.
               To manage these operations, MongoDB database provides <a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/" target="_blank">projection</a>.
               Here is an example of <i>projection</i> with <a href="#manual_3600">qx::QxSqlQuery class (or qx_query alias)</a>, see the <i>QStringList</i> constructor parameter (or second constructor parameter with <a href="https://fr.cppreference.com/w/cpp/utility/initializer_list" target="_blank">std::initializer_list</a>) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch by query (only female) adding 'sort', 'limit', 'skip', etc... commands (see second query QStringList parameter)</span>
list_of_female_author.clear();
qx_query queryOpts(QStringList() &lt;&lt; <span class="string">"{ \"sex\" : " + QString::number(static_cast<int>(author::female)) + " }"</span>
                              &lt;&lt; <font style="background-color:yellow"><span class="string">"{ \"sort\" : { \"sex\" : -1 }, \"limit\" : 2 }"</span></font>);
daoError = qx::dao::fetch_by_query(queryOpts, list_of_female_author);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9923">Execute a custom query</a></p>
            <div class="manual_div_content">
               To execute a custom query in MongoDB database, QxOrm library provides the <a href="#manual_3610">qx::dao::call_query() function</a>.
               Query results can be converted to <a href="http://doc.qt.io/qt-5/qvariant.html" target="_blank">QVariantMap or QList&lt;QVariantMap&gt;</a> (if query returns a cursor) to iterate over all database response.
               Here are some examples of custom queries :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Drop database</span>
qx_query dropDB(<span class="string">"{ \"dropDatabase\" : 1 }"</span>);
QSqlError daoError = qx::dao::call_query(dropDB);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom query and get JSON response as QVariantMap</span>
qx_query customQuery(<span class="string">"{ \"find\": \"author\", \"filter\": { } }"</span>);
daoError = qx::dao::call_query(customQuery); qAssert(! daoError.isValid());
QString responseCustomQuery = customQuery.response().toString();
QVariantMap responseCustomQueryAsJson;
qx::serialization::json::from_string(responseCustomQueryAsJson, responseCustomQuery);</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Call a custom query with cursor and get JSON response as QList&lt;QVariantMap&gt;</span>
qx_query customQueryCursor(<font style="background-color:yellow"><span class="string">"cursor"</span></font>, <span class="string">"{ \"find\": \"author\", \"filter\": { } }"</span>);
daoError = qx::dao::call_query(customQueryCursor); qAssert(! daoError.isValid());
QString responseCustomQueryCursor = customQueryCursor.response().toString();
QList&lt;QVariantMap&gt; responseCustomQueryCursorAsJson;
qx::serialization::json::from_string(responseCustomQueryCursorAsJson, responseCustomQueryCursor);</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_993">Relationships engine (MongoDB version 3.6 or + is required)</a></p>
         <div class="manual_div_content">
            <a href="#manual_380">QxOrm library relationship engine</a> supports MongoDB database (MongoDB version 3.6 or + is required).
            So QxOrm library is able to fetch Document fields over several Collections using only one query (similar to <i>JOINS</i> in SQL).
            <br/><br/>
            Here is an example to fetch a Document and 1 level of relationships (parent > children) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch blog with all relations : 'author', 'comment' and 'category' (MongoDB version 3.6+ is required for relationships)</span>
blog_ptr blog = std::make_shared&lt;blog&gt;();
blog->m_id = <span class="string">"id_blog_1"</span>;
daoError = qx::dao::fetch_by_id_with_all_relation(blog);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is an example to fetch a Document and 4 levels of relationships (using <i>*-&gt;*-&gt;*-&gt;*</i> syntax) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch blog with many relations using "*-&gt;*-&gt;*-&gt;*" (4 levels of relationships)</span>
blog_ptr blog = std::make_shared&lt;blog&gt;();
blog->m_id = <span class="string">"id_blog_1"</span>;
daoError = qx::dao::fetch_by_id_with_relation(<span class="string">"*-&gt;*-&gt;*-&gt;*"</span>, blog);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is an example to fetch a Document providing a list of relationships and fields to fetch (using <i>{ &lt;col_1&gt;, &lt;col_2&gt;, etc... }</i> syntax) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch relations defining fields to fetch with syntax { col_1, col_2, etc... }</span>
list_blog lstBlogComplexRelation;
QStringList relations = QStringList() &lt;&lt; <span class="string">"{ blog_text }"</span> &lt;&lt; <span class="string">"author_id { name, birthdate }"</span> &lt;&lt; <span class="string">"list_comment { comment_text } -&gt; blog_id -&gt; *"</span>;
daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is an example to fetch a Document providing a list of relationships and fields to not fetch (using <i>-{ &lt;col_1&gt;, &lt;col_2&gt;, etc... }</i> syntax) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Fetch relations defining columns to remove before fetching with syntax -{ col_1, col_2, etc... }</span>
list_blog lstBlogComplexRelation2;
QStringList relations = QStringList() &lt;&lt; <span class="string">"-{ blog_text }"</span> &lt;&lt; <span class="string">"author_id -{ name, birthdate }"</span> &lt;&lt; <span class="string">"list_comment -{ comment_text } -&gt; blog_id -&gt; *"</span>;
daoError = qx::dao::fetch_all_with_relation(relations, lstBlogComplexRelation2);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9930">Embedded vs Referenced</a></p>
            <div class="manual_div_content">
               One big advantage of MongoDB database is the possibility to store complex data structure (not limited by a 2 dimensions table/column structure like standard relational databases).
               A MongoDB Document can contain an objet and several sub-objects (hierarchy in Document structure).
               Include a sub-object in a Document has some advantages (no <i>JOIN</i> for example, so faster to fetch) and some disadvantages (a same object can be duplicated in database).
               So it is important to adopt the right strategy to store your data.
               <br/><br/>
               QxOrm library supports both :
               <ul>
                  <li><b>Embedded relationship</b> : the sub-object is included in the Document ;</li>
                  <li><b>Referenced relationship</b> : create a <i>JOIN</i> like standard relational databases.</li>
               </ul>
               <br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; void register_class(QxClass&lt;blog&gt; & t)
{
   t.id(& blog::m_id, <span class="string">"blog_id"</span>);

   t.data(& blog::m_text, <span class="string">"blog_text"</span>);
   t.data(& blog::m_dt_creation, <span class="string">"date_creation"</span>);
   <font style="background-color:yellow">t.data(& blog::m_categoryX, <span class="string">"list_category"</span>); <span class="comment">// Embedded relationship</span></font>

   <font style="background-color:yellow">t.relationManyToOne(& blog::m_author, <span class="string">"author_id"</span>); <span class="comment">// Referenced relationship</span></font>
   <font style="background-color:yellow">t.relationOneToMany(& blog::m_commentX, <span class="string">"list_comment"</span>, <span class="string">"blog_id"</span>); <span class="comment">// Referenced relationship</span></font>
}}</pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_994">Create automatically indexes</a></p>
         <div class="manual_div_content">
            QxOrm library provides a way to generate indexes automatically (this function should be called at the beginning of your program, for example in the <i>main</i>) :
            <ul>
               <li>all indexes to manage relationships between Collections (to optimize <i>JOINS</i>) ;</li>
               <li>all indexes defined by <a href="../doxygen/html/classqx_1_1_ix_data_member.html" target="_blank">qx::IxDataMember::setIndex()</a> method (in <i>qx::register_class()</i> function).</li>
            </ul>
            <br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// To optimize queries : create automatically indexes based on relationships and properties marked as 'index'</span>
daoError = qx::dao::mongodb::QxMongoDB_Helper::autoCreateIndexes(true);</pre>
            </td></tr></tbody></table>
            <br/><br/>
         </div>
         <br/><br/>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_96">HTTP/HTTPS web server (QxHttpServer module)</a></p>
      <div class="manual_div_content_1">
         QxOrm library provides a standalone, multi-threaded and easy to use HTTP 1.1 web server named <b>QxHttpServer module</b> (based on <a href="#manual_80">QxService module</a>).
         <b>QxHttpServer module</b> doesn't require any <a href="https://httpd.apache.org/" target="_blank">Apache</a> or <a href="https://nginx.org/en/" target="_blank">Nginx</a> installation.
         <br/><br/>
         <b>QxHttpServer module</b> supports several features :
         <ul>
            <li><a href="#manual_9961">SSL/TLS secured connections</a></li>
            <li><a href="#manual_997">Dynamic URL routing (dispatcher / define endpoints)</a></li>
            <li><a href="#manual_998">Sessions (server side storage per client)</a></li>
            <li><a href="#manual_999">Cookies</a></li>
            <li><a href="#manual_851">Manage static files</a></li>
            <li><a href="#manual_852">Chunked responses</a></li>
            <li><a href="#manual_853">JSON API requests (QxRestApi module)</a></li>
         </ul>
         Combined with <a href="#manual_97">QxRestApi module</a> (which provides a JSON API to request your persistent data layer), <b>QxHttpServer module</b> is designed to develop modern web applications.
         For example, <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank">SPA (<i>Single-Page Applications</i>)</a> web applications with famous Javascript frameworks like <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
         <br/><br/>
         <b>Note :</b> to enable <b>QxHttpServer</b> module, you have to define <font style="background-color:yellow"><b>_QX_ENABLE_QT_NETWORK</b></font> compilation option in <a href="#manual_220"><i>QxOrm.pri</i> (ou <i>QxOrm.cmake</i>) configuration file</a>.
         <b>_QX_ENABLE_QT_NETWORK</b> compilation option adds a dependency to <a href="http://doc.qt.io/qt-5/qtnetwork-index.html" target="_blank">QtNetwork</a> binary provided by Qt library.
         <br/><br/>
         <b>Other note :</b> QxOrm package contains a <a href="#manual_972">test project named <b><i>qxBlogRestApi</i></b></a>.
         This test project is a web application with several examples to request a persistent data layer from a web page (HTML and Javascript).
         <br/><br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_995">Hello World !</a></p>
         <div class="manual_div_content">
            Here is a HTTP web server source code based on <b>QxHttpServer module</b> (this web server just returns <i>Hello World !</i> to web client) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">#include</span> &lt;<span class="string">QtCore/qcoreapplication.h</span>&gt;
<span class="keyword">#include</span> &lt;<span class="string">QxOrm.h</span>&gt;

<span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char *</span> argv[])
{
   <span class="type">QCoreApplication</span> app(argc, argv);

   <span class="comment">// HTTP server settings</span>
   <span class="type">qx::service::QxConnect *</span> serverSettings = qx::service::QxConnect::getSingleton();
   serverSettings-&gt;setPort(<span class="int">9642</span>); <span class="comment">// HTTP server listening port</span>
   serverSettings-&gt;setKeepAlive(<span class="int">5000</span>); <span class="comment">// Keep-alive connection with client during 5s, then socket is disconnected and thread becomes available for other clients</span>
   serverSettings-&gt;setThreadCount(<span class="int">50</span>); <span class="comment">// Number of threads waiting for client's requests,</span>
                                                           <span class="comment">// which means also how many requests can be handled simultaneously (in parallel) by HTTP server</span>

   <span class="comment">// Create a QxOrm HTTP server instance</span>
   <span class="type">qx::QxHttpServer</span> httpServer;

   <span class="comment">// Define all HTTP server routes (dispatcher) to handle requests</span>
   <span class="comment">// Each callback is executed in a dedicated thread, so QxOrm HTTP server can handle several requests in parallel</span>
   httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
      response.data() = <span class="string">"Hello World !"</span>;
   });

   <span class="comment">// Start HTTP server</span>
   httpServer.startServer();

   <span class="comment">// Start event loop</span>
   return app.exec();
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Result :</b> open a web browser (Chrome, Firefox, Safari, Internet Explorer, Opera, etc...) and go to this URL : <u><b>http://localhost:9642/</b></u>. Your web browser should display :
            <br/><br/>
            <img alt="QxHttpServer Hello World !" src="./resource/qx_http_server_hello_world_01.png" border="0">
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_996">HTTP/HTTPS web server settings</a></p>
         <div class="manual_div_content">
            HTTP web server settings are available with <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class :
            <ul>
               <li><i>setPort()</i> : web server listening port (default web server port is 80 but you can define what you want) ;</li>
               <li><i>setThreadCount()</i> : number of threads used by web server to handle HTTP requests (which means number of simultaneous clients managed by web server) ;</li>
               <li><i>setMaxWait()</i> : timeout in milli-seconds (for example to read/write on socket), -1 value means no timeout ;</li>
               <li><i>setCompressData()</i> : if HTTP client supports GZIP compression, then text responses (HTML / Javascript / CSS files, JSON stream, etc...) will be compressed as GZIP ;</li>
               <li><i>setKeepAlive()</i> : socket stay connected to client during <i>X</i> milli-seconds, -1 value means never disconnect ;</li>
               <li><i>setSessionTimeOut()</i> : timeout in milli-seconds before deleting unused <a href="#manual_998">sessions (server side storage per client)</a>.</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9961">Secured connections SSL/TLS</a></p>
            <div class="manual_div_content">
               <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class provides also some parameters to manage HTTPS secured connections (SSL and/or TLS).<br/>
               Here is a secured connection settings example with server certificate and CA certificate authority (you can test this code with <a href="#manual_972"><b><i>qxBlogRestApi</i> project example</b></a>) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="comment">// Certificates created with this tutorial : https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/</span>
QFile::copy(<span class="string">":/documents/cert_qxorm_ca.pem"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_ca.pem"</span>));
QFile::copy(<span class="string">":/documents/cert_qxorm_server.crt"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_server.crt"</span>));
QFile::copy(<span class="string">":/documents/cert_qxorm_server.key"</span>, appPath.filePath(<span class="string">"files/cert_qxorm_server.key"</span>));

<span class="type">QFile</span> fileCertCA(appPath.filePath(<span class="string">"files/cert_qxorm_ca.pem"</span>));
fileCertCA.open(QIODevice::ReadOnly);
<span class="type">QList&lt;QSslCertificate&gt;</span> certCA; certCA &lt;&lt; QSslCertificate(fileCertCA.readAll());

<span class="type">QFile</span> fileCertServerPublic(appPath.filePath(<span class="string">"files/cert_qxorm_server.crt"</span>));
fileCertServerPublic.open(QIODevice::ReadOnly);
<span class="type">QSslCertificate</span> certServerPublic(fileCertServerPublic.readAll());

<span class="type">QFile</span> fileCertServerPrivate(appPath.filePath(<span class="string">"files/cert_qxorm_server.key"</span>));
fileCertServerPrivate.open(QIODevice::ReadOnly);
<span class="type">QSslKey</span> certServerPrivate(fileCertServerPrivate.readAll(), QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey, "qxorm");

<span class="type">qx::service::QxConnect *</span> serverSettings = qx::service::QxConnect::getSingleton();
serverSettings-&gt;setSSLEnabled(true);
serverSettings-&gt;setSSLCACertificates(certCA);
serverSettings-&gt;setSSLLocalCertificate(certServerPublic);
serverSettings-&gt;setSSLPrivateKey(certServerPrivate);
</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> by default, all SSL errors are ignored (often certificates errors).
               To manage your own security level, you can use following functions (from <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect</a> singleton class) :
               <ul>
                  <li><i>setSSLIgnoreErrors(QList&lt;QSslError&gt; lst) :</i> list of SSL errors to ignore (by default all errors are ignored), see <a href="https://doc.qt.io/Qt-5/qsslerror.html" target="_blank">QSslError Qt class</a> ;</li>
                  <li><i>setSSLPeerVerifyName(const QString & s) :</i> see <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">QSslSocket Qt class</a> for more details ;</li>
                  <li><i>setSSLPeerVerifyMode(QSslSocket::PeerVerifyMode e) :</i> see <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">QSslSocket Qt class</a> for more details ;</li>
                  <li><i>setSSLPeerVerifyDepth(int i) :</i> see <a href="https://doc.qt.io/qt-5/qsslsocket.html" target="_blank">QSslSocket Qt class</a> for more details ;</li>
                  <li><i>setSSLConfiguration(QSslConfiguration cfg) :</i> see <a href="https://doc.qt.io/qt-5/qsslconfiguration.html" target="_blank">QSslConfiguration Qt class</a> for more details ;</li>
                  <li><i>setSSLProtocol(QSsl::SslProtocol e) :</i> see <a href="https://doc.qt.io/qt-5/qssl.html#SslProtocol-enum" target="_blank">list of SSL and TLS protocols in Qt documentation</a>.</li>
               </ul>
               <br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_997">Routing URL (dispatcher / endpoints)</a></p>
         <div class="manual_div_content">
            <b>QxHttpServer module</b> provides an URL routing engine (<i>dispatcher</i>) to define functions (or lambda) to execute based on HTTP request parameters (HTTP method <i>GET, POST, DELETE, etc...</i> + URL).<br/>
            Functions (or lambda) must be defined with this signature : <font style="background-color:yellow"><b>void myRequestHandler(qx::QxHttpRequest & request, qx::QxHttpResponse & response);</b></font>
            <br/><br/>
            <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a> alias) has following methods :
            <ul>
               <li><i>setCustomRequestHandler()</i> : define a function (or lambda) executed if dispatcher doesn't find any other matched function ;</li>
               <li><i>dispatch()</i> : first parameter is HTTP method (<i>GET, POST, DELETE, etc...</i>), second parameter is requested URL (or its pattern), third parameter is function (or lambda) to execute ;</li>
               <li><i>beforeDispatching()</i> : function (or lambda) executed before handling HTTP request (can be used for example to log, or to manage an authentication process) ;</li>
               <li><i>afterDispatching()</i> : function (or lambda) executed after handling HTTP request (can be used for example to log) ;</li>
               <li><i>clearDispatcher()</i> : remove all routing rules from dispatcher (only function or lambda defined by <i>setCustomRequestHandler()</i> will be executed).</li>
            </ul>
            <b>Note :</b> dispatcher is thread-safe, so you can define URL routing rules even if web server is running.
            <br/><br/>
            <b>Other note :</b> each function (or lambda) is <font style="background-color:yellow"><b>executed in its own thread</b></font>.
            So QxOrm library HTTP web server can handle several HTTP requests simultaneously.
            <br/><br/>
            <b>Example n°1 :</b> this routing rule handles all HTTP requests with method <i>GET</i> + URL starts with <i>/files/</i>, and returns a static file content stored on server (<i>QDir::currentPath()</i> is static files root directory, and <i>5000</i> is chunked response size, this last parameter is optional) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/files/*"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   qx::QxHttpServer::buildResponseStaticFile(request, response, QDir::currentPath(), <span class="int">5000</span>);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Example n°2 :</b> this routing rule handles all HTTP requests with method <i>POST</i> + URL is <i>/qx</i>, and calls <a href="#manual_97">QxRestApi module</a> (which provides a JSON API to request persistent data layer).
            Example n°1 (<i>static files</i>) and example n°2 (<i>QxRestApi module</i>) are a good starting point to develop a SPA (<i>Single-Page Applications</i>) web application with famous Javascript frameworks like <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"POST"</span>, <span class="string">"/qx"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   qx::QxHttpServer::buildResponseQxRestApi(request, response);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Example n°3 :</b> this routing rule handles all HTTP requests with method <i>GET</i> + URL is <i>/test_big_json</i>, and builds a JSON response with an array of 10000 items :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/test_big_json"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <span class="comment">// To compare with this benchmark : https://blog.binaryspaceship.com/2017/cpp-rest-api-frameworks-benchmark/</span>
   <span class="comment">// This is more a JSON benchmark than HTTP server benchmark (RapidJSON is faster than Qt QJson engine)</span>
   QJsonArray arr; Q_UNUSED(request);
   for (int i = 0; i &lt; 10000; ++i)
   {
      QJsonObject item;
      item.insert(<span class="string">"id"</span>, QString::number(i));
      item.insert(<span class="string">"name"</span>, QString("Hello World"));
      item.insert(<span class="string">"type"</span>, QString("application"));
      arr.append(item);
   }
   QJsonDocument doc(arr);
   response.headers().insert(<span class="string">"Content-Type"</span>, <span class="string">"application/json; charset=utf-8"</span>);
   response.data() = doc.toJson(QJsonDocument::Compact);
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Note :</b> <font style="background-color:yellow"><i>dispatch()</i> order is very important</font>.
            The first item found by the dispatcher which matches requested URL is executed (all other dispatcher items are ignored).
            So you have to define first the most specific URL, and you have to define last the most generic URL (for example, pattern <i>/*</i> matches all URLs, so this is the most generic dispatcher item).
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9962">Dynamic URL routing</a></p>
            <div class="manual_div_content">
               <b>QxHttpServer dispatcher</b> supports dynamic URL routing.<br/>
               You can define some variables inside URL pattern with this syntax : <font style="background-color:yellow"><i>&lt;var_name:var_type&gt;</i></font> (<i>var_type</i> is optional, and can be equal to : <i>int, long, float, double, string</i>).
               <br/><br/>
               Dynamic URL routing is useful to define REST API.<br/>
               For example, <i>/blog/&lt;blog_id:int&gt;</i> pattern + <i>GET</i> HTTP method can be used to fetch a blog based on its numeric unique identifier (<i>fetch_by_id</i>).
               <br/><br/>
               URL is a list of segments splitted by character <i>/</i>.<br/>
               <b>QxHttpServer dispatcher</b> checks each segment from requested URL : if all segments match the pattern, then the function (or lambda) is executed.<br/>
               To get dynamic variables values from URL, you must write : <font style="background-color:yellow"><i>request.dispatchParams().value("var_name")</i></font> (which returns a <i>QVariant</i>).
               <br/><br/>
               <b>Example :</b> this routing rule handles all HTTP requests with method <i>GET</i> + URL starts with <i>/params/</i>, followed by a segment which will contain the value of <i>var1</i> variable, followed by a <b><i>numeric</i></b> segment which will contain the value of <i>var2</i> variable.
               The lambda returns a HTTP response which displays the values of <i>var1</i> and <i>var2</i> variables from URL.
               If the web browser calls <i>/params/abc/123/</i> URL then the function (or lambda) will be executed, <b>BUT</b> if the web browser calls <i>/params/abc/def/</i> URL then the function (or lambda) won't be executed (because <i>def</i> is not numeric) and dispatcher will search another item to execute :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <font style="background-color:yellow"><span class="string">"/params/&lt;var1&gt;/&lt;var2:int&gt;"</span></font>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   response.data() = <span class="string">"Test URL dispatch parameters :\r\n"</span>;
   response.data() += <span class="string">" - var1 = "</span> + request.dispatchParams().value(<span class="string">"var1"</span>).toByteArray() + <span class="string">"\r\n"</span>;
   response.data() += <span class="string">" - var2 = "</span> + request.dispatchParams().value(<span class="string">"var2"</span>).toByteArray() + <span class="string">"\r\n"</span>;
});</pre>
               </td></tr></tbody></table>
               <br/><br/>
               <b>Note :</b> you can also define a regular expression to route URLs with this syntax : <font style="background-color:yellow"><i>&lt;var_name:{my_reg_exp}&gt;</i></font>.
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_856">Get HTTP request parameters</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/classqx_1_1_qx_http_request.html" target="_blank"><i>qx::QxHttpRequest</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_request.html" target="_blank"><i>qx_http_request</i></a> alias) contains all HTTP request parameters :
            <ul>
               <li><i>QUrl & url() :</i> web browser requested URL ;</li>
               <li><i>QString & command() :</i> HTTP method (<i>GET, POST, PUT, DELETE, etc...</i>) ;</li>
               <li><i>QString & version() :</i> HTTP version provided by web browser (for example <i>HTTP/1.1</i>) ;</li>
               <li><i>QByteArray & data() :</i> HTTP request content ;</li>
               <li><i>QByteArray header(const QByteArray & key) :</i> get a HTTP header value provided by web browser (for example : <i>request.header("Accept-Encoding")</i>) ;</li>
               <li><i>QxHttpCookie cookie(const QByteArray & name) :</i> get a <a href="#manual_999">HTTP cookie</a> provided by web browser ;</li>
               <li><i>QString param(const QString & key) :</i> get a HTTP parameter value (from URL, or from HTTP request content if <i>'content-type'</i> is <i>'application/x-www-form-urlencoded'</i>) ;</li>
               <li><i>QHash&lt;QString, QVariant&gt; & dispatchParams() :</i> list of URL dynamic parameters computed by <a href="#manual_9962">dispatcher (routing engine)</a> ;</li>
               <li><i>QString & sourceAddress() :</i> IP address of client web browser ;</li>
               <li><i>long & sourcePort() :</i> port used by client web browser ;</li>
               <li><i>QString guid() :</i> internal HTTP request unique identifier (can be used to log for example).</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_857">Build HTTP response</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/classqx_1_1_qx_http_response.html" target="_blank"><i>qx::QxHttpResponse</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_response.html" target="_blank"><i>qx_http_response</i></a> alias) is used to build HTTP response :
            <ul>
               <li><i>int & status() :</i> HTTP response code (by default 200 which means OK) ;</li>
               <li><i>QByteArray & data() :</i> HTTP response content ;</li>
               <li><i>QByteArray header(const QByteArray & key) :</i> send a HTTP header to web browser (by default, some headers are created automatically : <i>Server</i>, <i>Date</i>, <i>Content-Type</i> and <i>Connection</i>) ;</li>
               <li><i>QxHttpCookie cookie(const QByteArray & name) :</i> send a <a href="#manual_999">HTTP cookie</a> to web browser ;</li>
               <li><i>qx_bool writeChunked(const QByteArray & data) :</i> can be used to send <a href="#manual_852">chunked responses</a>.</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_998">Sessions (storage per client on server side)</a></p>
         <div class="manual_div_content">
            HTTP sessions are a way to store some data related to a client on server side.
            Session data are available for each client's requests (until session is expired).
            The first time server access to a client's session, a <a href="#manual_999">HTTP cookie</a> with a unique identifier is generated and attached to HTTP response.
            Then all HTTP requests sent by client web browser will contain automatically a <a href="#manual_999">HTTP cookie</a> with the same unique identifier.
            When a session is unused and expired, then it is deleted automatically.
            <br/><br/>
            <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx::QxHttpSession</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx_http_session</i></a> alias) is a HTTP session on server side.<br/>
            <a href="../doxygen/html/classqx_1_1_qx_http_session_manager.html" target="_blank">qx::QxHttpSessionManager</a> singleton class must be used to access to a session :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <span class="comment">// If this is the first time to access to session, then a cookie is created automatically and attached to the response</span>
   <span class="comment">// Then each request sent by web browser will contain a cookie with the session id</span>
   <span class="comment">// The session expires on server side after qx::service::QxConnect::setSessionTimeOut() milliseconds</span>
   <font style="background-color:yellow">qx::QxHttpSession_ptr session = qx::QxHttpSessionManager::getSession(request, response);</font>
   if (session) { session-&gt;set(<span class="string">"last_request_per_user"</span>, QDateTime::currentDateTime()); }
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Note :</b> <a href="../doxygen/html/classqx_1_1_qx_http_session.html" target="_blank"><i>qx::QxHttpSession</i></a> class contains a hash-map (<i>QHash&lt;QByteArray, QVariant&gt;</i>) to store any values related to a client.
            <br/><br/>
            <b>Other note :</b> <a href="../doxygen/html/classqx_1_1service_1_1_qx_connect.html" target="_blank">qx::service::QxConnect::setSessionTimeOut()</a> method can be used to define a timeout (in milli-seconds) to delete unused sessions.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_999">Cookies</a></p>
         <div class="manual_div_content">
            <a href="https://en.wikipedia.org/wiki/HTTP_cookie" target="_blank">From Wikipedia website :</a> an HTTP cookie (also called web cookie, Internet cookie, browser cookie, or simply cookie) is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing.
            Cookies were designed to be a reliable mechanism for websites to remember stateful information (such as items added in the shopping cart in an online store) or to record the user's browsing activity (including clicking particular buttons, logging in, or recording which pages were visited in the past).
            <br/><br/>
            <a href="#manual_856">qx::QxHttpRequest</a> and <a href="#manual_857">qx::QxHttpResponse</a> classes provide the method <b><i>cookies()</i></b> to get cookies sent by web browser or generate some cookies in HTTP response.
            For example :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="type">qx::QxHttpCookie</span> cookie;
cookie.name = <span class="string">"my_http_cookie"</span>;
cookie.value = <span class="string">"my_value"</span>;
response.cookies().insert(cookie.name, cookie);</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Note : </b> an HTTP cookie is added automatically to HTTP response when accessing for the first time to a <a href="#manual_999">session (server side storage per client)</a>.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_851">Static files</a></p>
         <div class="manual_div_content">
            <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a> alias) provides a static method to send to client web browser a file content stored on server side (for example : HTML, Javascript, CSS, PNG, JPEG, videos, etc...).
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"GET"</span>, <span class="string">"/files/*"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <font style="background-color:yellow">qx::QxHttpServer::buildResponseStaticFile(request, response, QDir::currentPath(), 5000);</font>
});</pre>
            </td></tr></tbody></table>
            <br/>
            <ul>
               <li>The third parameter (<i>QDir::currentPath()</i> in the example) defines the root directory where files are stored on the server ;</li>
               <li>The fourth parameter (<i>5000</i> in the example) is optional and defines <a href="#manual_852">chunked response size</a>. This parameter can be useful to send big files (streaming).</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_852">Chunked responses</a></p>
         <div class="manual_div_content">
            <a href="https://en.wikipedia.org/wiki/Chunked_transfer_encoding" target="_blank">From Wikipedia website :</a> Chunked transfer encoding is a streaming data transfer mechanism available in version 1.1 of the Hypertext Transfer Protocol (HTTP).
            In chunked transfer encoding, the data stream is divided into a series of non-overlapping "chunks".
            The chunks are sent out and received independently of one another.
            No knowledge of the data stream outside the currently-being-processed chunk is necessary for both the sender and the receiver at any given time.
            Each chunk is preceded by its size in bytes.
            The transmission ends when a zero-length chunk is received.
            The chunked keyword in the Transfer-Encoding header is used to indicate chunked transfer.
            <br/><br/>
            The introduction of chunked encoding in HTTP 1.1 provided various benefits :
            <ul>
               <li>Chunked transfer encoding allows a server to maintain an HTTP persistent connection for dynamically generated content.</li>
               <li>Chunked encoding allows the sender to send additional header fields after the message body. This is important in cases where values of a field cannot be known until the content has been produced, such as when the content of the message must be digitally signed.</li>
            </ul>
            <br/>
            <a href="#manual_857">qx::QxHttpResponse</a> class provides the <i>qx_bool writeChunked(const QByteArray & data)</i> method to send chunked response.
            It is used for example <a href="#manual_851">to send big static files (streaming)</a> :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">while</span> (! file.atEnd())
{
   <span class="keyword">if</span> (! <font style="background-color:yellow">response.writeChunked(file.read(chunkedSize))</font>) { <span class="keyword">return</span>; }
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            <b>Note :</b> the first <i>response.writeChunked()</i> call sends automatically all HTTP response headers.
            So you have to define all HTTP response headers before calling <i>response.writeChunked()</i>.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_853">Requests using JSON API (QxRestApi module)</a></p>
         <div class="manual_div_content">
            <a href="#manual_97">QxRestApi module</a> provides a generic JSON API to request your persistent data layer (CRUD operations, complex queries, several levels of relationships, custom JSON output format, call dynamically native C++ functions registered in QxOrm context, instance validation, call custom database queries).
            <br/><br/>
            This user manual has a full chapter dedicated to <a href="#manual_97">QxRestApi module</a> : it contains several examples to request persistent data layer.
            Combining <a href="#manual_97">QxRestApi module</a> and <b>QxHttpServer module</b> : you have all tools to develop modern web applications.
            For example, <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank">SPA (<i>Single-Page Applications</i>)</a> web applications with famous Javascript frameworks like <a href="https://angularjs.org/" target="_blank">AngularJS</a>, <a href="https://reactjs.org/" target="_blank">React</a>, <a href="https://www.meteor.com/" target="_blank">Meteor.js</a>, etc...
            <br/><br/>
            <b>Note :</b> QxOrm package provides a <a href="#manual_972">test project named <b><i>qxBlogRestApi</i></b></a>.
            This project includes a HTTP web server developed with QxOrm library, and a client source code developed with HTML + Javascript (with <a href="https://jquery.com/" target="_blank">jQuery</a>).
            <br/><br/>
            For example, here is the Javascript function used to send JSON requests (POST method) from client web browser to QxOrm HTTP web server (all requests are sent to the same URL <i>/qx</i>) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">function</span> sendRequest(request) {
   <font style="background-color:yellow">$.post(<span class="string">"/qx"</span>, request</font>, function(data, status, xhr) {
      $(<span class="string">"#txtResponse"</span>).val(JSON.stringify(data, null, 3));
   }, <span class="string">"json"</span>).fail(function(error) {
      alert(<span class="string">"An error occurred sending request to QxOrm HTTP server : "</span> + error);
   });
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            On server side, handling these requests is very easy : <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a> alias) provides the <b>qx::QxHttpServer::buildResponseQxRestApi()</b> static method :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>httpServer.dispatch(<span class="string">"POST"</span>, <span class="string">"/qx"</span>, [](qx::QxHttpRequest & request, qx::QxHttpResponse & response) {
   <font style="background-color:yellow">qx::QxHttpServer::buildResponseQxRestApi(request, response);</font>
});</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is a JSON request example sent by client web browser to get the list of all blogs stored in database (<i>fetch_all</i>) :
            <br/><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "2b393e4c-a00c-45dc-a279-e9d76f1c55cf",
   "action": "fetch_all",
   "entity": "blog"
}</pre>
            </div>
            <br/><br/>
            Here is the JSON response with the list of all blogs :
            <br/><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-03-27T20:51:23.107",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "2b393e4c-a00c-45dc-a279-e9d76f1c55cf"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_854">WebSocket</a></p>
         <div class="manual_div_content">
            <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank">From Wikipedia website :</a> WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection.
            The WebSocket protocol enables interaction between a web browser (or other client application) and a web server with lower overheads, facilitating real-time data transfer from and to the server.
            This is made possible by providing a standardized way for the server to send content to the client without being first requested by the client, and allowing messages to be passed back and forth while keeping the connection open.
            In this way, a two-way ongoing conversation can take place between the client and the server.
            <br/><br/>
            QxOrm library is based on Qt framework which already provides a <a href="https://doc.qt.io/qt-5/qtwebsockets-index.html" target="_blank">WebSocket implementation</a>.<br/>
            Create a web server with Qt WebSocket is very easy : <a href="https://doc.qt.io/qt-5/echoserver.html" target="_blank">there are several examples in Qt documentation</a>.
            <br/><br/>
            So you can implement a web server like this :
            <ul>
               <li>a listening port for HTTP connections (using <b>QxHttpServer module</b>) ;</li>
               <li>another listening port for WebSocket connections (using <a href="https://doc.qt.io/qt-5/qtwebsockets-index.html" target="_blank">QtWebSockets</a> module provided by Qt).</li>
            </ul>
            <br/>
            <b>Note :</b> a WebSocket connection is often created in Javascript code from client web browser, so having 2 listening ports (1 for HTTP, and another for WebSocket) is not a problem.
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_855">Performance (tested with Apache Benchmark)</a></p>
         <div class="manual_div_content">
            Here is a performance test result with following parameters :
            <ul>
               <li>Operating System (OS) : <i>Windows 2010 64bits</i> ;</li>
               <li>CPU : <i>Intel Core i7-6820HQ @ 2.70GHz</i> (laptop) ;</li>
               <li>Qt version : <i>5.1.1</i> (release mode) ;</li>
               <li>QxOrm version : <i>1.4.6</i> (built in release mode with Visual Studio 2012, default parameters, no specific optimization) ;</li>
               <li>HTTP web server : <a href="#manual_972"><i>qxBlogRestApi</i> test project</a> ;</li>
               <li>Tool to execute the test : <a href="https://httpd.apache.org/docs/2.4/programs/ab.html" target="_blank">Apache Benchmark</a> ;</li>
               <li>Simulate 20000 requests with 50 concurrents connections simultaneously : <i><b>ab -n 20000 -c 50 -k http://localhost:9642/params/abc/123</b></i></li>
            </ul>
            <br/>
            Test results show that QxOrm HTTP web server can handle <font style="background-color:yellow">more than 12000 requests per second</font> :
            <br/><br/>
            <img alt="QxHttpServer performance" src="./resource/qx_http_server_apache_bench_test_01.png" border="0">
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_8550">Improve performance with epoll dispatcher on Linux</a></p>
            <div class="manual_div_content">
               On Linux, you can improve HTTP web server performance using <a href="https://en.wikipedia.org/wiki/Epoll" target="_blank">epoll</a> to manage your sockets.
               By default, Qt framework is based on a slower process (<i>select</i>), but a method exists to define another event loop and dispatcher.
               Several libraries are available, for example :
               <ul>
                  <li><a href="https://github.com/sjinks/qt_eventdispatcher_epoll" target="_blank">qt_eventdispatcher_epoll</a></li>
                  <li><a href="https://github.com/connectedtable/qeventdispatcher_epoll" target="_blank">qeventdispatcher_epoll</a></li>
               </ul>
               <br/>
               <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx::QxHttpServer</i></a> class (or its <a href="../doxygen/html/classqx_1_1_qx_http_server.html" target="_blank"><i>qx_http_server</i></a> alias) provides a method to define a custom epoll event dispatcher (you must call it before running the QxOrm HTTP web server) :
               <br/><br/>
               <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre>   httpServer.setEventDispatcher(new QEventDispatcherEpoll());   </pre>
               </td></tr></tbody></table>
               <br/><br/>
            </div>
         </div>
      </div>

      <p class="manual_p_title_1"><a class="manual_a_title_1" name="manual_97">JSON REST API (QxRestApi module)</a></p>
      <div class="manual_div_content_1">
         <b>QxRestApi module</b> is a JSON API to manage (in a generic way) your persistent data layer (database) or <a href="#manual_961">call C++ native functions</a> (registered in QxOrm context).
         <b>QxRestApi module</b> is based on a request/response mechanism : send a request in JSON format and receive a response in JSON format.
         <b>QxRestApi module</b> can be used for example to develop <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">REST services</a>.
         <br/><br/>
         <b>QxRestApi module</b> supports following features :
         <ul>
            <li>CRUD operations ;</li>
            <li>complex queries with several levels of relationships ;</li>
            <li>custom JSON output format ;</li>
            <li>call dynamically C++ native functions registered in QxOrm context ;</li>
            <li>instance validation ;</li>
            <li>call custom database queries or stored procedures.</li>
         </ul>
         <br/>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_971">How it works</a></p>
         <div class="manual_div_content">
            <b>QxRestApi module</b> is very easy to use : <a href="../doxygen/html/classqx_1_1_qx_rest_api.html" target="_blank"><i>qx::QxRestApi</i></a> class has only 1 main method : <i><b>processRequest()</b></i>.<br/>
            <b>Prerequisites :</b> all classes registered into QxOrm context <font style="background-color:yellow"><a href="#manual_450">must implement <b>qx::IxPersistable</b> interface</a></font>.
            <br/><br/>
            A JSON query contains following properties :
            <br/><br/>
            <div style="width: 1000px; max-height: 300px; overflow: auto; background-color: white;">
<pre>{
   <span class="string">"request_id"</span> : <span class="comment">// [optional] unique identifier generated by client to associate response to request (if provided by caller, then the response will contain the same unique identifier)</span>
   <span class="string">"action"</span> : <span class="comment">// [required] what is the action to execute on the server</span>
   <span class="string">"entity"</span> : <span class="comment">// [optional or required depending on action] C++ class registered in QxOrm context</span>
   <span class="string">"data"</span> : <span class="comment">// [optional or required depending on action] data in JSON format needed to execute action</span>
   <span class="string">"columns"</span> : <span class="comment">// [optional] list of columns to fetch or update (if empty, means all columns)</span>
   <span class="string">"relations"</span> : <span class="comment">// [optional] list of relationships to fetch or save</span>
   <span class="string">"query"</span> : <span class="comment">// [optional or required depending on action] query to execute on database</span>
   <span class="string">"output_format"</span> : <span class="comment">// [optional] output fields for the response (filter), if empty then response will contain all fields</span>
   <span class="string">"fct"</span> : <span class="comment">// [required only with action 'call_entity_function'] used to call C++ native functions</span>
   <span class="string">"save_mode"</span> : <span class="comment">// [optional] used only with action 'save' to define insert or update or check both insert/update</span>
}</pre>
            </div>
            <br/><br/>
            A JSON response contains following properties :
            <br/><br/>
            <div style="width: 1000px; max-height: 300px; overflow: auto; background-color: white;">
<pre>{
   <span class="string">"request_id"</span> : <span class="comment">// unique identifier generated by client's request (if any)</span>
   <span class="string">"data"</span> : <span class="comment">// contain the response data</span>
   <span class="string">"error"</span> : <span class="comment">// if an error occured, then contain a code and description of the error</span>
}</pre>
            </div>
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9710">Use cases</a></p>
            <div class="manual_div_content">
               Several programming languages support natively JSON format (Javascript, PHP, Python, etc...).
               <b>QxRestApi module</b> provides an interoperability between QxOrm library and any other applications developed with another technology (not C++/Qt for example).
               <br/><br/>
               <b>QxRestApi module</b> can be useful for :
               <ul>
                  <li>Develop an HTTP web server (with <a href="#manual_96">QxHttpServer module</a> for example) ;</li>
                  <li>Publish <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">REST web-services</a> ;</li>
                  <li>Access to your persistent data layer from a QML application (see <a href="#manual_972">qxBlogRestApi test project</a>) ;</li>
                  <li>Possibility to script your C++ application (with Python for example).</li>
               </ul>
               <br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_972">qxBlogRestApi example project (QML and HTTP web server)</a></p>
         <div class="manual_div_content">
            QxOrm package contains a test project named <b>qxBlogRestApi</b> (in <i>./test/qxBlogRestApi/</i> directory).<br/>
            This test project shows 2 ways to work with <b>QxRestApi module</b> :
            <ul>
               <li>The first screen is a <font style="background-color:yellow">QML application</font> which uses embedded QML Javascript engine to request a persistent data layer or call C++ native functions :
               <br/><br/><img alt="QxHttpServer performance" src="./resource/qx_blog_rest_api_qml_01.png" border="0"><br/><br/><br/></li>
               <li>The second screen runs an <font style="background-color:yellow">HTTP web server</font> based on <a href="#manual_96">QxHttpServer module</a>, then opens default web browser (to load HTML + Javascript with <a href="https://jquery.com/" target="_blank">jQuery</a>) :
               <br/><br/><img alt="QxHttpServer performance" src="./resource/qx_blog_rest_api_http_01.png" border="0"><br/></li>
            </ul>
            <br/>
            These 2 windows are developed with different programming languages (QML versus HTML + Javascript), but provide exactly same features :
            <ul>
               <li>On top-left position : a text area to write a JSON request to send to <b>QxRestApi module</b> ;</li>
               <li>Just below the JSON request text area : a button to send JSON request to <b>QxRestApi module</b> ;</li>
               <li>On bottom-left position : a list of pre-loaded JSON requests examples (a click on this list fills automatically the JSON request text area) ;</li>
               <li>On right side : a JSON response text area received from <b>QxRestApi module</b> (after executing a JSON request).</li>
            </ul>
            <br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_973">Fetch</a></p>
         <div class="manual_div_content">
            This chapter provides several ways to get data from database (fetch) :
            <ul>
               <li>Fetch all items from a table and <a href="#manual_3840">their relationships</a> (<a href="#manual_9731">fetch_all</a>) ;</li>
               <li>Fetch an item from a table based on its unique identifier (<a href="#manual_9732">fetch_by_id</a>) ;</li>
               <li>Fetch some items from a table <a href="#manual_360">filtered by a query</a> (<a href="#manual_9733">fetch_by_query</a>) ;</li>
               <li>Count items in a table with or without a query (<a href="#manual_9734">count</a>) ;</li>
               <li>Test if an item exists in database based on its unique identifier (<a href="#manual_9735">exist</a>).</li>
            </ul>
            <br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9731">fetch_all</a></p>
            <div class="manual_div_content">
               The <b><i>fetch_all</i></b> action gets all items from a table in database (and eventually <a href="#manual_3840">several levels of relationships</a>).
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> fetch all blogs (as list format) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "5e988bac-c812-4cb1-b0d8-6a2c9dc4478b",
   "action": "fetch_all",
   "entity": "blog"
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "5e988bac-c812-4cb1-b0d8-6a2c9dc4478b"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> fetch all blogs (as <i>hash-map</i> with key/value format) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "ad400135-19fd-40e0-8034-201be6a2ff7a",
   "action": "fetch_all",
   "entity": "blog",
   "data": [
      {
         "key": "",
         "value": ""
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "key": 1,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 1,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 2,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 2,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 3,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 3,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      },
      {
         "key": 4,
         "value": {
            "author_id": {
               "author_id": "author_id_2",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 4,
            "blog_text": "blog property 'text' modified => blog is dirty !!!",
            "date_creation": "2019-04-01T16:18:54",
            "list_category": [],
            "list_comment": []
         }
      }
   ],
   "request_id": "ad400135-19fd-40e0-8034-201be6a2ff7a"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°3 --</b></font> fetch all blogs and <a href="#manual_3840">2 levels of relationships</a> :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "cf9ea2a8-3e41-438f-9a48-bbc8593d2b99",
   "action": "fetch_all",
   "entity": "blog",
   "relations": [
      "*-&gt;*"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 1,
               "value": {
                  "category_id": 1,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 1,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 1,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 3,
               "value": {
                  "category_id": 3,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 1,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 1,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": [
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 1,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 3,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 5,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 7,
               "comment_text": "comment_1 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 2,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 4,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 6,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               "comment_id": 8,
               "comment_text": "comment_2 text",
               "date_creation": "2019-04-01T16:18:54"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 4,
               "value": {
                  "category_id": 4,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 2,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 2,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 5,
               "value": {
                  "category_id": 5,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 2,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 2,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 6,
               "value": {
                  "category_id": 6,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 3,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 3,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 7,
               "value": {
                  "category_id": 7,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 3,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 3,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "list_blog": [
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 2,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 3,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               },
               {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": null,
                     "list_blog": [],
                     "name": "",
                     "sex": 2
                  },
                  "blog_id": 4,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [],
                  "list_comment": []
               }
            ],
            "name": "author name modified at index 1 => container is dirty !!!",
            "sex": 1
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [
            {
               "key": 8,
               "value": {
                  "category_id": 8,
                  "description": "desc_1",
                  "list_blog": [
                     {
                        "key": 4,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 4,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_1"
               }
            },
            {
               "key": 9,
               "value": {
                  "category_id": 9,
                  "description": "desc_3",
                  "list_blog": [
                     {
                        "key": 4,
                        "value": {
                           "author_id": {
                              "author_id": "author_id_2",
                              "birthdate": null,
                              "list_blog": [],
                              "name": "",
                              "sex": 2
                           },
                           "blog_id": 4,
                           "blog_text": "blog property 'text' modified => blog is dirty !!!",
                           "date_creation": "2019-04-01T16:18:54",
                           "list_category": [],
                           "list_comment": []
                        }
                     }
                  ],
                  "name": "category_3"
               }
            }
         ],
         "list_comment": []
      }
   ],
   "request_id": "cf9ea2a8-3e41-438f-9a48-bbc8593d2b99"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°4 --</b></font> fetch all blogs and <a href="#manual_3840">some relationships</a> + define an output JSON format (all properties will not be exported to JSON response) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "4c45fdf9-8001-4509-bb4b-ce27a4a8708a",
   "action": "fetch_all",
   "entity": "blog",
   "relations": [
      "&lt;blog_alias&gt; { blog_text }",
      "author_id &lt;author_alias&gt; { name, birthdate }",
      "list_comment &lt;list_comment_alias&gt; { comment_text } -&gt; blog_id &lt;blog_alias_2&gt; -&gt; * &lt;..._my_alias_suffix&gt;"
   ],
   "output_format": [
      "{ blog_text }",
      "author_id { name, birthdate }",
      "list_comment { comment_text } -&gt; blog_id -&gt; *"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": [
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 1,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 3,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 5,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 7,
               "comment_text": "comment_1 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 2,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 4,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 6,
               "comment_text": "comment_2 text"
            },
            {
               "blog_id": {
                  "author_id": {
                     "author_id": "author_id_2",
                     "birthdate": "2019-04-01",
                     "name": "author name modified at index 1 => container is dirty !!!",
                     "sex": 1
                  },
                  "blog_id": 1,
                  "blog_text": "blog property 'text' modified => blog is dirty !!!",
                  "date_creation": "2019-04-01T16:18:54",
                  "list_category": [
                     {
                        "key": 1,
                        "value": {
                           "category_id": 1,
                           "description": "desc_1",
                           "name": "category_1"
                        }
                     },
                     {
                        "key": 3,
                        "value": {
                           "category_id": 3,
                           "description": "desc_3",
                           "name": "category_3"
                        }
                     }
                  ],
                  "list_comment": [
                     {
                        "comment_id": 1,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 3,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 5,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 7,
                        "comment_text": "comment_1 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 2,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 4,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 6,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     },
                     {
                        "comment_id": 8,
                        "comment_text": "comment_2 text",
                        "date_creation": "2019-04-01T16:18:54"
                     }
                  ]
               },
               "comment_id": 8,
               "comment_text": "comment_2 text"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 4,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      }
   ],
   "request_id": "4c45fdf9-8001-4509-bb4b-ce27a4a8708a"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9732">fetch_by_id</a></p>
            <div class="manual_div_content">
               The <b><i>fetch_by_id</i></b> action gets an item from a table based on its unique identifier.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> fetch a blog which has an unique identifier equals to 1 :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "4d6fbb9e-e088-482a-abfa-4e7ddee80569",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 1
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "author_id": {
         "author_id": "author_id_2",
         "birthdate": null,
         "list_blog": [],
         "name": "",
         "sex": 2
      },
      "blog_id": 1,
      "blog_text": "blog property 'text' modified => blog is dirty !!!",
      "date_creation": "2019-04-01T16:18:54",
      "list_category": [],
      "list_comment": []
   },
   "request_id": "4d6fbb9e-e088-482a-abfa-4e7ddee80569"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> fetch only some blog's columns which has an unique identifier equals to 1 (other columns are part of JSON response but with an empty or null value) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "72c9b362-d194-410e-98ed-23797a34318e",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 1
   },
   "columns": [
      "blog_text",
      "date_creation"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "author_id": null,
      "blog_id": 1,
      "blog_text": "blog property 'text' modified => blog is dirty !!!",
      "date_creation": "2019-04-01T16:18:54",
      "list_category": [],
      "list_comment": []
   },
   "request_id": "72c9b362-d194-410e-98ed-23797a34318e"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°3 --</b></font> fetch a list of blogs based on their unique identifier :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "59c37f70-26ee-42e5-9177-b32c331adce1",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 2
      },
      {
         "blog_id": 3
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": null,
            "list_blog": [],
            "name": "",
            "sex": 2
         },
         "blog_id": 3,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "date_creation": "2019-04-01T16:18:54",
         "list_category": [],
         "list_comment": []
      }
   ],
   "request_id": "59c37f70-26ee-42e5-9177-b32c331adce1"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°4 --</b></font> fetch a list of blogs (with some relationships) based on their unique identifier, and define a JSON output format (all properties will not be exported to JSON response) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "325d64f4-29ac-47ab-9846-d6a71a9e9d73",
   "action": "fetch_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 2
      }
   ],
   "relations": [
      "{ blog_text }",
      "author_id &lt;author_alias&gt; { name, birthdate }",
      "list_comment &lt;list_comment_alias&gt; { comment_text }"
   ],
   "output_format": [
      "{ blog_text }",
      "author_id { name, birthdate }",
      "list_comment { comment_text }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 1,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": [
            {
               "comment_id": 1,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 2,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 3,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 4,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 5,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 6,
               "comment_text": "comment_2 text"
            },
            {
               "comment_id": 7,
               "comment_text": "comment_1 text"
            },
            {
               "comment_id": 8,
               "comment_text": "comment_2 text"
            }
         ]
      },
      {
         "author_id": {
            "author_id": "author_id_2",
            "birthdate": "2019-04-01",
            "name": "author name modified at index 1 => container is dirty !!!"
         },
         "blog_id": 2,
         "blog_text": "blog property 'text' modified => blog is dirty !!!",
         "list_comment": []
      }
   ],
   "request_id": "325d64f4-29ac-47ab-9846-d6a71a9e9d73"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9733">fetch_by_query</a></p>
            <div class="manual_div_content">
               The <b><i>fetch_by_query</i></b> action gets some items from a table <a href="#manual_360">filtered by a query</a>.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> fetch only items from <i>author</i> table with a sex of type <i>female</i> (<i>female</i> == enum equals to 1) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "c178194c-a76f-4a77-af12-2b97fc7078e4",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [],
         "name": "author name modified at index 1 => container is dirty !!!",
         "sex": 1
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3",
         "sex": 1
      }
   ],
   "request_id": "c178194c-a76f-4a77-af12-2b97fc7078e4"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> fetch some items from <i>author</i> table (and <a href="#manual_3840">all relationships</a>) with a sex of type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "84e2e13a-0bf9-4d78-b655-970568a97e4c",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1,
            "type": "in"
         }
      ]
   },
   "relations": [
      "*"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 1,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 2,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 3,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            },
            {
               "author_id": {
                  "author_id": "author_id_2",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 4,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54",
               "list_category": [],
               "list_comment": []
            }
         ],
         "name": "author name modified at index 1 => container is dirty !!!",
         "sex": 1
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3",
         "sex": 1
      }
   ],
   "request_id": "84e2e13a-0bf9-4d78-b655-970568a97e4c"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°3 --</b></font> fetch some items from <i>author</i> table (and <a href="#manual_3840">all relationships</a>) with a sex of type <i>female</i>, and define a JSON output format (all properties will not be exported to JSON response) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "c18b59e7-54f9-4a4f-843d-f0797f4fb676",
   "action": "fetch_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1,
            "type": "in"
         }
      ]
   },
   "relations": [
      "*"
   ],
   "output_format": [
      "{ birthdate, name }",
      "list_blog { blog_text, date_creation }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_2",
         "birthdate": "2019-04-01",
         "list_blog": [
            {
               "blog_id": 1,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 2,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 3,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            },
            {
               "blog_id": 4,
               "blog_text": "blog property 'text' modified => blog is dirty !!!",
               "date_creation": "2019-04-01T16:18:54"
            }
         ],
         "name": "author name modified at index 1 => container is dirty !!!"
      },
      {
         "author_id": "author_id_3",
         "birthdate": "1998-03-06",
         "list_blog": [],
         "name": "author_3"
      }
   ],
   "request_id": "c18b59e7-54f9-4a4f-843d-f0797f4fb676"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9734">count</a></p>
            <div class="manual_div_content">
               The <b><i>count</i></b> action returns a number of items from a table in database with or without a query (and with or without relationships).
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> count all blogs stored in database :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "1ef62fd7-d847-4d67-9fd0-0207af463aa4",
   "action": "count",
   "entity": "blog"
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 4
   },
   "request_id": "1ef62fd7-d847-4d67-9fd0-0207af463aa4"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> count items from <i>author</i> table with a sex of type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "a80646d1-5a42-46fb-9306-3b91c7f594c8",
   "action": "count",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 2
   },
   "request_id": "a80646d1-5a42-46fb-9306-3b91c7f594c8"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°3 --</b></font> count all blogs associated to an <i>author</i> with a sex of type <i>female</i> :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "6ef252f7-385c-465e-8304-b9afa9fea490",
   "action": "count",
   "entity": "blog",
   "query": {
      "sql": "WHERE author_alias.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   },
   "relations": [
      "author_id &lt;author_alias&gt; { sex }"
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "count": 4
   },
   "request_id": "6ef252f7-385c-465e-8304-b9afa9fea490"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9735">exist</a></p>
            <div class="manual_div_content">
               The <b><i>exist</i></b> action checks if an item from a table exists in database based on its unique identifier.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> check if a blog with unique identifier equals to 1 exists in database :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "e8db33db-b249-4349-93fe-ad12e208520e",
   "action": "exist",
   "entity": "blog",
   "data": {
      "blog_id": 1
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": true
   },
   "request_id": "e8db33db-b249-4349-93fe-ad12e208520e"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> check if several blogs exist (based on their unique identifier) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "f2d6ca3f-36de-4920-8f4c-c04842603467",
   "action": "exist",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 999
      },
      {
         "blog_id": 3
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": false
   },
   "request_id": "f2d6ca3f-36de-4920-8f4c-c04842603467"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°3 --</b></font> check if an <i>author</i> exists :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "2c7df172-8010-4816-b8e1-3edbb0b0b90e",
   "action": "exist",
   "entity": "author",
   "data": {
      "author_id": "author_id_2"
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "exist": true
   },
   "request_id": "2c7df172-8010-4816-b8e1-3edbb0b0b90e"
}</pre>
               </div>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_974">Insert</a></p>
         <div class="manual_div_content">
            The <b><i>insert</i></b> action adds 1 or several items in database.
            Unique identifiers generated by database (for example auto-incremented identifiers) are provided in JSON response.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> insert a blog in database :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "573e4940-607a-4037-8a09-11ec52deb21c",
   "action": "insert",
   "entity": "blog",
   "data": {
      "blog_text": "this is a new blog from QxOrm REST API !",
      "date_creation": "2018-01-30T12:42:01",
      "author_id": "author_id_2"
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 5
   },
   "request_id": "573e4940-607a-4037-8a09-11ec52deb21c"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°2 --</b></font> insert a list of blogs in database :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "6ade2d01-086c-45d6-971b-b65e8836475f",
   "action": "insert",
   "entity": "blog",
   "data": [
      {
         "blog_text": "new blog from QxOrm REST API !",
         "date_creation": "2018-01-30T12:42:01",
         "author_id": "author_id_2"
      },
      {
         "blog_text": "another blog from QxOrm REST API !",
         "date_creation": "2016-06-12T08:33:12",
         "author_id": "author_id_1"
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 6
      },
      {
         "blog_id": 7
      }
   ],
   "request_id": "6ade2d01-086c-45d6-971b-b65e8836475f"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°3 --</b></font> insert an <i>author</i> in database :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57",
   "action": "insert",
   "entity": "author",
   "data": {
      "author_id": "author_id_from_rest_api",
      "birthdate": "1978-05-11",
      "name": "new author created by QxOrm REST API",
      "sex": 1
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "author_id": "author_id_from_rest_api"
   },
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57"
}</pre>
            </div>
            <br/>
            <b>Note :</b> the <i>author</i> table requires an unique identifier filled by caller (because it's not auto-incremented).
            If we execute the same JSON request a second time, then we have following error :
            <br/>
            <div class="json_pretty">
<pre>{
   "error": {
      "code": 19,
      "desc": "Unable to fetch row\ncolumn author_id is not unique"
   },
   "request_id": "0cffa916-99f4-4395-bccd-02918a4b3c57"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_975">Update</a></p>
         <div class="manual_div_content">
            The <b><i>update</i></b> action modifies 1 or several items in database.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> update a blog with unique identifier equals to 1 :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "4fa24a7f-a3d8-4bbf-85c1-c86df83dec0b",
   "action": "update",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": "author_id_1"
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "4fa24a7f-a3d8-4bbf-85c1-c86df83dec0b"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°2 --</b></font> update only some columns of a blog :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "d0704db1-5c3a-48ad-b27e-14aa54ac0efb",
   "action": "update",
   "entity": "blog",
   "data": {
      "blog_id": 2,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33"
   },
   "columns": [
      "blog_text",
      "date_creation"
   ]
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 2
   },
   "request_id": "d0704db1-5c3a-48ad-b27e-14aa54ac0efb"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°3 --</b></font> update a list of <i>author</i> :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "26ec3a7b-cf2d-47f7-bab7-db303f15ee51",
   "action": "update",
   "entity": "author",
   "data": [
      {
         "author_id": "author_id_from_rest_api",
         "birthdate": "1992-11-03",
         "name": "modify author from QxOrm REST API",
         "sex": 0
      },
      {
         "author_id": "author_id_1",
         "birthdate": "1978-12-25",
         "name": "modify another author from QxOrm REST API",
         "sex": 2
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "author_id": "author_id_from_rest_api"
      },
      {
         "author_id": "author_id_1"
      }
   ],
   "request_id": "26ec3a7b-cf2d-47f7-bab7-db303f15ee51"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_976">Save (insert or update)</a></p>
         <div class="manual_div_content">
            The <b><i>save</i></b> action adds or modifies (<i>insert</i> or <i>update</i>) 1 or several items in database.
            When inserting, unique identifiers generated by database (for example auto-incremented identifiers) are provided in JSON response.
            <br/><br/>
            JSON request has an optional parameter named <i>save_mode</i> which can have following values :
            <ul>
               <li><i>check_insert_or_update :</i> save the instance and its relationships recursively (several levels of relations) checking for each relation if an <i>insert</i> or <i>update</i> is required (can be slow with a lot of relations) ;</li>
               <li><i>insert_only :</i> insert recursively (several levels of relations) the instance and its relationships ;</li>
               <li><i>update_only :</i> update recursively (several levels of relations) the instance and its relationships.</li>
            </ul>
            <br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> save (insert or update based on the unique identifier) a blog in database :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ec3c71eb-5014-4b36-85a0-aeb7ae48a5e9",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "modify blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": "author_id_1"
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "ec3c71eb-5014-4b36-85a0-aeb7ae48a5e9"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°2 --</b></font> save (insert or update based on the unique identifier) a list of blogs in database :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "dc7c804e-f95a-4a9b-a4e3-547adcacf090",
   "action": "save",
   "entity": "blog",
   "data": [
      {
         "blog_id": 1,
         "blog_text": "save blog from QxOrm REST API !",
         "date_creation": "2018-01-30T12:42:01",
         "author_id": "author_id_2"
      },
      {
         "blog_text": "save another blog from QxOrm REST API !",
         "date_creation": "2016-06-12T08:33:12",
         "author_id": "author_id_1"
      }
   ]
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 1
      },
      {
         "blog_id": 5
      }
   ],
   "request_id": "dc7c804e-f95a-4a9b-a4e3-547adcacf090"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°3 --</b></font> save (insert or update based on the unique identifier) a blog and all its relationships recursively (several levels) :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "5b78e468-2fa3-4aeb-82ce-4d85408f5fa7",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_id": 1,
      "blog_text": "save recursive blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": {
         "author_id": "author_id_1",
         "birthdate": "1965-07-21",
         "name": "save recursive author from QxOrm REST API",
         "sex": 0
      }
   },
   "save_mode": "check_insert_or_update"
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 1
   },
   "request_id": "5b78e468-2fa3-4aeb-82ce-4d85408f5fa7"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°4 --</b></font> insert (<i>save_mode</i> = <i>insert_only</i>) a blog and all its relationships recursively (several levels) :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ef147c62-74e0-4be2-a294-ffeb020d5304",
   "action": "save",
   "entity": "blog",
   "data": {
      "blog_text": "save recursive - new blog from QxOrm REST API",
      "date_creation": "2013-11-25T09:56:33",
      "author_id": {
         "author_id": "author_id_save_recursive",
         "birthdate": "1965-07-21",
         "name": "save recursive (insert only) author from QxOrm REST API",
         "sex": 0
      }
   },
   "save_mode": "insert_only"
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 7
   },
   "request_id": "ef147c62-74e0-4be2-a294-ffeb020d5304"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_977">Delete</a></p>
         <div class="manual_div_content">
            This chapter provides several ways to remove data from database (delete or destroy) :
            <ul>
               <li>Delete all rows from a table (<a href="#manual_9771">delete_all / destroy_all</a>) ;</li>
               <li>Delete some rows from a table based on a query (<a href="#manual_9772">delete_by_query / destroy_by_query</a>) ;</li>
               <li>Delete some rows from a table based on the unique identifier (<a href="#manual_9773">delete_by_id / destroy_by_id</a>).</li>
            </ul>
            <br/>
            <b>Note :</b> difference between <i>delete</i> and <i>destroy</i> is <a href="#manual_3400">soft delete behaviour (logical delete)</a>.
            <br/><br/>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9771">delete_all / destroy_all</a></p>
            <div class="manual_div_content">
               The <b><i>delete_all</i></b> and <b><i>destroy_all</i></b> actions remove all items (rows) from a table.
               The difference between <i>delete</i> and <i>destroy</i> is <a href="#manual_3400">soft delete behaviour (logical delete)</a>.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> delete all rows from the <i>comment</i> table :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "7b06b5c0-409f-4e0d-bfc4-acafbfe7e796",
   "action": "delete_all",
   "entity": "comment"
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "deleted": true
   },
   "request_id": "7b06b5c0-409f-4e0d-bfc4-acafbfe7e796"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9772">delete_by_query / destroy_by_query</a></p>
            <div class="manual_div_content">
               The <b><i>delete_by_query</i></b> and <b><i>destroy_by_query</i></b> actions remove some items (rows) from a table based on a query.
               The difference between <i>delete</i> and <i>destroy</i> is <a href="#manual_3400">soft delete behaviour (logical delete)</a>.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> delete all rows from the <i>author</i> table with a sex of type <i>female</i> (<i>female</i> = enum with value 1) :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "169ff0be-6e49-457b-a99c-22bd7141dc02",
   "action": "delete_by_query",
   "entity": "author",
   "query": {
      "sql": "WHERE author.sex = :sex",
      "params": [
         {
            "key": ":sex",
            "value": 1
         }
      ]
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "deleted": true
   },
   "request_id": "169ff0be-6e49-457b-a99c-22bd7141dc02"
}</pre>
               </div>
               <br/><br/>
            </div>
            <p class="manual_p_title_3"><a class="manual_a_title_3" name="manual_9773">delete_by_id / destroy_by_id</a></p>
            <div class="manual_div_content">
               The <b><i>delete_by_id</i></b> and <b><i>destroy_by_id</i></b> actions remove some items (rows) from a table based on the unique identifier.
               The difference between <i>delete</i> and <i>destroy</i> is <a href="#manual_3400">soft delete behaviour (logical delete)</a>.
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°1 --</b></font> delete from database the blog with unique identifier equals to 4 :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "80bff383-8ebd-4bde-bb42-37b6f67bc39f",
   "action": "delete_by_id",
   "entity": "blog",
   "data": {
      "blog_id": 4
   }
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": {
      "blog_id": 4
   },
   "request_id": "80bff383-8ebd-4bde-bb42-37b6f67bc39f"
}</pre>
               </div>
               <br/><br/>
               <font style="background-color:yellow"><b>-- Example n°2 --</b></font> delete from database a list of 2 blogs with unique identifier equals to 3 and 2 :
               <br/><br/>
               <font style="color:blue"><i>JSON request :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "request_id": "38020cb7-d725-4c0e-80a0-63db7569155e",
   "action": "delete_by_id",
   "entity": "blog",
   "data": [
      {
         "blog_id": 3
      },
      {
         "blog_id": 2
      }
   ]
}</pre>
               </div>
               <font style="color:blue"><i>JSON response :</i></font><br/>
               <div class="json_pretty">
<pre>{
   "data": [
      {
         "blog_id": 3
      },
      {
         "blog_id": 2
      }
   ],
   "request_id": "38020cb7-d725-4c0e-80a0-63db7569155e"
}</pre>
               </div>
               <br/><br/>
            </div>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_978">Validate</a></p>
         <div class="manual_div_content">
            The <b><i>validate</i></b> action checks some properties of your instance (without triggering any action to database).
            The <b><i>validate</i></b> action calls the <a href="#manual_420">QxValidator module</a> from QxOrm library.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> a <i>blog</i> must contain some text (<i>blog_text</i> property) to be saved in database.
            With the following JSON request, we get a JSON response with an error message which means that the blog instance is not valid :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba",
   "action": "validate",
   "entity": "blog",
   "data": {
      "blog_id": 9999,
      "blog_text": ""
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "invalid_values": [
         "blog",
         [
            {
               "message": "'blog_text' property cannot be empty",
               "path": "blog"
            }
         ]
      ]
   },
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba"
}</pre>
            </div>
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°2 --</b></font> we add a value to <i>blog_text</i> property, so the <i>blog</i> instance becomes valid (the JSON response has an <i>invalid_values</i> property with a <i>null</i> value) :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba",
   "action": "validate",
   "entity": "blog",
   "data": {
      "blog_id": 9999,
      "blog_text": "my blog text !!!"
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "invalid_values": null
   },
   "request_id": "92043c2b-4ba8-4583-8fad-c828251734ba"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_979">Custom SQL query or stored procedure</a></p>
         <div class="manual_div_content">
            The <b><i>call_custom_query</i></b> action executes a custom SQL query or a stored procedure.
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> insert in database a new <i>author</i> with a custom SQL query :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ff2a2256-041d-4c5f-bd86-3745ce46ead8",
   "action": "call_custom_query",
   "query": {
      "sql": "INSERT INTO author (author_id, name, birthdate, sex) VALUES (:author_id, :name, :birthdate, :sex)",
      "params": [
         {
            "key": ":author_id",
            "value": "author_id_custom_query"
         },
         {
            "key": ":name",
            "value": "new author inserted by custom query"
         },
         {
            "key": ":birthdate",
            "value": "20190215"
         },
         {
            "key": ":sex",
            "value": 2
         }
      ]
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "query_output": {
         "distinct": false,
         "list_values": {
            ":author_id": [
               "author_id_custom_query",
               1
            ],
            ":birthdate": [
               "20190215",
               1
            ],
            ":name": [
               "new author inserted by custom query",
               1
            ],
            ":sex": [
               2,
               1
            ]
         },
         "parenthesis_count": 0,
         "query": [
            "INSERT INTO author (author_id, name, birthdate, sex) VALUES (:author_id, :name, :birthdate, :sex)"
         ],
         "response": "",
         "result_position_by_key": {},
         "result_values": [],
         "sql_element_index": 0,
         "sql_element_list": [],
         "sql_element_temp_type": 0,
         "type": ""
      }
   },
   "request_id": "ff2a2256-041d-4c5f-bd86-3745ce46ead8"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_961">Call C++ natives functions</a></p>
         <div class="manual_div_content">
            The <b><i>call_entity_function</i></b> action executes C++ natives functions registered into QxOrm context.<br/>
            <b>Prerequisites :</b> the C++ native function must be a <i>static</i> method with this signature : <b><i><font style="background-color:yellow">static QJsonValue myNativeCppFct(const QJsonValue & request);</font></i></b>
            <br/><br/>
            Here is an example of C++ function registered into QxOrm context, this function can be called by the JSON API engine (<i>QxRestApi</i> module) :
            <br/><br/>
            <table border="1" bgcolor="#FFFFFF"><col><tbody><tr><td>
<pre><span class="keyword">namespace</span> qx {
<span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> register_class(QxClass&lt;blog&gt; & t)
{
   <span class="comment">// Register 'helloWorld()' static function in QxOrm context (can be called by QxRestApi JSON API module)</span>
   t.fctStatic_1&lt;<span class="type">QJsonValue</span>, const <span class="type">QJsonValue</span> & &gt;(& blog::helloWorld, <span class="string">"helloWorld"</span>);
}}

<span class="comment">// 'helloWorld()' static function implementation</span>
<span class="type">QJsonValue</span> blog::helloWorld(const <span class="type">QJsonValue</span> & request)
{
   <span class="type">QJsonObject</span> response;
   response.insert(<span class="string">"request"</span>, request);
   response.insert(<span class="string">"response"</span>, QString(<span class="string">"Hello World !"</span>));
   return response;
}</pre>
            </td></tr></tbody></table>
            <br/><br/>
            Here is how to execute the C++ <i>helloWorld</i> function from JSON API using <b><i>call_entity_function</i></b> action :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "ab1ba7d3-9f98-4b18-a310-a9c34498d043",
   "action": "call_entity_function",
   "entity": "blog",
   "fct": "helloWorld",
   "data": {
      "param1": "test",
      "param2": "static fct call"
   }
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "request": {
         "param1": "test",
         "param2": "static fct call"
      },
      "response": "Hello World !"
   },
   "request_id": "ab1ba7d3-9f98-4b18-a310-a9c34498d043"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_962">Meta-data (C++ classes registered into QxOrm context)</a></p>
         <div class="manual_div_content">
            The <b><i>get_meta_data</i></b> action fetches some meta-data from 1 or all entities registered into QxOrm context (C++ classes structure with list of properties and relationships).
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> get all meta-data of <a href="#manual_972"><i>qxBlogRestApi</i> example project</a> :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "request_id": "842ed7b5-9b94-455f-86dc-32992866b3d5",
   "action": "get_meta_data",
   "entity": "*"
}</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>{
   "data": {
      "entities": [
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "author_id",
               "type": "QString"
            },
            "key": "author",
            "name": "author",
            "properties": [
               {
                  "description": "",
                  "key": "name",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "birthdate",
                  "type": "QDate"
               },
               {
                  "description": "",
                  "key": "sex",
                  "type": "enum author::enum_sex *"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "list_blog",
                  "target": "blog",
                  "type": "std::vector&lt;std::shared_ptr&lt;blog&gt;&gt;",
                  "type_relation": "relation one-to-many"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "blog_id",
               "type": "long"
            },
            "key": "blog",
            "name": "blog",
            "properties": [
               {
                  "description": "",
                  "key": "blog_text",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "date_creation",
                  "type": "QDateTime"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "author_id",
                  "target": "author",
                  "type": "std::shared_ptr&lt;author&gt;",
                  "type_relation": "relation many-to-one"
               },
               {
                  "description": "",
                  "key": "list_comment",
                  "target": "comment",
                  "type": "QList&lt;std::shared_ptr&lt;comment&gt;&gt;",
                  "type_relation": "relation one-to-many"
               },
               {
                  "description": "",
                  "key": "list_category",
                  "target": "category",
                  "type": "qx::QxCollection&lt;long, QSharedPointer&lt;category&gt;&gt;",
                  "type_relation": "relation many-to-many"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "comment_id",
               "type": "long"
            },
            "key": "comment",
            "name": "comment",
            "properties": [
               {
                  "description": "",
                  "key": "comment_text",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "date_creation",
                  "type": "QDateTime"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "blog_id",
                  "target": "blog",
                  "type": "std::shared_ptr&lt;blog&gt;",
                  "type_relation": "relation many-to-one"
               }
            ],
            "version": 0
         },
         {
            "base_entity": "",
            "description": "",
            "entity_id": {
               "description": "",
               "key": "category_id",
               "type": "long"
            },
            "key": "category",
            "name": "category",
            "properties": [
               {
                  "description": "",
                  "key": "name",
                  "type": "QString"
               },
               {
                  "description": "",
                  "key": "description",
                  "type": "QString"
               }
            ],
            "relations": [
               {
                  "description": "",
                  "key": "list_blog",
                  "target": "blog",
                  "type": "qx::QxCollection&lt;long, std::shared_ptr&lt;blog&gt;&gt;",
                  "type_relation": "relation many-to-many"
               }
            ],
            "version": 0
         }
      ]
   },
   "request_id": "842ed7b5-9b94-455f-86dc-32992866b3d5"
}</pre>
            </div>
            <br/><br/>
         </div>
         <p class="manual_p_title_2"><a class="manual_a_title_2" name="manual_963">Send a list of JSON requests</a></p>
         <div class="manual_div_content">
            To limit transactions count between client and server, it is possible to send a list of JSON requests to <b>QxRestApi module</b>.
            Each JSON request can contain its own unique identifier <i>request_id</i> (to match a JSON response with the right JSON request).
            When a list of JSON requests is sent to <b>QxRestApi module</b>, then <a href="#manual_370">a transaction (commit/rollback)</a> is automatically created (so if an error occurred, then all actions in database are cancelled).
            <br/><br/>
            <font style="background-color:yellow"><b>-- Example n°1 --</b></font> send a list of 4 JSON requests to <b>QxRestApi module</b> (1 request to <a href="#manual_962">fetch project meta-data</a> + 3 requests to <a href="#manual_9731"><i>fetch_all</i> blogs with several ways to get relationships</a>) :
            <br/><br/>
            <font style="color:blue"><i>JSON request :</i></font><br/>
            <div class="json_pretty">
<pre>[
   {
      "request_id": "53c96a23-2566-4b3d-ae6c-bff634600e79",
      "action": "get_meta_data",
      "entity": "*"
   },
   {
      "request_id": "56e3ca99-5c12-4aca-aa6c-7d0e43c1e636",
      "action": "fetch_all",
      "entity": "blog"
   },
   {
      "request_id": "692968e4-8885-41ad-b918-6ce2791b3bb8",
      "action": "fetch_all",
      "entity": "blog",
      "data": [
         {
            "key": "",
            "value": ""
         }
      ]
   },
   {
      "request_id": "4ffe38a6-d642-44b0-8be1-198e84256321",
      "action": "fetch_all",
      "entity": "blog",
      "relations": [
         "*->*"
      ]
   }
]</pre>
            </div>
            <font style="color:blue"><i>JSON response :</i></font><br/>
            <div class="json_pretty">
<pre>[
   {
      "data": {
         "entities": [
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "author_id",
                  "type": "QString"
               },
               "key": "author",
               "name": "author",
               "properties": [
                  {
                     "description": "",
                     "key": "name",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "birthdate",
                     "type": "QDate"
                  },
                  {
                     "description": "",
                     "key": "sex",
                     "type": "enum author::enum_sex *"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "list_blog",
                     "target": "blog",
                     "type": "std::vector&lt;std::shared_ptr&lt;blog&gt;&gt;",
                     "type_relation": "relation one-to-many"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "blog_id",
                  "type": "long"
               },
               "key": "blog",
               "name": "blog",
               "properties": [
                  {
                     "description": "",
                     "key": "blog_text",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "date_creation",
                     "type": "QDateTime"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "author_id",
                     "target": "author",
                     "type": "std::shared_ptr&lt;author&gt;",
                     "type_relation": "relation many-to-one"
                  },
                  {
                     "description": "",
                     "key": "list_comment",
                     "target": "comment",
                     "type": "QList&lt;std::shared_ptr&lt;comment&gt;&gt;",
                     "type_relation": "relation one-to-many"
                  },
                  {
                     "description": "",
                     "key": "list_category",
                     "target": "category",
                     "type": "qx::QxCollection&lt;long, QSharedPointer&lt;category&gt;&gt;",
                     "type_relation": "relation many-to-many"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "comment_id",
                  "type": "long"
               },
               "key": "comment",
               "name": "comment",
               "properties": [
                  {
                     "description": "",
                     "key": "comment_text",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "date_creation",
                     "type": "QDateTime"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "blog_id",
                     "target": "blog",
                     "type": "std::shared_ptr&lt;blog&gt;",
                     "type_relation": "relation many-to-one"
                  }
               ],
               "version": 0
            },
            {
               "base_entity": "",
               "description": "",
               "entity_id": {
                  "description": "",
                  "key": "category_id",
                  "type": "long"
               },
               "key": "category",
               "name": "category",
               "properties": [
                  {
                     "description": "",
                     "key": "name",
                     "type": "QString"
                  },
                  {
                     "description": "",
                     "key": "description",
                     "type": "QString"
                  }
               ],
               "relations": [
                  {
                     "description": "",
                     "key": "list_blog",
                     "target": "blog",
                     "type": "qx::QxCollection&lt;long, std::shared_ptr&lt;blog&gt;&gt;",
                     "type_relation": "relation many-to-many"
                  }
               ],
               "version": 0
            }
         ]
      },
      "request_id": "53c96a23-2566-4b3d-ae6c-bff634600e79"
   },
   {
      "data": [
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 1,
            "blog_text": "save recursive blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 5,
            "blog_text": "save another blog from QxOrm REST API !",
            "date_creation": "2016-06-12T08:33:12",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 6,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 7,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         }
      ],
      "request_id": "56e3ca99-5c12-4aca-aa6c-7d0e43c1e636"
   },
   {
      "data": [
         {
            "key": 1,
            "value": {
               "author_id": {
                  "author_id": "author_id_1",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 1,
               "blog_text": "save recursive blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 5,
            "value": {
               "author_id": {
                  "author_id": "author_id_1",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 5,
               "blog_text": "save another blog from QxOrm REST API !",
               "date_creation": "2016-06-12T08:33:12",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 6,
            "value": {
               "author_id": {
                  "author_id": "author_id_save_recursive",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 6,
               "blog_text": "save recursive - new blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         },
         {
            "key": 7,
            "value": {
               "author_id": {
                  "author_id": "author_id_save_recursive",
                  "birthdate": null,
                  "list_blog": [],
                  "name": "",
                  "sex": 2
               },
               "blog_id": 7,
               "blog_text": "save recursive - new blog from QxOrm REST API",
               "date_creation": "2013-11-25T09:56:33",
               "list_category": [],
               "list_comment": []
            }
         }
      ],
      "request_id": "692968e4-8885-41ad-b918-6ce2791b3bb8"
   },
   {
      "data": [
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": "2019-04-02",
               "list_blog": [
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 5,
                     "blog_text": "save another blog from QxOrm REST API !",
                     "date_creation": "2016-06-12T08:33:12",
                     "list_category": [],
                     "list_comment": []
                  },
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 1,
                     "blog_text": "save recursive blog from QxOrm REST API",
                     "date_creation": "2013-11-25T09:56:33",
                     "list_category": [],
                     "list_comment": []
                  }
               ],
               "name": "author_1",
               "sex": 0
            },
            "blog_id": 1,
            "blog_text": "save recursive blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_1",
               "birthdate": "2019-04-02",
               "list_blog": [
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 5,
                     "blog_text": "save another blog from QxOrm REST API !",
                     "date_creation": "2016-06-12T08:33:12",
                     "list_category": [],
                     "list_comment": []
                  },
                  {
                     "author_id": {
                        "author_id": "author_id_1",
                        "birthdate": null,
                        "list_blog": [],
                        "name": "",
                        "sex": 2
                     },
                     "blog_id": 1,
                     "blog_text": "save recursive blog from QxOrm REST API",
                     "date_creation": "2013-11-25T09:56:33",
                     "list_category": [],
                     "list_comment": []
                  }
               ],
               "name": "author_1",
               "sex": 0
            },
            "blog_id": 5,
            "blog_text": "save another blog from QxOrm REST API !",
            "date_creation": "2016-06-12T08:33:12",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 6,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         },
         {
            "author_id": {
               "author_id": "author_id_save_recursive",
               "birthdate": null,
               "list_blog": [],
               "name": "",
               "sex": 2
            },
            "blog_id": 7,
            "blog_text": "save recursive - new blog from QxOrm REST API",
            "date_creation": "2013-11-25T09:56:33",
            "list_category": [],
            "list_comment": []
         }
      ],
      "request_id": "4ffe38a6-d642-44b0-8be1-198e84256321"
   }
]</pre>
            </div>
            <br/><br/>
         </div>
      </div>

      </div>
      </td>
    </tr>
  </tbody>
</table>
<br><hr style="width: 80%" align="center" size="1" color="#100D5A">
<table border="0" style="width: 80%" align="center">
  <col><col><col>
  <tbody>
    <tr>
      <td align="left" valign="middle">
        <img alt="QxOrm" src="./resource/logo_qxorm_small.png" width="168" height="40">
      </td>
      <td align="center" valign="middle">
        <font size="2">© 2011-2024 Lionel Marty - <a href="mailto:contact@qxorm.com">contact@qxorm.com</a></font>
      </td>
      <td align="right" valign="middle">
        <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
           <input type="hidden" name="cmd" value="_s-xclick">
           <input type="hidden" name="hosted_button_id" value="2K4Z58ZYAYJ6S">
           <input type="image" src="./resource/paypal_support_qxorm_library.gif" border="0" name="submit" alt="Support QxOrm library - PayPal">
           <img alt="" border="0" src="https://www.paypalobjects.com/fr_FR/i/scr/pixel.gif" width="1" height="1">
        </form>
      </td>
    </tr>
  </tbody>
</table>
</body>
</html>
